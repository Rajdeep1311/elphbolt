var tipuesearch = {"pages":[{"title":" elphbolt ","text":"elphbolt Developer Info Nakib Haider Protik","tags":"home","loc":"index.html"},{"title":"params.f90 – elphbolt","text":"Files dependent on this one sourcefile~~params.f90~~AfferentGraph sourcefile~params.f90 params.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~interactions.f90->sourcefile~params.f90 sourcefile~misc.f90 misc.f90 sourcefile~interactions.f90->sourcefile~misc.f90 sourcefile~numerics.f90 numerics.f90 sourcefile~interactions.f90->sourcefile~numerics.f90 sourcefile~electron.f90 electron.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~crystal.f90 crystal.f90 sourcefile~interactions.f90->sourcefile~crystal.f90 sourcefile~wannier.f90 wannier.f90 sourcefile~interactions.f90->sourcefile~wannier.f90 sourcefile~delta.f90 delta.f90 sourcefile~interactions.f90->sourcefile~delta.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 sourcefile~misc.f90->sourcefile~params.f90 sourcefile~numerics.f90->sourcefile~params.f90 sourcefile~numerics.f90->sourcefile~misc.f90 sourcefile~numerics.f90->sourcefile~crystal.f90 sourcefile~electron.f90->sourcefile~params.f90 sourcefile~electron.f90->sourcefile~misc.f90 sourcefile~electron.f90->sourcefile~numerics.f90 sourcefile~electron.f90->sourcefile~crystal.f90 sourcefile~electron.f90->sourcefile~wannier.f90 sourcefile~symmetry.f90 symmetry.f90 sourcefile~electron.f90->sourcefile~symmetry.f90 sourcefile~electron.f90->sourcefile~delta.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~bz_sums.f90->sourcefile~params.f90 sourcefile~bz_sums.f90->sourcefile~misc.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 sourcefile~bz_sums.f90->sourcefile~crystal.f90 sourcefile~bz_sums.f90->sourcefile~symmetry.f90 sourcefile~bz_sums.f90->sourcefile~delta.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 sourcefile~spglib_wrapper.f90 spglib_wrapper.f90 sourcefile~spglib_wrapper.f90->sourcefile~params.f90 sourcefile~bte.f90 bte.f90 sourcefile~bte.f90->sourcefile~params.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~bte.f90->sourcefile~misc.f90 sourcefile~bte.f90->sourcefile~numerics.f90 sourcefile~bte.f90->sourcefile~electron.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~bte.f90->sourcefile~crystal.f90 sourcefile~bte.f90->sourcefile~symmetry.f90 sourcefile~bte.f90->sourcefile~phonon.f90 sourcefile~crystal.f90->sourcefile~params.f90 sourcefile~crystal.f90->sourcefile~misc.f90 sourcefile~wannier.f90->sourcefile~params.f90 sourcefile~wannier.f90->sourcefile~misc.f90 sourcefile~wannier.f90->sourcefile~numerics.f90 sourcefile~wannier.f90->sourcefile~crystal.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~params.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90->sourcefile~misc.f90 sourcefile~elphbolt.f90->sourcefile~numerics.f90 sourcefile~elphbolt.f90->sourcefile~electron.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 sourcefile~elphbolt.f90->sourcefile~crystal.f90 sourcefile~elphbolt.f90->sourcefile~wannier.f90 sourcefile~elphbolt.f90->sourcefile~symmetry.f90 sourcefile~elphbolt.f90->sourcefile~phonon.f90 sourcefile~symmetry.f90->sourcefile~params.f90 sourcefile~symmetry.f90->sourcefile~misc.f90 sourcefile~symmetry.f90->sourcefile~spglib_wrapper.f90 sourcefile~symmetry.f90->sourcefile~crystal.f90 sourcefile~delta.f90->sourcefile~params.f90 sourcefile~delta.f90->sourcefile~misc.f90 sourcefile~phonon.f90->sourcefile~params.f90 sourcefile~phonon.f90->sourcefile~misc.f90 sourcefile~phonon.f90->sourcefile~numerics.f90 sourcefile~phonon.f90->sourcefile~crystal.f90 sourcefile~phonon.f90->sourcefile~wannier.f90 sourcefile~phonon.f90->sourcefile~symmetry.f90 sourcefile~phonon.f90->sourcefile~delta.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules params Source Code params.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module params !! Module containing various parameters and constants. implicit none integer , parameter :: r_int = 12 !! Exponent range for reals. integer , parameter :: r_real = 200 !! Exponent range for reals. integer , parameter :: p_real = 14 !! Number of digits for reals. integer , parameter :: dp = selected_real_kind ( p_real , r_real ) !! Custom real precision. integer , parameter :: k8 = selected_int_kind ( r_int ) !! Custom integer precision. !Physical constants: real ( dp ), parameter :: qe = 1.602176634e-19_dp !! Electron charge magnitude (C) real ( dp ), parameter :: me = 9.1093837015e-31_dp !! Electron mass (Kg) real ( dp ), parameter :: amu = 1.66053906660e-27_dp !! Atomic mass unit (Kg) real ( dp ), parameter :: hbar = 1.05457172647e-22_dp !! Reduced Planck's constant (J/THz = J.ps) real ( dp ), parameter :: hbar_eVps = hbar / qe !! Reduced Planck's constant (eV/THz = eV.ps) real ( dp ), parameter :: perm0 = 8.854187817e-12_dp !! Permittivity of free space (F/m) real ( dp ), parameter :: kB = 1.380649e-23_dp / qe !! Boltzmann constant (eV/K) real ( dp ), parameter :: pi = 4.0_dp * atan ( 1.0_dp ) !! Value of pi real ( dp ), parameter :: twopi = 2.0_dp * pi !! Value of 2pi !Conversion factors: real ( dp ), parameter :: Hartree2radTHz = 2 7.2116_dp * qe / hbar !Hartree to rad.THz real ( dp ), parameter :: Hartree2eV = 2 7.2116_dp !Hartree to eV real ( dp ), parameter :: Ryd2radTHz = 0.5_dp * Hartree2radTHz !Rydberg to rad.THz real ( dp ), parameter :: Ryd2eV = 0.5_dp * Hartree2eV !Rydberg to eV real ( dp ), parameter :: Ryd2meV = Ryd2eV * 1.0e3_dp !Rydberg to meV real ( dp ), parameter :: Ryd2amu = 2.0_dp * me / amu !Rydberg mass to amu real ( dp ), parameter :: bohr2nm = 0.052917721092_dp !Bohr to nm !Miscellaneous complex ( dp ), parameter :: oneI = ( 0.0_dp , 1.0_dp ) complex ( dp ), parameter :: twopiI = twopi * oneI !The code below is adapted from ShengBTE (file data.f90): !Periodic table from ShengBTE character ( len = 3 ), parameter :: periodic_table ( 114 ) = [ character ( len = 3 ) :: & \"H\" , \"He\" , \"Li\" , \"Be\" , \"B\" , \"C\" , \"N\" , \"O\" , & \"F\" , \"Ne\" , \"Na\" , \"Mg\" , \"Al\" , \"Si\" , \"P\" , \"S\" , \"Cl\" , \"Ar\" , \"K\" , \"Ca\" , \"Sc\" , \"Ti\" , \"V\" , & \"Cr\" , \"Mn\" , \"Fe\" , \"Co\" , \"Ni\" , \"Cu\" , \"Zn\" , \"Ga\" , \"Ge\" , \"As\" , \"Se\" , \"Br\" , \"Kr\" , \"Rb\" , & \"Sr\" , \"Y\" , \"Zr\" , \"Nb\" , \"Mo\" , \"Tc\" , \"Ru\" , \"Rh\" , \"Pd\" , \"Ag\" , \"Cd\" , \"In\" , \"Sn\" , \"Sb\" , & \"Te\" , \"I\" , \"Xe\" , \"Cs\" , \"Ba\" , \"La\" , \"Ce\" , \"Pr\" , \"Nd\" , \"Pm\" , \"Sm\" , \"Eu\" , \"Gd\" , \"Tb\" , & \"Dy\" , \"Ho\" , \"Er\" , \"Tm\" , \"Yb\" , \"Lu\" , \"Hf\" , \"Ta\" , \"W\" , \"Re\" , \"Os\" , \"Ir\" , \"Pt\" , \"Au\" , \"Hg\" , & \"Tl\" , \"Pb\" , \"Bi\" , \"Po\" , \"At\" , \"Rn\" , \"Fr\" , \"Ra\" , \"Ac\" , \"Th\" , \"Pa\" , \"U\" , \"Np\" , \"Pu\" , \"Am\" , & \"Cm\" , \"Bk\" , \"Cf\" , \"Es\" , \"Fm\" , \"Md\" , \"No\" , \"Lr\" , \"Rf\" , \"Db\" , \"Sg\" , \"Bh\" , \"Hs\" , \"Mt\" , \"Ds\" ,& \"Rg\" , \"Cn\" , \"Uuq\" , \"Uuh\" ] end module params","tags":"","loc":"sourcefile/params.f90.html"},{"title":"bte.f90 – elphbolt","text":"This file depends on sourcefile~~bte.f90~~EfferentGraph sourcefile~bte.f90 bte.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~misc.f90 misc.f90 sourcefile~bte.f90->sourcefile~misc.f90 sourcefile~numerics.f90 numerics.f90 sourcefile~bte.f90->sourcefile~numerics.f90 sourcefile~electron.f90 electron.f90 sourcefile~bte.f90->sourcefile~electron.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~crystal.f90 crystal.f90 sourcefile~bte.f90->sourcefile~crystal.f90 sourcefile~params.f90 params.f90 sourcefile~bte.f90->sourcefile~params.f90 sourcefile~symmetry.f90 symmetry.f90 sourcefile~bte.f90->sourcefile~symmetry.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~bte.f90->sourcefile~phonon.f90 sourcefile~interactions.f90->sourcefile~misc.f90 sourcefile~interactions.f90->sourcefile~numerics.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~interactions.f90->sourcefile~crystal.f90 sourcefile~interactions.f90->sourcefile~params.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 sourcefile~wannier.f90 wannier.f90 sourcefile~interactions.f90->sourcefile~wannier.f90 sourcefile~delta.f90 delta.f90 sourcefile~interactions.f90->sourcefile~delta.f90 sourcefile~misc.f90->sourcefile~params.f90 sourcefile~numerics.f90->sourcefile~misc.f90 sourcefile~numerics.f90->sourcefile~crystal.f90 sourcefile~numerics.f90->sourcefile~params.f90 sourcefile~electron.f90->sourcefile~misc.f90 sourcefile~electron.f90->sourcefile~numerics.f90 sourcefile~electron.f90->sourcefile~crystal.f90 sourcefile~electron.f90->sourcefile~params.f90 sourcefile~electron.f90->sourcefile~symmetry.f90 sourcefile~electron.f90->sourcefile~wannier.f90 sourcefile~electron.f90->sourcefile~delta.f90 sourcefile~bz_sums.f90->sourcefile~misc.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 sourcefile~bz_sums.f90->sourcefile~crystal.f90 sourcefile~bz_sums.f90->sourcefile~params.f90 sourcefile~bz_sums.f90->sourcefile~symmetry.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 sourcefile~bz_sums.f90->sourcefile~delta.f90 sourcefile~crystal.f90->sourcefile~misc.f90 sourcefile~crystal.f90->sourcefile~params.f90 sourcefile~symmetry.f90->sourcefile~misc.f90 sourcefile~symmetry.f90->sourcefile~crystal.f90 sourcefile~symmetry.f90->sourcefile~params.f90 sourcefile~spglib_wrapper.f90 spglib_wrapper.f90 sourcefile~symmetry.f90->sourcefile~spglib_wrapper.f90 sourcefile~phonon.f90->sourcefile~misc.f90 sourcefile~phonon.f90->sourcefile~numerics.f90 sourcefile~phonon.f90->sourcefile~crystal.f90 sourcefile~phonon.f90->sourcefile~params.f90 sourcefile~phonon.f90->sourcefile~symmetry.f90 sourcefile~phonon.f90->sourcefile~wannier.f90 sourcefile~phonon.f90->sourcefile~delta.f90 sourcefile~wannier.f90->sourcefile~misc.f90 sourcefile~wannier.f90->sourcefile~numerics.f90 sourcefile~wannier.f90->sourcefile~crystal.f90 sourcefile~wannier.f90->sourcefile~params.f90 sourcefile~spglib_wrapper.f90->sourcefile~params.f90 sourcefile~delta.f90->sourcefile~misc.f90 sourcefile~delta.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~bte.f90~~AfferentGraph sourcefile~bte.f90 bte.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules bte_module Source Code bte.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module bte_module !! Module containing type and procedures related to the solution of the !! Boltzmann transport equation (BTE). use params , only : dp , k8 , qe , kB use misc , only : print_message , exit_with_message , write2file_rank2_real , & distribute_points , demux_state , binsearch , interpolate , demux_vector , & trace , subtitle , append2file_transport_tensor , write2file_response , & linspace , readfile_response , write2file_spectral_tensor , subtitle use numerics_module , only : numerics use crystal_module , only : crystal use symmetry_module , only : symmetry use phonon_module , only : phonon use electron_module , only : electron use interactions , only : calculate_ph_rta_rates , read_transition_probs_e , & calculate_el_rta_rates use bz_sums , only : calculate_transport_coeff , calculate_spectral_transport_coeff implicit none private public bte type bte !! Data and procedures related to the BTE. real ( dp ), allocatable :: ph_rta_rates_iso_ibz (:,:) !! Phonon RTA scattering rates on the IBZ due to isotope scattering. real ( dp ), allocatable :: ph_rta_rates_subs_ibz (:,:) !! Phonon RTA scattering rates on the IBZ due to substitution scattering. real ( dp ), allocatable :: ph_rta_rates_ibz (:,:) !! Phonon RTA scattering rates on the IBZ. real ( dp ), allocatable :: ph_field_term_T (:,:,:) !! Phonon field coupling term for gradT field on the FBZ. real ( dp ), allocatable :: ph_response_T (:,:,:) !! Phonon response function for gradT field on the FBZ. real ( dp ), allocatable :: ph_field_term_E (:,:,:) !! Phonon field coupling term for E field on the FBZ. real ( dp ), allocatable :: ph_response_E (:,:,:) !! Phonon response function for E field on the FBZ. real ( dp ), allocatable :: el_rta_rates_echimp_ibz (:,:) !! Electron RTA scattering rates on the IBZ due to charged impurity scattering. real ( dp ), allocatable :: el_rta_rates_ibz (:,:) !! Electron RTA scattering rates on the IBZ. real ( dp ), allocatable :: el_field_term_T (:,:,:) !! Electron field coupling term for gradT field on the FBZ. real ( dp ), allocatable :: el_response_T (:,:,:) !! Electron response function for gradT field on the FBZ. real ( dp ), allocatable :: el_field_term_E (:,:,:) !! Electron field coupling term for E field on the FBZ. real ( dp ), allocatable :: el_response_E (:,:,:) !! Electron response function for E field on the FBZ. contains procedure :: solve_bte , post_process end type bte contains subroutine solve_bte ( bt , num , crys , sym , ph , el ) !! Subroutine to solve the BTE !! !! bt BTE object !! num Numerics object !! crys Crystal object !! sym Symmertry object !! ph Phonon object !! el Electron object class ( bte ), intent ( inout ) :: bt type ( numerics ), intent ( in ) :: num type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( phonon ), intent ( in ) :: ph type ( electron ), intent ( in ), optional :: el !Local variables character ( len = 1024 ) :: tag , Tdir , tableheader integer ( k8 ) :: iq , ik , it_ph , it_el , icart real ( dp ), allocatable :: rates_3ph (:,:), rates_phe (:,:), rates_eph (:,:), & I_diff (:,:,:), I_drag (:,:,:), ph_kappa (:,:,:), ph_alphabyT (:,:,:), & el_sigma (:,:,:), el_sigmaS (:,:,:), el_alphabyT (:,:,:), el_kappa0 (:,:,:), & dummy (:,:,:), ph_drag_term_T (:,:,:), ph_drag_term_E (:,:,:) real ( dp ) :: ph_kappa_scalar , ph_kappa_scalar_old , el_sigma_scalar , el_sigma_scalar_old , & el_sigmaS_scalar , el_sigmaS_scalar_old , el_kappa0_scalar , el_kappa0_scalar_old , & ph_alphabyT_scalar , ph_alphabyT_scalar_old , el_alphabyT_scalar , el_alphabyT_scalar_old , & KO_dev , tot_alphabyT_scalar , lambda call subtitle ( \"Calculating transport...\" ) call print_message ( \"Only the trace-averaged transport coefficients are printed below:\" ) !Create output folder tagged by temperature and create it write ( tag , \"(E9.3)\" ) crys % T Tdir = trim ( adjustl ( num % cwd )) // '/T' // trim ( adjustl ( tag )) if ( this_image () == 1 ) then call system ( 'mkdir -p ' // trim ( adjustl ( Tdir ))) end if sync all if (. not . num % onlyebte ) then !Allocate phonon transport coefficients allocate ( ph_kappa ( ph % numbranches , 3 , 3 ), ph_alphabyT ( ph % numbranches , 3 , 3 ), & dummy ( ph % numbranches , 3 , 3 )) !Allocate total RTA scattering rates allocate ( bt % ph_rta_rates_ibz ( ph % nq_irred , ph % numbranches )) !Calculate RTA scattering rates if ( num % phe ) then call calculate_ph_rta_rates ( rates_3ph , rates_phe , num , crys , ph , el ) else call calculate_ph_rta_rates ( rates_3ph , rates_phe , num , crys , ph ) end if !Matthiessen's rule bt % ph_rta_rates_ibz = rates_3ph + rates_phe + & bt % ph_rta_rates_iso_ibz + bt % ph_rta_rates_subs_ibz !gradT field: ! Calculate field term (gradT=>F0) call calculate_field_term ( 'ph' , 'T' , ph % nequiv , ph % ibz2fbz_map , & crys % T , 0.0_dp , ph % ens , ph % vels , bt % ph_rta_rates_ibz , bt % ph_field_term_T ) ! Symmetrize field term do iq = 1 , ph % nq bt % ph_field_term_T ( iq ,:,:) = transpose (& matmul ( ph % symmetrizers (:,:, iq ), transpose ( bt % ph_field_term_T ( iq ,:,:)))) end do ! RTA solution of BTE allocate ( bt % ph_response_T ( ph % nq , ph % numbranches , 3 )) bt % ph_response_T = bt % ph_field_term_T ! Calculate transport coefficient call calculate_transport_coeff ( 'ph' , 'T' , crys % T , 1_k8 , 0.0_dp , ph % ens , ph % vels , & crys % volume , ph % qmesh , bt % ph_response_T , sym , ph_kappa , dummy ) !---------------------------------------------------------------------------------! !E field: ! Calculate field term (E=>G0) call calculate_field_term ( 'ph' , 'E' , ph % nequiv , ph % ibz2fbz_map , & crys % T , 0.0_dp , ph % ens , ph % vels , bt % ph_rta_rates_ibz , bt % ph_field_term_E ) ! RTA solution of BTE allocate ( bt % ph_response_E ( ph % nq , ph % numbranches , 3 )) bt % ph_response_E = bt % ph_field_term_E ! Calculate transport coefficient call calculate_transport_coeff ( 'ph' , 'E' , crys % T , 1_k8 , 0.0_dp , ph % ens , ph % vels , & crys % volume , ph % qmesh , bt % ph_response_E , sym , ph_alphabyT , dummy ) ph_alphabyT = ph_alphabyT / crys % T !---------------------------------------------------------------------------------! !Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) !Write T-dependent RTA scattering rates to file call write2file_rank2_real ( 'ph.W_rta_3ph' , rates_3ph ) call write2file_rank2_real ( 'ph.W_rta_phe' , rates_phe ) call write2file_rank2_real ( 'ph.W_rta' , bt % ph_rta_rates_ibz ) !Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) !Calculate and print transport scalars !gradT: ph_kappa_scalar = trace ( sum ( ph_kappa , dim = 1 )) / crys % dim !E: ph_alphabyT_scalar = trace ( sum ( ph_alphabyT , dim = 1 )) / crys % dim if (. not . num % drag . and . this_image () == 1 ) then write ( * , * ) \"iter    k_ph[W/m/K]\" write ( * , \"(I3, A, 1E16.8)\" ) 0 , \"    \" , ph_kappa_scalar end if ph_kappa_scalar_old = ph_kappa_scalar ph_alphabyT_scalar_old = ph_alphabyT_scalar ! Append RTA coefficients in no-drag files ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'nodrag_ph_kappa_' , 0_k8 , ph_kappa ) ! Print RTA band/branch resolved response functions call write2file_response ( 'RTA_F0_' , bt % ph_response_T ) !gradT, ph ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) end if if (. not . num % onlyphbte ) then !Allocate electron transport coefficients allocate ( el_sigma ( el % numbands , 3 , 3 ), el_sigmaS ( el % numbands , 3 , 3 ), & el_alphabyT ( el % numbands , 3 , 3 ), el_kappa0 ( el % numbands , 3 , 3 )) !Calculate RTA scattering rates call calculate_el_rta_rates ( rates_eph , bt % el_rta_rates_echimp_ibz , num , crys , el ) !Allocate total RTA scattering rates allocate ( bt % el_rta_rates_ibz ( el % nk_irred , el % numbands )) !Matthiessen's rule bt % el_rta_rates_ibz = rates_eph + bt % el_rta_rates_echimp_ibz !gradT field: ! Calculate field term (gradT=>I0) call calculate_field_term ( 'el' , 'T' , el % nequiv , el % ibz2fbz_map , & crys % T , el % chempot , el % ens , el % vels , bt % el_rta_rates_ibz , & bt % el_field_term_T , el % indexlist ) ! Symmetrize field term do ik = 1 , el % nk bt % el_field_term_T ( ik ,:,:) = transpose (& matmul ( el % symmetrizers (:,:, ik ), transpose ( bt % el_field_term_T ( ik ,:,:)))) end do ! RTA solution of BTE allocate ( bt % el_response_T ( el % nk , el % numbands , 3 )) bt % el_response_T = bt % el_field_term_T ! Calculate transport coefficient call calculate_transport_coeff ( 'el' , 'T' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , el % kmesh , bt % el_response_T , sym , el_kappa0 , el_sigmaS ) !E field: ! Calculate field term (E=>J0) call calculate_field_term ( 'el' , 'E' , el % nequiv , el % ibz2fbz_map , & crys % T , el % chempot , el % ens , el % vels , bt % el_rta_rates_ibz , & bt % el_field_term_E , el % indexlist ) ! Symmetrize field term do ik = 1 , el % nk bt % el_field_term_E ( ik ,:,:) = transpose (& matmul ( el % symmetrizers (:,:, ik ), transpose ( bt % el_field_term_E ( ik ,:,:)))) end do ! RTA solution of BTE allocate ( bt % el_response_E ( el % nk , el % numbands , 3 )) bt % el_response_E = bt % el_field_term_E ! Calculate transport coefficient call calculate_transport_coeff ( 'el' , 'E' , crys % T , el % spindeg , el % chempot , el % ens , el % vels , & crys % volume , el % kmesh , bt % el_response_E , sym , el_alphabyT , el_sigma ) el_alphabyT = el_alphabyT / crys % T !--! !Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) !Write RTA scattering rates to file call write2file_rank2_real ( 'el.W_rta_eph' , rates_eph ) !Write e-chimp RTA scattering rates to file call write2file_rank2_real ( 'el.W_rta_echimp' , bt % el_rta_rates_echimp_ibz ) !Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) !Calculate and print transport scalars !gradT: el_kappa0_scalar = trace ( sum ( el_kappa0 , dim = 1 )) / crys % dim el_sigmaS_scalar = trace ( sum ( el_sigmaS , dim = 1 )) / crys % dim !E: el_sigma_scalar = trace ( sum ( el_sigma , dim = 1 )) / crys % dim el_alphabyT_scalar = trace ( sum ( el_alphabyT , dim = 1 )) / crys % dim if (. not . num % drag . and . this_image () == 1 ) then write ( * , * ) \"iter    k0_el[W/m/K]        sigmaS[A/m/K]\" , & \"         sigma[1/Ohm/m]      alpha_el/T[A/m/K]\" write ( * , \"(I3, A, 1E16.8, A, 1E16.8, A, 1E16.8, A, 1E16.8)\" ) 0 , & \"    \" , el_kappa0_scalar , \"     \" , el_sigmaS_scalar , & \"     \" , el_sigma_scalar , \"     \" , el_alphabyT_scalar end if el_kappa0_scalar_old = el_kappa0_scalar el_sigmaS_scalar_old = el_sigmaS_scalar el_sigma_scalar_old = el_sigma_scalar el_alphabyT_scalar_old = el_alphabyT_scalar ! Append RTA coefficients in no-drag files ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'nodrag_el_sigmaS_' , 0_k8 , el_sigmaS , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_sigma_' , 0_k8 , el_sigma , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_alphabyT_' , 0_k8 , el_alphabyT , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_kappa0_' , 0_k8 , el_kappa0 , el % bandlist ) ! Print RTA band/branch resolved response functions call write2file_response ( 'RTA_I0_' , bt % el_response_T , el % bandlist ) !gradT, el call write2file_response ( 'RTA_J0_' , bt % el_response_E , el % bandlist ) !E, el ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) end if if ( num % drag ) then !Coupled BTEs tot_alphabyT_scalar = el_alphabyT_scalar + ph_alphabyT_scalar KO_dev = 10 0.0_dp * abs (& ( el_sigmaS_scalar - tot_alphabyT_scalar ) / tot_alphabyT_scalar ) call print_message ( \"RTA solution:\" ) call print_message ( \"-------------\" ) if ( this_image () == 1 ) then tableheader = \"iter     k0_el[W/m/K]         sigmaS[A/m/K]         k_ph[W/m/K]\" & // \"         sigma[1/Ohm/m]         alpha_el/T[A/m/K]         alpha_ph/T[A/m/K]\" & // \"         KO dev.[%]\" write ( * , * ) trim ( tableheader ) end if !RTA if ( this_image () == 1 ) then write ( * , \"(I3, A, 1E16.8, A, 1E16.8, A, 1E16.8, A, 1E16.8, & A, 1E16.8, A, 1E16.8, A, 1F6.3)\" ) 0 , \"     \" , el_kappa0_scalar , & \"      \" , el_sigmaS_scalar , \"     \" , ph_kappa_scalar , & \"    \" , el_sigma_scalar , \"        \" , el_alphabyT_scalar , & \"         \" , ph_alphabyT_scalar , \"           \" , KO_dev end if !Append RTA coefficients in drag files ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'drag_ph_kappa_' , 0_k8 , ph_kappa ) call append2file_transport_tensor ( 'drag_ph_alphabyT_' , 0_k8 , ph_alphabyT ) call append2file_transport_tensor ( 'drag_el_sigmaS_' , 0_k8 , el_sigmaS , el % bandlist ) call append2file_transport_tensor ( 'drag_el_sigma_' , 0_k8 , el_sigma , el % bandlist ) call append2file_transport_tensor ( 'drag_el_alphabyT_' , 0_k8 , el_alphabyT , el % bandlist ) call append2file_transport_tensor ( 'drag_el_kappa0_' , 0_k8 , el_kappa0 , el % bandlist ) ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) call print_message ( \"Coupled electron-phonon transport:\" ) call print_message ( \"----------------------------------\" ) if ( this_image () == 1 ) then tableheader = \"iter     k0_el[W/m/K]         sigmaS[A/m/K]         k_ph[W/m/K]\" & // \"         sigma[1/Ohm/m]         alpha_el/T[A/m/K]         alpha_ph/T[A/m/K]\" & // \"         KO dev.[%]\" write ( * , * ) trim ( tableheader ) end if !These will be needed below allocate ( I_drag ( el % nk , el % numbands , 3 ), I_diff ( el % nk , el % numbands , 3 ), & ph_drag_term_T ( el % nk , el % numbands , 3 ), ph_drag_term_E ( el % nk , el % numbands , 3 )) !Start iterator do it_ph = 1 , num % maxiter !Scheme: for each step of phonon response, fully iterate the electron response. !Iterate phonon response once call iterate_bte_ph ( crys % T , . True ., num , ph , el , bt % ph_rta_rates_ibz , & bt % ph_field_term_T , bt % ph_response_T , bt % el_response_T ) call iterate_bte_ph ( crys % T , . True ., num , ph , el , bt % ph_rta_rates_ibz , & bt % ph_field_term_E , bt % ph_response_E , bt % el_response_E ) !Calculate phonon transport coefficients call calculate_transport_coeff ( 'ph' , 'T' , crys % T , 1_k8 , 0.0_dp , ph % ens , ph % vels , & crys % volume , ph % qmesh , bt % ph_response_T , sym , ph_kappa , dummy ) call calculate_transport_coeff ( 'ph' , 'E' , crys % T , 1_k8 , 0.0_dp , ph % ens , ph % vels , & crys % volume , ph % qmesh , bt % ph_response_E , sym , ph_alphabyT , dummy ) ph_alphabyT = ph_alphabyT / crys % T !Calculate phonon drag term for the current phBTE iteration. call calculate_phonon_drag ( crys % T , num , el , ph , sym , bt % el_rta_rates_ibz , & bt % ph_response_E , ph_drag_term_E ) call calculate_phonon_drag ( crys % T , num , el , ph , sym , bt % el_rta_rates_ibz , & bt % ph_response_T , ph_drag_term_T ) !Iterate electron response all the way do it_el = 1 , num % maxiter !E field: call iterate_bte_el ( crys % T , . True ., num , el , ph , sym , & bt % el_rta_rates_ibz , bt % el_field_term_E , bt % el_response_E , ph_drag_term_E ) !Calculate electron transport coefficients call calculate_transport_coeff ( 'el' , 'E' , crys % T , el % spindeg , el % chempot , & el % ens , el % vels , crys % volume , el % kmesh , bt % el_response_E , sym , & el_alphabyT , el_sigma ) el_alphabyT = el_alphabyT / crys % T !delT field: call iterate_bte_el ( crys % T , . True ., num , el , ph , sym , & bt % el_rta_rates_ibz , bt % el_field_term_T , bt % el_response_T , ph_drag_term_T ) !Enforce Kelvin-Onsager relation: !Fix \"diffusion\" part do icart = 1 , 3 I_diff (:,:, icart ) = ( el % ens (:,:) - el % chempot ) / qe / crys % T * & bt % el_response_E (:,:, icart ) end do !Correct \"drag\" part I_drag = bt % el_response_T - I_diff call correct_I_drag ( I_drag , trace ( sum ( ph_alphabyT , dim = 1 )) / crys % dim , lambda ) bt % el_response_T = I_diff + lambda * I_drag !Calculate electron transport coefficients call calculate_transport_coeff ( 'el' , 'T' , crys % T , el % spindeg , el % chempot , & el % ens , el % vels , crys % volume , el % kmesh , bt % el_response_T , sym , & el_kappa0 , el_sigmaS ) !Calculate electron transport scalars el_kappa0_scalar = trace ( sum ( el_kappa0 , dim = 1 )) / crys % dim el_sigmaS_scalar = trace ( sum ( el_sigmaS , dim = 1 )) / crys % dim el_sigma_scalar = trace ( sum ( el_sigma , dim = 1 )) / crys % dim el_alphabyT_scalar = trace ( sum ( el_alphabyT , dim = 1 )) / crys % dim !Check convergence if ( converged ( el_kappa0_scalar_old , el_kappa0_scalar , num % conv_thres ) . and . & converged ( el_sigmaS_scalar_old , el_sigmaS_scalar , num % conv_thres ) . and . & converged ( el_sigma_scalar_old , el_sigma_scalar , num % conv_thres ) . and . & converged ( el_alphabyT_scalar_old , el_alphabyT_scalar , num % conv_thres )) then exit else el_kappa0_scalar_old = el_kappa0_scalar el_sigmaS_scalar_old = el_sigmaS_scalar el_sigma_scalar_old = el_sigma_scalar el_alphabyT_scalar_old = el_alphabyT_scalar end if end do !Calculate phonon transport scalar ph_kappa_scalar = trace ( sum ( ph_kappa , dim = 1 )) / crys % dim ph_alphabyT_scalar = trace ( sum ( ph_alphabyT , dim = 1 )) / crys % dim if ( it_ph == 1 ) then !Print RTA band/branch resolved response functions ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call write2file_response ( 'partdcpl_I0_' , bt % el_response_T , el % bandlist ) !gradT, el call write2file_response ( 'partdcpl_J0_' , bt % el_response_E , el % bandlist ) !E, el ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) end if !Check convergence if ( converged ( ph_kappa_scalar_old , ph_kappa_scalar , num % conv_thres ) . and . & converged ( ph_alphabyT_scalar_old , ph_alphabyT_scalar , num % conv_thres )) then !Print converged band/branch resolved response functions ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call write2file_response ( 'drag_F0_' , bt % ph_response_T ) !gradT, ph call write2file_response ( 'drag_I0_' , bt % el_response_T , el % bandlist ) !gradT, el call write2file_response ( 'drag_G0_' , bt % ph_response_E ) !E, ph call write2file_response ( 'drag_J0_' , bt % el_response_E , el % bandlist ) !E, el ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) exit else ph_kappa_scalar_old = ph_kappa_scalar ph_alphabyT_scalar_old = ph_alphabyT_scalar !Print out band resolved transport coefficients ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'drag_ph_kappa_' , it_ph , ph_kappa ) call append2file_transport_tensor ( 'drag_ph_alphabyT_' , it_ph , ph_alphabyT ) call append2file_transport_tensor ( 'drag_el_sigmaS_' , it_ph , el_sigmaS , el % bandlist ) call append2file_transport_tensor ( 'drag_el_sigma_' , it_ph , el_sigma , el % bandlist ) call append2file_transport_tensor ( 'drag_el_alphabyT_' , it_ph , el_alphabyT , el % bandlist ) call append2file_transport_tensor ( 'drag_el_kappa0_' , it_ph , el_kappa0 , el % bandlist ) ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) end if tot_alphabyT_scalar = el_alphabyT_scalar + ph_alphabyT_scalar KO_dev = 10 0.0_dp * abs (& ( el_sigmaS_scalar - tot_alphabyT_scalar ) / tot_alphabyT_scalar ) if ( this_image () == 1 ) then write ( * , \"(I3, A, 1E16.8, A, 1E16.8, A, 1E16.8, A, 1E16.8, & A, 1E16.8, A, 1E16.8, A, 1F6.3)\" ) it_ph , \"     \" , el_kappa0_scalar , & \"      \" , el_sigmaS_scalar , \"     \" , ph_kappa_scalar , & \"    \" , el_sigma_scalar , \"        \" , el_alphabyT_scalar , & \"         \" , ph_alphabyT_scalar , \"           \" , KO_dev end if end do !Don't need these anymore deallocate ( I_drag , I_diff , ph_drag_term_T , ph_drag_term_E ) end if !drag if ( num % onlyphbte . or . num % drag ) then !Phonon BTE call print_message ( \"Decoupled phonon transport:\" ) call print_message ( \"---------------------------\" ) !Restart with RTA solution bt % ph_response_T = bt % ph_field_term_T if ( this_image () == 1 ) then write ( * , * ) \"iter    k_ph[W/m/K]\" end if do it_ph = 1 , num % maxiter call iterate_bte_ph ( crys % T , . False ., num , ph , el , bt % ph_rta_rates_ibz , & bt % ph_field_term_T , bt % ph_response_T ) !Calculate phonon transport coefficients call calculate_transport_coeff ( 'ph' , 'T' , crys % T , 1_k8 , 0.0_dp , ph % ens , ph % vels , & crys % volume , ph % qmesh , bt % ph_response_T , sym , ph_kappa , dummy ) !Calculate and print phonon transport scalar ph_kappa_scalar = trace ( sum ( ph_kappa , dim = 1 )) / crys % dim if ( this_image () == 1 ) then write ( * , \"(I3, A, 1E16.8)\" ) it_ph , \"    \" , ph_kappa_scalar end if if ( converged ( ph_kappa_scalar_old , ph_kappa_scalar , num % conv_thres ) . and . & converged ( ph_alphabyT_scalar_old , ph_alphabyT_scalar , num % conv_thres )) then !Print converged branch resolved response functions ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call write2file_response ( 'nodrag_F0_' , bt % ph_response_T ) !gradT, ph ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) exit else !Print out branch resolved transport coefficients ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'nodrag_ph_kappa_' , it_ph , ph_kappa ) ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) ph_kappa_scalar_old = ph_kappa_scalar end if end do end if if ( num % onlyebte . or . num % drag ) then !Electron BTE call print_message ( \"Decoupled electron transport:\" ) call print_message ( \"-----------------------------\" ) !Restart with RTA solution bt % el_response_T = bt % el_field_term_T bt % el_response_E = bt % el_field_term_E if ( this_image () == 1 ) then write ( * , * ) \"iter    k0_el[W/m/K]        sigmaS[A/m/K]\" , & \"         sigma[1/Ohm/m]      alpha_el/T[A/m/K]\" end if do it_el = 1 , num % maxiter !E field: call iterate_bte_el ( crys % T , . False ., num , el , ph , sym ,& bt % el_rta_rates_ibz , bt % el_field_term_E , bt % el_response_E ) !Calculate electron transport coefficients call calculate_transport_coeff ( 'el' , 'E' , crys % T , el % spindeg , el % chempot , & el % ens , el % vels , crys % volume , el % kmesh , bt % el_response_E , sym , & el_alphabyT , el_sigma ) el_alphabyT = el_alphabyT / crys % T !delT field: call iterate_bte_el ( crys % T , . False ., num , el , ph , sym ,& bt % el_rta_rates_ibz , bt % el_field_term_T , bt % el_response_T , bt % ph_response_T ) !Enforce Kelvin-Onsager relation do icart = 1 , 3 bt % el_response_T (:,:, icart ) = ( el % ens (:,:) - el % chempot ) / qe / crys % T * & bt % el_response_E (:,:, icart ) end do call calculate_transport_coeff ( 'el' , 'T' , crys % T , el % spindeg , el % chempot , & el % ens , el % vels , crys % volume , el % kmesh , bt % el_response_T , sym , & el_kappa0 , el_sigmaS ) !Calculate and print electron transport scalars el_kappa0_scalar = trace ( sum ( el_kappa0 , dim = 1 )) / crys % dim el_sigmaS_scalar = trace ( sum ( el_sigmaS , dim = 1 )) / crys % dim el_sigma_scalar = trace ( sum ( el_sigma , dim = 1 )) / crys % dim el_alphabyT_scalar = trace ( sum ( el_alphabyT , dim = 1 )) / crys % dim if ( this_image () == 1 ) then write ( * , \"(I3, A, 1E16.8, A, 1E16.8, A, 1E16.8, A, 1E16.8)\" ) it_el , & \"    \" , el_kappa0_scalar , \"     \" , el_sigmaS_scalar , & \"     \" , el_sigma_scalar , \"     \" , el_alphabyT_scalar end if !Check convergence if ( converged ( el_kappa0_scalar_old , el_kappa0_scalar , num % conv_thres ) . and . & converged ( el_sigmaS_scalar_old , el_sigmaS_scalar , num % conv_thres ) . and . & converged ( el_sigma_scalar_old , el_sigma_scalar , num % conv_thres ) . and . & converged ( el_alphabyT_scalar_old , el_alphabyT_scalar , num % conv_thres )) then !Print converged band resolved response functions ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call write2file_response ( 'nodrag_I0_' , bt % el_response_T , el % bandlist ) !gradT, el call write2file_response ( 'nodrag_J0_' , bt % el_response_E , el % bandlist ) !E, el ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) exit else !Print out band resolved transport coefficients ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'nodrag_el_sigmaS_' , it_el , el_sigmaS , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_sigma_' , it_el , el_sigma , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_alphabyT_' , it_el , el_alphabyT , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_kappa0_' , it_el , el_kappa0 , el % bandlist ) ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) el_kappa0_scalar_old = el_kappa0_scalar el_sigmaS_scalar_old = el_sigmaS_scalar el_sigma_scalar_old = el_sigma_scalar el_alphabyT_scalar_old = el_alphabyT_scalar end if end do end if contains subroutine correct_I_drag ( I_drag , constraint , lambda ) !! Subroutine to find scaling correction to I_drag. real ( dp ), intent ( in ) :: I_drag (:,:,:), constraint real ( dp ), intent ( out ) :: lambda !Internal variables integer ( k8 ) :: it , maxiter real ( dp ) :: a , b , sigmaS ( size ( I_drag ( 1 ,:, 1 )), 3 , 3 ),& thresh , sigmaS_scalar , dummy ( size ( I_drag ( 1 ,:, 1 )), 3 , 3 ) a = 0.0_dp !lower bound b = 2.0_dp !upper bound maxiter = 100 thresh = 1.0e-6_dp do it = 1 , maxiter lambda = 0.5_dp * ( a + b ) !Calculate electron transport coefficients call calculate_transport_coeff ( 'el' , 'T' , crys % T , el % spindeg , el % chempot , & el % ens , el % vels , crys % volume , el % kmesh , lambda * I_drag , sym , & dummy , sigmaS ) sigmaS_scalar = trace ( sum ( sigmaS , dim = 1 )) / crys % dim if ( abs ( sigmaS_scalar - constraint ) < thresh ) then exit else if ( abs ( sigmaS_scalar ) < abs ( constraint )) then a = lambda else b = lambda end if end do end subroutine correct_I_drag end subroutine solve_bte subroutine calculate_field_term ( species , field , nequiv , ibz2fbz_map , & T , chempot , ens , vels , rta_rates_ibz , field_term , el_indexlist ) !! Subroutine to calculate the field coupling term of the BTE. !! !! species Type of particle !! field Type of field !! nequiv List of the number of equivalent points for each IBZ wave vector !! ibz2fbz_map Map from an FBZ wave vectors to its IBZ wedge image !! T Temperature in K !! ens FBZ energies !! vels FBZ velocities !! chempot Chemical potential (should be 0 for phonons) !! rta_rates_ibz IBZ RTA scattering rates !! field_term FBZ field-coupling term of the BTE !! el_indexlist [Optional] character ( len = 2 ), intent ( in ) :: species character ( len = 1 ), intent ( in ) :: field integer ( k8 ), intent ( in ) :: nequiv (:), ibz2fbz_map (:,:,:) real ( dp ), intent ( in ) :: T , chempot , ens (:,:), vels (:,:,:), rta_rates_ibz (:,:) real ( dp ), allocatable , intent ( out ) :: field_term (:,:,:) integer ( k8 ), intent ( in ), optional :: el_indexlist (:) !Local variables integer ( k8 ) :: ik_ibz , ik_fbz , ieq , ib , nk_ibz , nk , nbands , pow , & chunk , num_active_images integer ( k8 ), allocatable :: start [:], end [:] real ( dp ), allocatable :: field_term_reduce (:,:,:)[:] real ( dp ) :: A logical :: trivial_case !Set constant and power of energy depending on species and field type if ( species == 'ph' ) then A = 1.0_dp / T pow = 1 if ( chempot /= 0.0_dp ) then call exit_with_message ( \"Phonon chemical potential non-zero in calculate_field_term. Exiting.\" ) end if else if ( species == 'el' ) then if ( field == 'T' ) then A = 1.0_dp / T pow = 1 else if ( field == 'E' ) then A = qe pow = 0 else call exit_with_message ( \"Unknown field type in calculate_field_term. Exiting.\" ) end if else call exit_with_message ( \"Unknown particle species in calculate_field_term. Exiting.\" ) end if !Number of IBZ wave vectors nk_ibz = size ( rta_rates_ibz (:, 1 )) !Number of FBZ wave vectors nk = size ( ens (:, 1 )) !Number of bands nbands = size ( ens ( 1 ,:)) !Allocate and initialize field term allocate ( field_term ( nk , nbands , 3 )) field_term (:,:,:) = 0.0_dp !No field-coupling case trivial_case = species == 'ph' . and . field == 'E' if (. not . trivial_case ) then !Allocate start and end coarrays allocate ( start [ * ], end [ * ]) !Divide IBZ states among images call distribute_points ( nk_ibz , chunk , start , end , num_active_images ) !Allocate and initialize field term coarrays allocate ( field_term_reduce ( nk , nbands , 3 )[ * ]) field_term_reduce (:,:,:) = 0.0_dp !Work the active images only: do ik_ibz = start , end do ieq = 1 , nequiv ( ik_ibz ) if ( species == 'ph' ) then ik_fbz = ibz2fbz_map ( ieq , ik_ibz , 2 ) else !Find index of electron in indexlist call binsearch ( el_indexlist , ibz2fbz_map ( ieq , ik_ibz , 2 ), ik_fbz ) end if do ib = 1 , nbands if ( rta_rates_ibz ( ik_ibz , ib ) /= 0.0_dp ) then field_term_reduce ( ik_fbz , ib , :) = A * vels ( ik_fbz , ib , :) * & ( ens ( ik_fbz , ib ) - chempot ) ** pow / rta_rates_ibz ( ik_ibz , ib ) end if end do end do end do !Reduce field term coarrays !Units: ! nm.eV/K for phonons, gradT-field ! nm.eV/K for electrons, gradT-field ! nm.C for electrons, E-field call co_sum ( field_term_reduce ) field_term = field_term_reduce end if end subroutine calculate_field_term subroutine iterate_bte_ph ( T , drag , num , ph , el , rta_rates_ibz , & field_term , response_ph , response_el ) !! Subroutine to iterate the phonon BTE one step. !! !! T Temperature in K !! drag Is drag included? !! ph Phonon object !! rta_rates_ibz Phonon RTA scattering rates !! field_term Phonon field coupling term !! response_ph Phonon response function !! response_el Electron response function type ( phonon ), intent ( in ) :: ph type ( electron ), intent ( in ) :: el type ( numerics ), intent ( in ) :: num logical , intent ( in ) :: drag real ( dp ), intent ( in ) :: T , rta_rates_ibz (:,:), field_term (:,:,:) real ( dp ), intent ( in ), optional :: response_el (:,:,:) real ( dp ), intent ( inout ) :: response_ph (:,:,:) !Local variables integer ( k8 ) :: nstates_irred , chunk , istate1 , numbranches , s1 , & iq1_ibz , ieq , iq1_sym , iq1_fbz , iproc , iq2 , s2 , iq3 , s3 , nq , & num_active_images , numbands , ik , ikp , m , n , nprocs_phe , aux1 , aux2 , & nprocs_3ph_plus , nprocs_3ph_minus integer ( k8 ), allocatable :: istate2_plus (:), istate3_plus (:), & istate2_minus (:), istate3_minus (:), istate_el1 (:), istate_el2 (:), & start [:], end [:] real ( dp ) :: tau_ibz real ( dp ), allocatable :: Wp (:), Wm (:), Y (:), response_ph_reduce (:,:,:)[:] character ( len = 1024 ) :: filepath_Wm , filepath_Wp , filepath_Y , tag !Set output directory of transition probilities write ( tag , \"(E9.3)\" ) T if ( drag . and . . not . present ( response_el )) then call exit_with_message ( \"For drag in phonon BTE, must provide electron response. Exiting.\" ) end if if ( drag ) then !Number of electron bands numbands = size ( response_el ( 1 ,:, 1 )) end if !Number of phonon branches numbranches = size ( rta_rates_ibz ( 1 ,:)) !Number of FBZ wave vectors nq = size ( field_term (:, 1 , 1 )) !Total number of IBZ states nstates_irred = size ( rta_rates_ibz (:, 1 )) * numbranches !Allocate coarrays allocate ( start [ * ], end [ * ]) allocate ( response_ph_reduce ( nq , numbranches , 3 )[ * ]) !Initialize coarray response_ph_reduce (:,:,:) = 0.0_dp !Divide phonon states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) !Run over first phonon IBZ states do istate1 = start , end !Demux state index into branch (s) and wave vector (iq1_ibz) indices call demux_state ( istate1 , numbranches , s1 , iq1_ibz ) !RTA lifetime tau_ibz = 0.0_dp if ( rta_rates_ibz ( iq1_ibz , s1 ) /= 0.0_dp ) then tau_ibz = 1.0_dp / rta_rates_ibz ( iq1_ibz , s1 ) end if !Set W+ filename write ( tag , '(I9)' ) istate1 filepath_Wp = trim ( adjustl ( num % Wdir )) // '/Wp.istate' // trim ( adjustl ( tag )) !Read W+ from file if ( allocated ( Wp )) deallocate ( Wp ) if ( allocated ( istate2_plus )) deallocate ( istate2_plus ) if ( allocated ( istate3_plus )) deallocate ( istate3_plus ) call read_transition_probs_e ( trim ( adjustl ( filepath_Wp )), nprocs_3ph_plus , Wp , & istate2_plus , istate3_plus ) !Set W- filename filepath_Wm = trim ( adjustl ( num % Wdir )) // '/Wm.istate' // trim ( adjustl ( tag )) !Read W- from file if ( allocated ( Wm )) deallocate ( Wm ) if ( allocated ( istate2_minus )) deallocate ( istate2_minus ) if ( allocated ( istate3_minus )) deallocate ( istate3_minus ) call read_transition_probs_e ( trim ( adjustl ( filepath_Wm )), nprocs_3ph_minus , Wm , & istate2_minus , istate3_minus ) if ( drag ) then !Set Y filename filepath_Y = trim ( adjustl ( num % Ydir )) // '/Y.istate' // trim ( adjustl ( tag )) !Read Y from file if ( allocated ( Y )) deallocate ( Y ) if ( allocated ( istate_el1 )) deallocate ( istate_el1 ) if ( allocated ( istate_el2 )) deallocate ( istate_el2 ) call read_transition_probs_e ( trim ( adjustl ( filepath_Y )), nprocs_phe , Y , & istate_el1 , istate_el2 ) end if !Sum over the number of equivalent q-points of the IBZ point do ieq = 1 , ph % nequiv ( iq1_ibz ) iq1_sym = ph % ibz2fbz_map ( ieq , iq1_ibz , 1 ) !symmetry iq1_fbz = ph % ibz2fbz_map ( ieq , iq1_ibz , 2 ) !image due to symmetry !Sum over scattering processes !Self contribution from plus processes: do iproc = 1 , nprocs_3ph_plus !Grab 2nd and 3rd phonons call demux_state ( istate2_plus ( iproc ), numbranches , s2 , iq2 ) call demux_state ( istate3_plus ( iproc ), numbranches , s3 , iq3 ) response_ph_reduce ( iq1_fbz , s1 , :) = response_ph_reduce ( iq1_fbz , s1 , :) + & Wp ( iproc ) * ( response_ph ( ph % equiv_map ( iq1_sym , iq3 ), s3 , :) - & response_ph ( ph % equiv_map ( iq1_sym , iq2 ), s2 , :)) end do !Self contribution from minus processes: do iproc = 1 , nprocs_3ph_minus !Grab 2nd and 3rd phonons call demux_state ( istate2_minus ( iproc ), numbranches , s2 , iq2 ) call demux_state ( istate3_minus ( iproc ), numbranches , s3 , iq3 ) response_ph_reduce ( iq1_fbz , s1 , :) = response_ph_reduce ( iq1_fbz , s1 , :) + & 0.5_dp * Wm ( iproc ) * ( response_ph ( ph % equiv_map ( iq1_sym , iq3 ), s3 , :) + & response_ph ( ph % equiv_map ( iq1_sym , iq2 ), s2 , :)) end do !Drag contribution: if ( drag ) then do iproc = 1 , nprocs_phe !Grab initial and final electron states call demux_state ( istate_el1 ( iproc ), numbands , m , ik ) call demux_state ( istate_el2 ( iproc ), numbands , n , ikp ) !Find image of electron wave vector due to the current symmetry call binsearch ( el % indexlist , el % equiv_map ( iq1_sym , ik ), aux1 ) call binsearch ( el % indexlist , el % equiv_map ( iq1_sym , ikp ), aux2 ) response_ph_reduce ( iq1_fbz , s1 , :) = response_ph_reduce ( iq1_fbz , s1 , :) + & el % spindeg * Y ( iproc ) * ( response_el ( aux2 , n , :) - response_el ( aux1 , m , :)) end do end if !Iterate BTE response_ph_reduce ( iq1_fbz , s1 , :) = field_term ( iq1_fbz , s1 , :) + & response_ph_reduce ( iq1_fbz , s1 , :) * tau_ibz end do end do !Update the response function call co_sum ( response_ph_reduce ) response_ph = response_ph_reduce !Symmetrize response function do iq1_fbz = 1 , nq response_ph ( iq1_fbz ,:,:) = transpose (& matmul ( ph % symmetrizers (:,:, iq1_fbz ), transpose ( response_ph ( iq1_fbz ,:,:)))) end do end subroutine iterate_bte_ph subroutine iterate_bte_el ( T , drag , num , el , ph , sym , rta_rates_ibz , field_term , & response_el , ph_drag_term ) !! Subroutine to iterate the electron BTE one step. !! !! T Temperature in K !! drag Is drag included? !! el Electron object !! ph Phonon object !! sym Symmetry !! rta_rates_ibz Electron RTA scattering rates !! field_term Electron field coupling term !! response_el Electron response function !! ph_drag_term Phonon drag term type ( electron ), intent ( in ) :: el type ( phonon ), intent ( in ) :: ph type ( numerics ), intent ( in ) :: num type ( symmetry ), intent ( in ) :: sym logical , intent ( in ) :: drag real ( dp ), intent ( in ) :: T , rta_rates_ibz (:,:), field_term (:,:,:) real ( dp ), intent ( in ), optional :: ph_drag_term (:,:,:) real ( dp ), intent ( inout ) :: response_el (:,:,:) !Local variables integer ( k8 ) :: nstates_irred , nprocs , chunk , istate , numbands , numbranches , & ik_ibz , m , ieq , ik_sym , ik_fbz , iproc , ikp , n , nk , num_active_images , aux integer ( k8 ), allocatable :: istate_el (:), istate_ph (:), start [:], end [:] real ( dp ) :: tau_ibz real ( dp ), allocatable :: Xplus (:), Xminus (:), response_el_reduce (:,:,:)[:] character ( 1024 ) :: filepath_Xminus , filepath_Xplus , tag !Set output directory of transition probilities write ( tag , \"(E9.3)\" ) T if ( drag . and . . not . present ( ph_drag_term )) then call exit_with_message ( \"For drag in electron BTE, must provide phonon drag term. Exiting.\" ) end if !Number of electron bands numbands = size ( rta_rates_ibz ( 1 ,:)) !Number of in-window FBZ wave vectors nk = size ( field_term (:, 1 , 1 )) !Total number of IBZ states nstates_irred = size ( rta_rates_ibz (:, 1 )) * numbands if ( drag ) then !Number of phonon branches !numbranches = size(response_ph(1,:,1)) numbranches = size ( ph_drag_term ( 1 ,:, 1 )) end if !Allocate coarrays allocate ( start [ * ], end [ * ]) allocate ( response_el_reduce ( nk , numbands , 3 )[ * ]) !Initialize coarray response_el_reduce (:,:,:) = 0.0_dp !Divide electron states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) !Run over electron IBZ states do istate = start , end !Demux state index into band (m) and wave vector (ik_ibz) indices call demux_state ( istate , numbands , m , ik_ibz ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( el % ens_irred ( ik_ibz , m ) - el % enref ) > el % fsthick ) cycle !RTA lifetime tau_ibz = 0.0_dp if ( rta_rates_ibz ( ik_ibz , m ) /= 0.0_dp ) then tau_ibz = 1.0_dp / rta_rates_ibz ( ik_ibz , m ) end if !Set X+ filename write ( tag , '(I9)' ) istate filepath_Xplus = trim ( adjustl ( num % Xdir )) // '/Xplus.istate' // trim ( adjustl ( tag )) !Read X+ from file call read_transition_probs_e ( trim ( adjustl ( filepath_Xplus )), nprocs , Xplus , & istate_el , istate_ph ) !Set X- filename write ( tag , '(I9)' ) istate filepath_Xminus = trim ( adjustl ( num % Xdir )) // '/Xminus.istate' // trim ( adjustl ( tag )) !Read X- from file call read_transition_probs_e ( trim ( adjustl ( filepath_Xminus )), nprocs , Xminus ) !Sum over the number of equivalent k-points of the IBZ point do ieq = 1 , el % nequiv ( ik_ibz ) ik_sym = el % ibz2fbz_map ( ieq , ik_ibz , 1 ) !symmetry call binsearch ( el % indexlist , el % ibz2fbz_map ( ieq , ik_ibz , 2 ), ik_fbz ) !Sum over scattering processes do iproc = 1 , nprocs !Grab the final electron and, if needed, the interacting phonon call demux_state ( istate_el ( iproc ), numbands , n , ikp ) !Self contribution: !Find image of final electron wave vector due to the current symmetry call binsearch ( el % indexlist , el % equiv_map ( ik_sym , ikp ), aux ) response_el_reduce ( ik_fbz , m , :) = response_el_reduce ( ik_fbz , m , :) + & response_el ( aux , n , :) * ( Xplus ( iproc ) + Xminus ( iproc )) end do !Iterate BTE response_el_reduce ( ik_fbz , m , :) = field_term ( ik_fbz , m , :) + & response_el_reduce ( ik_fbz , m , :) * tau_ibz end do end do !Update the response function call co_sum ( response_el_reduce ) response_el = response_el_reduce if ( drag ) then !Drag contribution: response_el (:,:,:) = response_el (:,:,:) + ph_drag_term (:,:,:) end if !Symmetrize response function do ik_fbz = 1 , nk response_el ( ik_fbz ,:,:) = transpose (& matmul ( el % symmetrizers (:,:, ik_fbz ), transpose ( response_el ( ik_fbz ,:,:)))) end do end subroutine iterate_bte_el subroutine calculate_phonon_drag ( T , num , el , ph , sym , rta_rates_ibz , response_ph , ph_drag_term ) !! Subroutine to calculate the phonon drag term. !! !! T Temperature in K !! num Numerics object !! el Electron object !! ph Phonon object !! sym Symmetry !! rta_rates_ibz Electron RTA scattering rates !! response_ph Phonon response function !! ph_drag_term Phonon drag term type ( electron ), intent ( in ) :: el type ( phonon ), intent ( in ) :: ph type ( numerics ), intent ( in ) :: num type ( symmetry ), intent ( in ) :: sym real ( dp ), intent ( in ) :: T , rta_rates_ibz (:,:), response_ph (:,:,:) real ( dp ), intent ( out ) :: ph_drag_term (:,:,:) !Local variables integer ( k8 ) :: nstates_irred , nprocs , chunk , istate , numbands , numbranches , & ik_ibz , m , ieq , ik_sym , ik_fbz , iproc , iq , s , nk , num_active_images , & ipol , fineq_indvec ( 3 ) integer ( k8 ), allocatable :: istate_el (:), istate_ph (:), start [:], end [:] real ( dp ) :: tau_ibz , ForG ( 3 ) real ( dp ), allocatable :: Xplus (:), Xminus (:), ph_drag_term_reduce (:,:,:)[:] character ( 1024 ) :: filepath_Xminus , filepath_Xplus , tag !Number of electron bands numbands = el % numbands !Number of in-window FBZ wave vectors nk = el % nk !Total number of IBZ states nstates_irred = el % nk_irred * numbands !Number of phonon branches numbranches = ph % numbranches !Allocate coarrays allocate ( start [ * ], end [ * ]) allocate ( ph_drag_term_reduce ( nk , numbands , 3 )[ * ]) !Initialize coarray ph_drag_term_reduce (:,:,:) = 0.0_dp !Divide electron states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) !Run over electron IBZ states do istate = start , end !Demux state index into band (m) and wave vector (ik_ibz) indices call demux_state ( istate , numbands , m , ik_ibz ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( el % ens_irred ( ik_ibz , m ) - el % enref ) > el % fsthick ) cycle !RTA lifetime tau_ibz = 0.0_dp if ( rta_rates_ibz ( ik_ibz , m ) /= 0.0_dp ) then tau_ibz = 1.0_dp / rta_rates_ibz ( ik_ibz , m ) end if !Set X+ filename write ( tag , '(I9)' ) istate filepath_Xplus = trim ( adjustl ( num % Xdir )) // '/Xplus.istate' // trim ( adjustl ( tag )) !Read X+ from file call read_transition_probs_e ( trim ( adjustl ( filepath_Xplus )), nprocs , Xplus , & istate_el , istate_ph ) !Set X- filename write ( tag , '(I9)' ) istate filepath_Xminus = trim ( adjustl ( num % Xdir )) // '/Xminus.istate' // trim ( adjustl ( tag )) !Read X- from file call read_transition_probs_e ( trim ( adjustl ( filepath_Xminus )), nprocs , Xminus ) !Sum over the number of equivalent k-points of the IBZ point do ieq = 1 , el % nequiv ( ik_ibz ) ik_sym = el % ibz2fbz_map ( ieq , ik_ibz , 1 ) !symmetry call binsearch ( el % indexlist , el % ibz2fbz_map ( ieq , ik_ibz , 2 ), ik_fbz ) !Sum over scattering processes do iproc = 1 , nprocs if ( istate_ph ( iproc ) < 0 ) then !This phonon is on the (fine) electron mesh call demux_state ( - istate_ph ( iproc ), numbranches , s , iq ) iq = - iq !Keep the negative tag else !This phonon is on the phonon mesh call demux_state ( istate_ph ( iproc ), numbranches , s , iq ) end if !Drag contribution: if ( iq < 0 ) then !Need to interpolate on this point !Calculate the fine mesh wave vector, 0-based index vector call demux_vector ( - iq , fineq_indvec , el % kmesh , 0_k8 ) !Find image of phonon wave vector due to the current symmetry fineq_indvec = modulo ( & nint ( matmul ( sym % qrotations (:, :, ik_sym ), fineq_indvec )), el % kmesh ) !Interpolate response function on this wave vector do ipol = 1 , 3 call interpolate ( ph % qmesh , el % mesh_ref_array , response_ph (:, s , ipol ), & fineq_indvec , ForG ( ipol )) end do else !F(q) or G(q) ForG (:) = response_ph ( ph % equiv_map ( ik_sym , iq ), s , :) end if !Here we use the fact that F(-q) = -F(q) and G(-q) = -G(q) ph_drag_term_reduce ( ik_fbz , m , :) = ph_drag_term_reduce ( ik_fbz , m , :) - & ForG (:) * ( Xplus ( iproc ) + Xminus ( iproc )) end do !Multiply life time factor ph_drag_term_reduce ( ik_fbz , m , :) = ph_drag_term_reduce ( ik_fbz , m , :) * tau_ibz end do end do !Reduce from all images call co_sum ( ph_drag_term_reduce ) ph_drag_term = ph_drag_term_reduce end subroutine calculate_phonon_drag pure logical function converged ( oldval , newval , thres ) !! Function to check if newval is the same as oldval real ( dp ), intent ( in ) :: oldval , newval , thres converged = . False . if ( abs ( newval - oldval ) < thres ) converged = . True . end function converged subroutine post_process ( bt , num , crys , sym , ph , el ) !! Subroutine to post-process results of the BTEs. class ( bte ), intent ( inout ) :: bt type ( numerics ), intent ( in ) :: num type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( phonon ), intent ( in ) :: ph type ( electron ), intent ( in ), optional :: el !Local variables real ( dp ), allocatable :: ph_en_grid (:), el_en_grid (:), ph_kappa (:,:,:,:), dummy (:,:,:,:), & el_kappa0 (:,:,:,:), el_sigmaS (:,:,:,:), el_sigma (:,:,:,:), el_alphabyT (:,:,:,:), & ph_alphabyT (:,:,:,:) character ( len = 1024 ) :: tag , Tdir integer ( k8 ) :: ie !Calculate electron and/or phonon sampling energy grid call linspace ( ph_en_grid , num % ph_en_min , num % ph_en_max , num % ph_en_num ) call linspace ( el_en_grid , num % el_en_min , num % el_en_max , num % el_en_num ) !Write energy grids to file if ( this_image () == 1 ) then open ( 1 , file = \"ph.en_grid\" , status = \"replace\" ) do ie = 1 , num % ph_en_num write ( 1 , \"(E20.10)\" ) ph_en_grid ( ie ) end do close ( 1 ) open ( 1 , file = \"el.en_grid\" , status = \"replace\" ) do ie = 1 , num % el_en_num write ( 1 , \"(E20.10)\" ) el_en_grid ( ie ) end do close ( 1 ) end if !Change to T-dependent directory write ( tag , \"(E9.3)\" ) crys % T Tdir = trim ( adjustl ( num % cwd )) // '/T' // trim ( adjustl ( tag )) call chdir ( trim ( adjustl ( Tdir ))) !Decoupled electron BTE if (. not . num % onlyphbte ) then call print_message ( \"Decoupled electron BTE:\" ) call print_message ( \"---------------------\" ) !gradT: call print_message ( \"gradT field:\" ) ! RTA: call print_message ( \" Calculating RTA electron kappa0 and sigmaS...\" ) !  Allocate response function allocate ( bt % el_response_T ( el % nk , el % numbands , 3 )) !  Read response function call readfile_response ( 'RTA_I0_' , bt % el_response_T , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_kappa0 ( el % numbands , 3 , 3 , num % el_en_num ), & el_sigmaS ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'T' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , bt % el_response_T , el_en_grid , num % tetrahedra , sym , & el_kappa0 , el_sigmaS ) !  Write spectral electron kappa call write2file_spectral_tensor ( 'RTA_el_kappa0_spectral_' , el_kappa0 , el % bandlist ) !  Write spectral electron sigmaS call write2file_spectral_tensor ( 'RTA_el_sigmaS_spectral_' , el_sigmaS , el % bandlist ) !------------------------------------------------------------------! ! Iterated: call print_message ( \" Calculating iterated electron kappa0 and sigmaS...\" ) !  Read response function call readfile_response ( 'nodrag_I0_' , bt % el_response_T , el % bandlist ) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'T' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , bt % el_response_T , el_en_grid , num % tetrahedra , sym , & el_kappa0 , el_sigmaS ) !  Write spectral electron kappa call write2file_spectral_tensor ( 'nodrag_iterated_el_kappa0_spectral_' , el_kappa0 , el % bandlist ) !  Write spectral electron sigmaS call write2file_spectral_tensor ( 'nodrag_iterated_el_sigmaS_spectral_' , el_sigmaS , el % bandlist ) !  Release memory deallocate ( bt % el_response_T , el_kappa0 , el_sigmaS ) !------------------------------------------------------------------! !E: call print_message ( \"E field:\" ) ! RTA: call print_message ( \" Calculating RTA electron sigma and alpha/T...\" ) !  Allocate response function allocate ( bt % el_response_E ( el % nk , el % numbands , 3 )) !  Read response function call readfile_response ( 'RTA_J0_' , bt % el_response_E , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_sigma ( el % numbands , 3 , 3 , num % el_en_num ), & el_alphabyT ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'E' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , bt % el_response_E , el_en_grid , num % tetrahedra , sym , & el_alphabyT , el_sigma ) !  Write spectral electron alpha/T call write2file_spectral_tensor ( 'RTA_el_alphabyT_spectral_' , el_alphabyT , el % bandlist ) !  Write spectral electron sigma call write2file_spectral_tensor ( 'RTA_el_sigma_spectral_' , el_sigma , el % bandlist ) !------------------------------------------------------------------! ! Iterated: call print_message ( \" Calculating iterated electron sigma and alpha/T...\" ) !  Read response function call readfile_response ( 'nodrag_J0_' , bt % el_response_E , el % bandlist ) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'E' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , bt % el_response_E , el_en_grid , num % tetrahedra , sym , & el_alphabyT , el_sigma ) !  Write spectral electron alpha/T call write2file_spectral_tensor ( 'nodrag_iterated_el_alphabyT_spectral_' , el_alphabyT , el % bandlist ) !  Write spectral electron sigma call write2file_spectral_tensor ( 'nodrag_iterated_el_sigma_spectral_' , el_sigma , el % bandlist ) !  Release memory deallocate ( bt % el_response_E , el_alphabyT , el_sigma ) end if !Decoupled phonon BTE if (. not . num % onlyebte ) then call print_message ( \"Decoupled phonon BTE:\" ) call print_message ( \"---------------------\" ) !gradT: call print_message ( \"gradT field:\" ) ! RTA: call print_message ( \" Calculating RTA phonon kappa...\" ) !  Allocate response function allocate ( bt % ph_response_T ( ph % nq , ph % numbranches , 3 )) !  Read response function call readfile_response ( 'RTA_F0_' , bt % ph_response_T ) !  Allocate spectral transport coefficients allocate ( ph_kappa ( ph % numbranches , 3 , 3 , num % ph_en_num ), & dummy ( ph % numbranches , 3 , 3 , num % ph_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( ph , 'T' , crys % T , 1_k8 , 0.0_dp , ph % ens , ph % vels , & crys % volume , bt % ph_response_T , ph_en_grid , num % tetrahedra , sym , ph_kappa , dummy ) !  Write spectral phonon kappa call write2file_spectral_tensor ( 'RTA_ph_kappa_spectral_' , ph_kappa ) !------------------------------------------------------------------! ! Iterated: call print_message ( \" Calculating iterated phonon kappa...\" ) !  Read response function call readfile_response ( 'nodrag_F0_' , bt % ph_response_T ) !  Calculate spectral function call calculate_spectral_transport_coeff ( ph , 'T' , crys % T , 1_k8 , 0.0_dp , ph % ens , ph % vels , & crys % volume , bt % ph_response_T , ph_en_grid , num % tetrahedra , sym , ph_kappa , dummy ) !  Write spectral phonon kappa call write2file_spectral_tensor ( 'nodrag_iterated_ph_kappa_spectral_' , ph_kappa ) !  Release memory deallocate ( bt % ph_response_T , ph_kappa , dummy ) end if !Partially decoupled electron BTE if ( num % drag ) then call print_message ( \"Partially decoupled electron BTE:\" ) call print_message ( \"---------------------\" ) !gradT: call print_message ( \"gradT field:\" ) ! Iterated: call print_message ( \" Calculating iterated electron kappa0 and sigmaS...\" ) !  Allocate response function allocate ( bt % el_response_T ( el % nk , el % numbands , 3 )) !  Read response function call readfile_response ( 'partdcpl_I0_' , bt % el_response_T , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_kappa0 ( el % numbands , 3 , 3 , num % el_en_num ), & el_sigmaS ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'T' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , bt % el_response_T , el_en_grid , num % tetrahedra , sym , & el_kappa0 , el_sigmaS ) !  Write spectral electron kappa call write2file_spectral_tensor ( 'partdcpl_iterated_el_kappa0_spectral_' , el_kappa0 , el % bandlist ) !  Write spectral electron sigmaS call write2file_spectral_tensor ( 'partdcpl_iterated_el_sigmaS_spectral_' , el_sigmaS , el % bandlist ) !  Release memory deallocate ( bt % el_response_T , el_kappa0 , el_sigmaS ) !------------------------------------------------------------------! !E: call print_message ( \"E field:\" ) ! Iterated: call print_message ( \" Calculating iterated electron sigma and alpha/T...\" ) !  Allocate response function allocate ( bt % el_response_E ( el % nk , el % numbands , 3 )) !  Read response function call readfile_response ( 'partdcpl_J0_' , bt % el_response_E , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_sigma ( el % numbands , 3 , 3 , num % el_en_num ), & el_alphabyT ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'E' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , bt % el_response_E , el_en_grid , num % tetrahedra , sym , & el_alphabyT , el_sigma ) !  Write spectral electron alpha/T call write2file_spectral_tensor ( 'partdcpl_iterated_el_alphabyT_spectral_' , el_alphabyT , el % bandlist ) !  Write spectral electron sigma call write2file_spectral_tensor ( 'partdcpl_iterated_el_sigma_spectral_' , el_sigma , el % bandlist ) !  Release memory deallocate ( bt % el_response_E , el_alphabyT , el_sigma ) end if !Coupled electron BTE if ( num % drag ) then call print_message ( \"Coupled electron BTE:\" ) call print_message ( \"---------------------\" ) !gradT: call print_message ( \"gradT field:\" ) ! Iterated: call print_message ( \" Calculating iterated electron kappa0 and sigmaS...\" ) !  Allocate response function allocate ( bt % el_response_T ( el % nk , el % numbands , 3 )) !  Read response function call readfile_response ( 'drag_I0_' , bt % el_response_T , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_kappa0 ( el % numbands , 3 , 3 , num % el_en_num ), & el_sigmaS ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'T' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , bt % el_response_T , el_en_grid , num % tetrahedra , sym , & el_kappa0 , el_sigmaS ) !  Write spectral electron kappa call write2file_spectral_tensor ( 'drag_iterated_el_kappa0_spectral_' , el_kappa0 , el % bandlist ) !  Write spectral electron sigmaS call write2file_spectral_tensor ( 'drag_iterated_el_sigmaS_spectral_' , el_sigmaS , el % bandlist ) !  Release memory deallocate ( bt % el_response_T , el_kappa0 , el_sigmaS ) !------------------------------------------------------------------! !E: call print_message ( \"E field:\" ) ! Iterated: call print_message ( \" Calculating iterated electron sigma and alpha/T...\" ) !  Allocate response function allocate ( bt % el_response_E ( el % nk , el % numbands , 3 )) !  Read response function call readfile_response ( 'drag_J0_' , bt % el_response_E , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_sigma ( el % numbands , 3 , 3 , num % el_en_num ), & el_alphabyT ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'E' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , bt % el_response_E , el_en_grid , num % tetrahedra , sym , & el_alphabyT , el_sigma ) !  Write spectral electron alpha/T call write2file_spectral_tensor ( 'drag_iterated_el_alphabyT_spectral_' , el_alphabyT , el % bandlist ) !  Write spectral electron sigma call write2file_spectral_tensor ( 'drag_iterated_el_sigma_spectral_' , el_sigma , el % bandlist ) !  Release memory deallocate ( bt % el_response_E , el_alphabyT , el_sigma ) end if !Coupled phonon BTE if ( num % drag ) then call print_message ( \"Coupled phonon BTE:\" ) call print_message ( \"---------------------\" ) !gradT: call print_message ( \"gradT field:\" ) ! Iterated: call print_message ( \" Calculating iterated phonon kappa...\" ) !  Allocate response function allocate ( bt % ph_response_T ( ph % nq , ph % numbranches , 3 )) !  Read response function call readfile_response ( 'drag_F0_' , bt % ph_response_T ) !  Allocate spectral transport coefficients allocate ( ph_kappa ( ph % numbranches , 3 , 3 , num % ph_en_num ), & dummy ( ph % numbranches , 3 , 3 , num % ph_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( ph , 'T' , crys % T , 1_k8 , 0.0_dp , ph % ens , ph % vels , & crys % volume , bt % ph_response_T , ph_en_grid , num % tetrahedra , sym , ph_kappa , dummy ) !  Write spectral phonon kappa call write2file_spectral_tensor ( 'drag_iterated_ph_kappa_spectral_' , ph_kappa ) !  Release memory deallocate ( bt % ph_response_T , ph_kappa ) !E: call print_message ( \"E field:\" ) ! Iterated: call print_message ( \" Calculating iterated phonon alpha/T...\" ) !  Allocate response function allocate ( bt % ph_response_E ( ph % nq , ph % numbranches , 3 )) !  Read response function call readfile_response ( 'drag_G0_' , bt % ph_response_E ) !  Allocate spectral transport coefficients allocate ( ph_alphabyT ( ph % numbranches , 3 , 3 , num % ph_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( ph , 'E' , crys % T , 1_k8 , 0.0_dp , ph % ens , ph % vels , & crys % volume , bt % ph_response_E , ph_en_grid , num % tetrahedra , sym , ph_alphabyT , dummy ) !  Write spectral phonon kappa call write2file_spectral_tensor ( 'drag_iterated_ph_alphabyT_spectral_' , ph_alphabyT ) !  Release memory deallocate ( bt % ph_response_E , ph_alphabyT , dummy ) !------------------------------------------------------------------! end if !Return to working directory call chdir ( trim ( adjustl ( num % cwd ))) sync all end subroutine post_process end module bte_module","tags":"","loc":"sourcefile/bte.f90.html"},{"title":"delta.f90 – elphbolt","text":"This file depends on sourcefile~~delta.f90~~EfferentGraph sourcefile~delta.f90 delta.f90 sourcefile~misc.f90 misc.f90 sourcefile~delta.f90->sourcefile~misc.f90 sourcefile~params.f90 params.f90 sourcefile~delta.f90->sourcefile~params.f90 sourcefile~misc.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~delta.f90~~AfferentGraph sourcefile~delta.f90 delta.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~phonon.f90->sourcefile~delta.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~interactions.f90->sourcefile~delta.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 sourcefile~electron.f90 electron.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~electron.f90->sourcefile~delta.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~bz_sums.f90->sourcefile~delta.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 sourcefile~bte.f90 bte.f90 sourcefile~bte.f90->sourcefile~phonon.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~bte.f90->sourcefile~electron.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~phonon.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90->sourcefile~electron.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules delta Source Code delta.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module delta !! Module containing the procedures related to delta function evaulation. use params , only : dp , k8 use misc , only : exit_with_message , print_message , demux_vector , mux_vector , & binsearch , sort implicit none private public form_tetrahedra_3d , fill_tetrahedra_3d , delta_fn_tetra , & form_triangles , fill_triangles , delta_fn_triang contains pure real ( dp ) function delta_fn_tetra ( e , ik , ib , mesh , tetramap , tetracount , tetra_evals ) !! Calculate delta function using the tetraheron method. !! !! e Sample energy !! ik Wave vector index !! ib Band index !! mesh Wave vector grid !! tetramap Wave vector to (tetrahedron, vertex) mapping !! tetracount Number of tetrahedra in which a wave vector belongs !! tetra_evals Tetrahedra populated with the eigenvalues real ( dp ), intent ( in ) :: e integer ( k8 ), intent ( in ) :: ik , ib integer ( k8 ), intent ( in ) :: mesh ( 3 ), tetramap (:,:,:), tetracount (:) real ( dp ), intent ( in ) :: tetra_evals (:,:,:) !Local variables integer ( k8 ) :: iv , it , itk , num , numtetra logical :: c1 , c2 , c3 real ( dp ) :: e1 , e2 , e3 , e4 , e1e , e2e , e3e , e4e , & e21 , e31 , e41 , e32 , e42 , e43 , tmp ! eji \\equiv ej - ei tmp = 0.0_dp delta_fn_tetra = 0.0_dp !Total number of tetrahedra in the system numtetra = product ( mesh ) * 6 !Grab number of tetrahedra in which wave vector belongs num = tetracount ( ik ) do itk = 1 , num !Run over tetrahedra it = tetramap ( 1 , ik , itk ) !Grab tetrahedron iv = tetramap ( 2 , ik , itk ) !Grab vertex !Grab vertex energies e1 = tetra_evals ( it , ib , 1 ) e2 = tetra_evals ( it , ib , 2 ) e3 = tetra_evals ( it , ib , 3 ) e4 = tetra_evals ( it , ib , 4 ) !Define the energy differences e1e = e1 - e e2e = e2 - e e3e = e3 - e e4e = e4 - e e21 = e2 - e1 e31 = e3 - e1 e41 = e4 - e1 e32 = e3 - e2 e42 = e4 - e2 e43 = e4 - e3 !Evaluate the three cases c1 = e1 <= e . and . e <= e2 c2 = e2 <= e . and . e <= e3 c3 = e3 <= e . and . e <= e4 if (. not . ( e < e1 . or . e > e4 )) then !Evaluate the expressions for the three cases select case ( iv ) case ( 1 ) if ( c1 ) then tmp = ( e2e / e21 + e3e / e31 + e4e / e41 ) * ( e1e ** 2 ) / e41 / e31 / e21 if ( e1 == e2 ) then tmp = 0.0_dp end if else if ( c2 ) then tmp = - 0.5_dp * ( e3e / ( e31 ** 2 ) * ( e3e * e2e / e42 / e32 + e4e * e1e / e41 / e42 + e3e * e1e / e32 / e41 ) & + e4e / ( e41 ** 2 ) * ( e4e * e1e / e42 / e31 + e4e * e2e / e42 / e32 + e3e * e1e / e31 / e32 )) if ( e2 == e3 ) then tmp = - 0.5_dp * ( e4e * e1e / e41 / e42 + e1e / e41 & + e4e / ( e41 ** 2 ) * ( e4e * e1e / e42 / e31 + e4e / e42 + e1e / e31 )) end if else if ( c3 ) then tmp = ( e4e ** 3 ) / ( e41 ** 2 ) / e42 / e43 if ( e3 == e4 ) then tmp = ( e4e ** 2 ) / ( e41 ** 2 ) / e42 end if end if case ( 2 ) if ( c1 ) then tmp = - ( e1e ** 3 ) / ( e21 ** 2 ) / e31 / e41 if ( e1 == e2 ) then tmp = 0.0_dp end if else if ( c2 ) then tmp = - 0.5_dp * ( e3e / ( e32 ** 2 ) * ( e3e * e2e / e42 / e31 + e4e * e2e / e42 / e41 + e3e * e1e / e31 / e41 ) & + e4e / ( e42 ** 2 ) * ( e3e * e2e / e32 / e31 + e4e * e1e / e41 / e31 + e4e * e2e / e32 / e41 )) if ( e2 == e3 ) then tmp = - 0.5_dp * ( 0.0 + e4e / e42 / e41 + 0.0 & + e4e / ( e42 ** 2 ) * ( 0.0 + e4e * e1e / e41 / e31 + 1.0 )) end if else if ( c3 ) then tmp = ( e4e ** 3 ) / e41 / ( e42 ** 2 ) / e43 if ( e3 == e4 ) then tmp = 0.0_dp end if end if case ( 3 ) if ( c1 ) then tmp = - ( e1e ** 3 ) / e21 / ( e31 ** 2 ) / e41 if ( e1 == e2 ) then tmp = 0.0_dp end if else if ( c2 ) then tmp = 0.5_dp * ( e2e / ( e32 ** 2 ) * ( e3e * e2e / e42 / e31 + e4e * e2e / e42 / e41 + e3e * e1e / e31 / e41 ) & + e1e / ( e31 ** 2 ) * ( e3e * e2e / e42 / e32 + e4e * e1e / e41 / e42 + e3e * e1e / e32 / e41 )) if ( e2 == e3 ) then tmp = 0.5_dp * ( 0.0 + e4e / e42 / e41 + e1e / e31 / e41 & + e1e / ( e31 ** 2 ) * ( 0.0 + e4e * e1e / e41 / e42 + e1e / e41 )) end if else if ( c3 ) then tmp = ( e4e ** 3 ) / e41 / e42 / ( e43 ** 2 ) if ( e3 == e4 ) then tmp = 0.0_dp end if end if case ( 4 ) if ( c1 ) then tmp = - ( e1e ** 3 ) / e21 / e31 / ( e41 ** 2 ) if ( e1 == e2 ) then tmp = 0.0_dp end if else if ( c2 ) then tmp = 0.5_dp * ( e2e / ( e42 ** 2 ) * ( e3e * e2e / e32 / e31 + e4e * e1e / e41 / e31 + e4e * e2e / e32 / e41 ) & + e1e / ( e41 ** 2 ) * ( e4e * e1e / e42 / e31 + e4e * e2e / e42 / e32 + e3e * e1e / e31 / e32 )) if ( e2 == e3 ) then tmp = 0.5_dp * ( 0.0 & + e1e / ( e41 ** 2 ) * ( e4e * e1e / e42 / e31 + e4e / e42 + e1e / e31 )) end if else if ( c3 ) then tmp = - ( e3e / e43 + e2e / e42 + e1e / e41 ) * ( e4e ** 2 ) / e41 / e42 / e43 if ( e3 == e4 ) then tmp = 0.0_dp end if end if end select if (( e1 == e2 ) . and . ( e1 == e3 ) . and . ( e1 == e4 ) . and . ( e == e1 )) then tmp = 0.25_dp end if delta_fn_tetra = delta_fn_tetra + tmp end if ! .not. (e <= e1 .or. e >= e4) end do !itk if ( delta_fn_tetra < 1.0e-12_dp ) delta_fn_tetra = 0.0_dp !Normalize with the total number of tetrahedra delta_fn_tetra = delta_fn_tetra / numtetra end function delta_fn_tetra subroutine form_tetrahedra_3d ( nk , mesh , tetra , tetracount , tetramap , & blocks , indexlist ) !! Form all the tetrahedra of a 3d FBZ mesh. !! !! nk Number of points in the list of FBZ wave vectors !! mesh Wave vector grid !! tetra List of the tetrahedra vertices !! tetracount Number of tetrahedra in which a wave vector belongs !! tetramap Wave vector to (tetrahedron, vertex) mapping !! blocks Is the FBZ wave vector list full or energy restricted? !! indexlist List of muxed indices of the FBZ wave vectors integer ( k8 ), intent ( in ) :: nk , mesh ( 3 ) integer ( k8 ), intent ( out ), allocatable :: tetra (:,:), tetracount (:), tetramap (:,:,:) logical , intent ( in ) :: blocks integer ( k8 ), optional , intent ( in ) :: indexlist (:) !Local variables integer ( k8 ) :: ik , i , j , k , ijk ( 3 ), ii , jj , kk , tk , tl , aux , count integer ( k8 ) :: ip1 , jp1 , kp1 , n1 , n2 , n3 , tmp integer ( k8 ) :: tetra_vertices_labels ( 6 , 4 ) integer ( k8 ) :: scvol_vertices ( 8 , 3 ) ! subcell volume vertices n1 = mesh ( 1 ) n2 = mesh ( 2 ) n3 = mesh ( 3 ) !Label of the vertices of the tetrahedra for a given subcell tetra_vertices_labels = reshape (( / & 1 , 2 , 3 , 6 , & 1 , 3 , 5 , 6 , & 3 , 5 , 6 , 7 , & 3 , 6 , 7 , 8 , & 3 , 4 , 6 , 8 , & 2 , 3 , 4 , 6 / ), & shape ( tetra_vertices_labels ), order = ( / 2 , 1 / )) !Allocate tetrahedra related variables allocate ( tetra ( 6 * nk , 4 ), tetracount ( nk ), tetramap ( 2 , nk , 24 )) tetra (:,:) = 0 tetracount (:) = 0 tetramap (:,:,:) = 0 count = 1 !tetrahedron counter do ik = 1 , nk !Run over all wave vectors in FBZ if ( blocks ) then !For energy window restricted FBZ call demux_vector ( indexlist ( ik ), ijk , mesh , 1_k8 ) else !For unrestristed FBZ call demux_vector ( ik , ijk , mesh , 1_k8 ) end if i = ijk ( 1 ) j = ijk ( 2 ) k = ijk ( 3 ) !Apply periodic boundary condition if ( i == n1 ) then ip1 = 1 else ip1 = i + 1 end if if ( j == n2 ) then jp1 = 1 else jp1 = j + 1 end if if ( k == n3 ) then kp1 = 1 else kp1 = k + 1 end if !For each subcell save the vertices scvol_vertices = reshape (( / & i , j , k , & ip1 , j , k , & i , jp1 , k , & ip1 , jp1 , k , & i , j , kp1 , & ip1 , j , kp1 , & i , jp1 , kp1 , & ip1 , jp1 , kp1 / ), & shape ( scvol_vertices ), order = ( / 2 , 1 / )) do tk = 1 , 6 !Run over 6 tetrahedra do tl = 1 , 4 !Run over the labels of the vertices that !make up each tetrahedron aux = tetra_vertices_labels ( tk , tl ) ii = scvol_vertices ( aux , 1 ) jj = scvol_vertices ( aux , 2 ) kk = scvol_vertices ( aux , 3 ) aux = mux_vector (( / ii , jj , kk / ), mesh , 1_k8 ) tmp = aux !Guaranteed to be > 0 if ( blocks ) then !Which point in indexlist does aux correspond to? call binsearch ( indexlist , aux , tmp ) !tmp < 0 if search fails. end if tetra ( count , tl ) = tmp if ( tmp > 0 ) then !Save the mapping of a wave vector index to a (tetrahedron, vertex) tetracount ( tmp ) = tetracount ( tmp ) + 1 tetramap ( 1 , tmp , tetracount ( tmp )) = count tetramap ( 2 , tmp , tetracount ( tmp )) = tl end if end do count = count + 1 end do end do end subroutine form_tetrahedra_3d subroutine fill_tetrahedra_3d ( tetra , evals , tetra_evals ) !! Populate the (sorted along the vertices) eigenvalues on all the vertices of the tetrahedra !! !! tetra List of the tetrahedra vertices !! evals List of eigenvalues !! tetra_evals Tetrahedra populated with the eigenvalues integer ( k8 ), intent ( in ) :: tetra (:,:) real ( dp ), intent ( in ) :: evals (:,:) real ( dp ), allocatable , intent ( out ) :: tetra_evals (:,:,:) !Local variables integer ( k8 ) :: iv , it , ib , numbands , aux , numtetra numtetra = size ( tetra (:, 1 )) numbands = size ( evals ( 1 , :)) allocate ( tetra_evals ( numtetra , numbands , 4 )) !Note: Eigenvalues outside the transport active window is taken to be zero. !      As such, close to the transport window boundary, this method is inaccurate. !      A large enough transport window must be chosen to obtain accurate transport coefficients. tetra_evals (:,:,:) = 0.0_dp do it = 1 , numtetra !Run over tetrahedra do ib = 1 , numbands !Run over bands do iv = 1 , 4 !Run over vertices aux = tetra ( it , iv ) if ( aux > 0 ) then !Only eigenvalues inside transport active region tetra_evals ( it , ib , iv ) = evals ( aux , ib ) end if end do call sort ( tetra_evals ( it , ib , :)) end do end do end subroutine fill_tetrahedra_3d subroutine form_triangles ( nk , mesh , triang , triangcount , triangmap , & blocks , indexlist ) !! Form all the triangles of a 3d FBZ mesh for each z component. !! !! nk Number of points in the list of FBZ wave vectors !! mesh Wave vector grid !! triang List of the triangle vertices !! triangcount Number of triangles in which a wave vector belongs !! triangmap Wave vector to (triangle, vertex) mapping !! blocks Is the FBZ wave vector list full or energy restricted? !! indexlist List of muxed indices of the FBZ wave vectors integer ( k8 ), intent ( in ) :: nk , mesh ( 3 ) integer ( k8 ), intent ( out ), allocatable :: triang (:,:), triangcount (:), triangmap (:,:,:) logical , intent ( in ) :: blocks integer ( k8 ), optional , intent ( in ) :: indexlist (:) !Local variables integer ( k8 ) :: ik , i , j , k , ijk ( 3 ), ii , jj , kk , tk , tl , aux , count integer ( k8 ) :: ip1 , jp1 , n1 , n2 , n3 , tmp integer ( k8 ) :: triang_vertices_labels ( 2 , 3 ) integer ( k8 ) :: scvol_vertices ( 4 , 3 ) !subcell vertices n1 = mesh ( 1 ) n2 = mesh ( 2 ) n3 = mesh ( 3 ) !Label of the vertices of the triangles for a given subcell triang_vertices_labels = reshape (( / & 1 , 2 , 3 ,& 1 , 3 , 4 / ), & shape ( triang_vertices_labels ), order = ( / 2 , 1 / )) !Allocate triangles related variables allocate ( triang ( 2 * nk , 3 ), triangcount ( nk ), triangmap ( 2 , nk , 6 )) triang (:,:) = 0 triangcount (:) = 0 triangmap (:,:,:) = 0 count = 1 !triangles counter do ik = 1 , nk !Run over all wave vectors in FBZ if ( blocks ) then !For energy window restricted FBZ call demux_vector ( indexlist ( ik ), ijk , mesh , 1_k8 ) else !For unrestristed FBZ call demux_vector ( ik , ijk , mesh , 1_k8 ) end if i = ijk ( 1 ) j = ijk ( 2 ) k = ijk ( 3 ) !Apply periodic boundary condition if ( i == n1 ) then ip1 = 1 else ip1 = i + 1 end if if ( j == n2 ) then jp1 = 1 else jp1 = j + 1 end if !For each subcell save the vertices scvol_vertices = reshape (( / & i , j , k , & ip1 , j , k , & i , jp1 , k , & ip1 , jp1 , k / ), & shape ( scvol_vertices ), order = ( / 2 , 1 / )) !Run over the 2 triangles do tk = 1 , 2 !Run over the labels of the vertices that !make up each triangle do tl = 1 , 3 aux = triang_vertices_labels ( tk , tl ) ii = scvol_vertices ( aux , 1 ) jj = scvol_vertices ( aux , 2 ) kk = scvol_vertices ( aux , 3 ) aux = mux_vector (( / ii , jj , kk / ), mesh , 1_k8 ) tmp = aux !Guaranteed to be > 0 if ( blocks ) then !Which point in indexlist does aux correspond to? call binsearch ( indexlist , aux , tmp ) !tmp < 0 if search fails. end if triang ( count , tl ) = tmp if ( tmp > 0 ) then !Save the mapping of a wave vector index to a (triangle, vertex) triangcount ( tmp ) = triangcount ( tmp ) + 1 triangmap ( 1 , tmp , triangcount ( tmp )) = count triangmap ( 2 , tmp , triangcount ( tmp )) = tl end if end do count = count + 1 end do end do end subroutine form_triangles subroutine fill_triangles ( triang , evals , triang_evals ) !! Populate the (sorted along the vertices) eigenvalues on all the vertices of the triangles !! !! triang List of the triangle vertices !! evals List of eigenvalues !! triang_evals Triangles populated with the eigenvalues integer ( k8 ), intent ( in ) :: triang (:,:) real ( dp ), intent ( in ) :: evals (:,:) real ( dp ), allocatable , intent ( out ) :: triang_evals (:,:,:) !Local variables integer ( k8 ) :: iv , it , ib , numbands , aux , numtriangs , numvertices numtriangs = size ( triang (:, 1 )) numbands = size ( evals ( 1 , :)) numvertices = 3 allocate ( triang_evals ( numtriangs , numbands , numvertices )) !Note: Eigenvalues outside the transport active window is taken to be zero. !      As such, close to the transport window boundary, this method is inaccurate. !      A large enough transport window must be chosen to obtain accurate transport coefficients. triang_evals (:,:,:) = 0.0_dp do it = 1 , numtriangs !Run over triangles do ib = 1 , numbands !Run over bands do iv = 1 , numvertices !Run over vertices aux = triang ( it , iv ) if ( aux > 0 ) then !Only eigenvalues inside transport active region triang_evals ( it , ib , iv ) = evals ( aux , ib ) end if end do call sort ( triang_evals ( it , ib , :)) end do end do end subroutine fill_triangles pure real ( dp ) function delta_fn_triang ( e , ik , ib , mesh , triangmap , triangcount , triang_evals ) !! Calculate delta function using the triangle method a la !! Kurganskii et al. Phys. Stat. Sol.(b) 129, 293 (1985) !! !! e Sample energy !! ik Wave vector index !! ib Band index !! mesh Wave vector grid !! triangmap Wave vector to (triangle, vertex) mapping !! triangcount Number of triangles in which a wave vector belongs !! triang_evals Triangles populated with the eigenvalues real ( dp ), intent ( in ) :: e integer ( k8 ), intent ( in ) :: ik , ib integer ( k8 ), intent ( in ) :: mesh ( 3 ), triangmap (:,:,:), triangcount (:) real ( dp ), intent ( in ) :: triang_evals (:,:,:) !Local variables integer ( k8 ) :: iv , it , itk , num , numtriangs logical :: c1 , c2 , c3 , c4 real ( dp ) :: e1 , e2 , e3 , E12 , E21 , E13 , E31 , E23 , E32 , tmp tmp = 0.0_dp delta_fn_triang = 0.0_dp !Total number of triangles in the system numtriangs = product ( mesh ) * 2 !Grab number of triangles in which wave vector belongs num = triangcount ( ik ) do itk = 1 , num !Run over triangles it = triangmap ( 1 , ik , itk ) !Grab triangle iv = triangmap ( 2 , ik , itk ) !Grab vertex !Grab vertex energies e1 = triang_evals ( it , ib , 1 ) e2 = triang_evals ( it , ib , 2 ) e3 = triang_evals ( it , ib , 3 ) !Evaluate the four possible cases c1 = e <= e1 c2 = e1 < e . and . e <= e2 c3 = e2 < e . and . e <= e3 c4 = e3 < e tmp = 0.0_dp if ( c1 . or . c4 ) cycle !Define Eij ! Note that at this stage the quantities below might ! be ill defined due to degeneracies. But the conditionals ! that will follow will take this into account. E12 = ( e - e2 ) / ( e1 - e2 ) E21 = ( e - e1 ) / ( e2 - e1 ) E13 = ( e - e3 ) / ( e1 - e3 ) E31 = ( e - e1 ) / ( e3 - e1 ) E23 = ( e - e3 ) / ( e2 - e3 ) E32 = ( e - e2 ) / ( e3 - e2 ) select case ( iv ) case ( 1 ) if ( c2 ) then tmp = E21 * ( E12 + E13 ) / ( e3 - e1 ) else if ( c3 ) then tmp = E23 * E13 / ( e3 - e1 ) end if case ( 2 ) if ( c2 ) then tmp = E21 * E21 / ( e3 - e1 ) else if ( c3 ) then tmp = E23 * E23 / ( e3 - e1 ) end if case ( 3 ) if ( c2 ) then tmp = E21 * E31 / ( e3 - e1 ) else if ( c3 ) then tmp = E23 * ( E31 + E32 ) / ( e3 - e1 ) end if end select delta_fn_triang = delta_fn_triang + tmp end do !itk if ( delta_fn_triang < 1.0e-12_dp ) delta_fn_triang = 0.0_dp !Normalize with the total number of triangles delta_fn_triang = delta_fn_triang / numtriangs end function delta_fn_triang end module delta","tags":"","loc":"sourcefile/delta.f90.html"},{"title":"elphbolt.f90 – elphbolt","text":"This file depends on sourcefile~~elphbolt.f90~~EfferentGraph sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~misc.f90 misc.f90 sourcefile~elphbolt.f90->sourcefile~misc.f90 sourcefile~electron.f90 electron.f90 sourcefile~elphbolt.f90->sourcefile~electron.f90 sourcefile~numerics.f90 numerics.f90 sourcefile~elphbolt.f90->sourcefile~numerics.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~bte.f90 bte.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 sourcefile~crystal.f90 crystal.f90 sourcefile~elphbolt.f90->sourcefile~crystal.f90 sourcefile~wannier.f90 wannier.f90 sourcefile~elphbolt.f90->sourcefile~wannier.f90 sourcefile~params.f90 params.f90 sourcefile~elphbolt.f90->sourcefile~params.f90 sourcefile~symmetry.f90 symmetry.f90 sourcefile~elphbolt.f90->sourcefile~symmetry.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~elphbolt.f90->sourcefile~phonon.f90 sourcefile~interactions.f90->sourcefile~misc.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~interactions.f90->sourcefile~numerics.f90 sourcefile~interactions.f90->sourcefile~crystal.f90 sourcefile~interactions.f90->sourcefile~wannier.f90 sourcefile~interactions.f90->sourcefile~params.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 sourcefile~delta.f90 delta.f90 sourcefile~interactions.f90->sourcefile~delta.f90 sourcefile~misc.f90->sourcefile~params.f90 sourcefile~electron.f90->sourcefile~misc.f90 sourcefile~electron.f90->sourcefile~numerics.f90 sourcefile~electron.f90->sourcefile~crystal.f90 sourcefile~electron.f90->sourcefile~wannier.f90 sourcefile~electron.f90->sourcefile~params.f90 sourcefile~electron.f90->sourcefile~symmetry.f90 sourcefile~electron.f90->sourcefile~delta.f90 sourcefile~numerics.f90->sourcefile~misc.f90 sourcefile~numerics.f90->sourcefile~crystal.f90 sourcefile~numerics.f90->sourcefile~params.f90 sourcefile~bz_sums.f90->sourcefile~misc.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 sourcefile~bz_sums.f90->sourcefile~crystal.f90 sourcefile~bz_sums.f90->sourcefile~params.f90 sourcefile~bz_sums.f90->sourcefile~symmetry.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 sourcefile~bz_sums.f90->sourcefile~delta.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~bte.f90->sourcefile~misc.f90 sourcefile~bte.f90->sourcefile~electron.f90 sourcefile~bte.f90->sourcefile~numerics.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~bte.f90->sourcefile~crystal.f90 sourcefile~bte.f90->sourcefile~params.f90 sourcefile~bte.f90->sourcefile~symmetry.f90 sourcefile~bte.f90->sourcefile~phonon.f90 sourcefile~crystal.f90->sourcefile~misc.f90 sourcefile~crystal.f90->sourcefile~params.f90 sourcefile~wannier.f90->sourcefile~misc.f90 sourcefile~wannier.f90->sourcefile~numerics.f90 sourcefile~wannier.f90->sourcefile~crystal.f90 sourcefile~wannier.f90->sourcefile~params.f90 sourcefile~symmetry.f90->sourcefile~misc.f90 sourcefile~symmetry.f90->sourcefile~crystal.f90 sourcefile~symmetry.f90->sourcefile~params.f90 sourcefile~spglib_wrapper.f90 spglib_wrapper.f90 sourcefile~symmetry.f90->sourcefile~spglib_wrapper.f90 sourcefile~phonon.f90->sourcefile~misc.f90 sourcefile~phonon.f90->sourcefile~numerics.f90 sourcefile~phonon.f90->sourcefile~crystal.f90 sourcefile~phonon.f90->sourcefile~wannier.f90 sourcefile~phonon.f90->sourcefile~params.f90 sourcefile~phonon.f90->sourcefile~symmetry.f90 sourcefile~phonon.f90->sourcefile~delta.f90 sourcefile~spglib_wrapper.f90->sourcefile~params.f90 sourcefile~delta.f90->sourcefile~misc.f90 sourcefile~delta.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs elphbolt Source Code elphbolt.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. program elphbolt !! Author: Nakib Haider Protik !! Summary: Main driver program. !! Version: 1.0.0 !! !! elphbolt is a program for solving the coupled electron-phonon Boltzmann transport equations !! (e-ph BTEs) as formulated in https://arxiv.org/abs/2109.08547 (2021) with both the !! electron-phonon and phonon-phonon interactions computed ab initio. use params , only : k8 , dp use misc , only : welcome , print_message , subtitle use numerics_module , only : numerics use crystal_module , only : crystal use symmetry_module , only : symmetry use electron_module , only : electron use phonon_module , only : phonon use wannier_module , only : epw_wannier use bte_module , only : bte use bz_sums , only : calculate_dos , calculate_qTF use interactions , only : calculate_gReq , calculate_gkRp , calculate_3ph_interaction , & calculate_eph_interaction_ibzq , calculate_eph_interaction_ibzk , & calculate_echimp_interaction_ibzk implicit none type ( numerics ) :: num type ( crystal ) :: crys type ( symmetry ) :: sym type ( epw_wannier ) :: wann type ( electron ) :: el type ( phonon ) :: ph type ( bte ) :: bt !Print banner and other information call welcome !Set up crystal call crys % initialize !Set up numerics data call num % initialize ( crys ) !Calculate crystal and BZ symmetries call sym % calculate_symmetries ( crys , num % qmesh ) if ( num % onlyebte . or . num % drag . or . num % phe . or . num % plot_along_path ) then !Read EPW Wannier data call wann % read ( num ) !Calculate electrons call el % initialize ( wann , crys , sym , num ) end if !Calculate phonons call ph % initialize ( crys , sym , num ) select case ( num % runlevel ) case ( 1 ) !BTE solving case call subtitle ( \"Calculating density of states...\" ) if ( num % onlyebte . or . num % drag ) then !Calculate electron density of states call calculate_dos ( el , num % tetrahedra ) !Calculate Thomas-Fermi screening call calculate_qTF ( crys , el ) end if !Calculate phonon density of states and, if needed, phonon-isotope !and/or phonon-substitution scattering rates. call calculate_dos ( ph , num % tetrahedra , crys % gfactors , crys % subs_gfactors , & crys % atomtypes , bt % ph_rta_rates_iso_ibz , bt % ph_rta_rates_subs_ibz , & num % phiso , num % phsubs ) if ( num % plot_along_path ) then call subtitle ( \"Plotting along high-symmetry path...\" ) !Plot electron bands, phonon dispersions, and g along path. call wann % plot_along_path ( crys , num ) end if call subtitle ( \"Calculating interactions...\" ) !Set chemical potential dependent directory call num % create_chempot_dirs ( el % chempot ) if ( num % onlyphbte . and . num % phe . or . num % drag ) then if (. not . num % read_gq2 ) then !Calculate mixed Bloch-Wannier space e-ph vertex g(Re,q) call calculate_gReq ( wann , ph , num ) !Calculate Bloch space e-ph vertex g(k,q) for IBZ q call calculate_eph_interaction_ibzq ( wann , crys , el , ph , num , 'g' ) end if !Calculate ph-e transition probabilities call calculate_eph_interaction_ibzq ( wann , crys , el , ph , num , 'Y' ) end if if ( num % onlyebte . or . num % drag ) then if (. not . num % read_gk2 ) then !Calculate mixed Bloch-Wannier space e-ph vertex g(k,Rp) call calculate_gkRp ( wann , el , num ) !Calculate Bloch space e-ph vertex g(k,q) for IBZ k call calculate_eph_interaction_ibzk ( wann , crys , el , ph , num , 'g' ) end if !Calculate e-ph transition probabilities call calculate_eph_interaction_ibzk ( wann , crys , el , ph , num , 'X' ) end if if ( num % onlyebte . or . num % drag . or . num % phe . or . num % drag & . or . num % plot_along_path ) then !Deallocate Wannier quantities call wann % deallocate_wannier ( num ) end if if ( num % onlyebte . or . num % drag . or . num % phe ) then !After this point the electron eigenvectors are not needed call el % deallocate_eigenvecs end if if ( num % onlyebte . or . num % drag ) then if ( num % elchimp ) then !Calculate e-ch. imp. transition probabilities call calculate_echimp_interaction_ibzk ( crys , el , num ) end if end if if ( num % onlyphbte . or . num % drag ) then if (. not . num % read_V ) then !Calculate ph-ph vertex call calculate_3ph_interaction ( ph , crys , num , 'V' ) end if if (. not . num % read_W ) then !Calculate ph-ph transition probabilities call calculate_3ph_interaction ( ph , crys , num , 'W' ) end if end if if ( num % onlyphbte . or . num % drag ) then !After this point the phonon eigenvectors and other quantities are not needed call ph % deallocate_phonon_quantities end if !Solve BTEs if ( num % onlyphbte . and . . not . num % phe ) then call bt % solve_bte ( num , crys , sym , ph ) else call bt % solve_bte ( num , crys , sym , ph , el ) end if case ( 2 ) !Post-processing case call subtitle ( \"Post-processing...\" ) !Read RTA response functions from finished calculation if ( num % onlyphbte . and . . not . num % phe ) then call bt % post_process ( num , crys , sym , ph ) else call bt % post_process ( num , crys , sym , ph , el ) end if end select call print_message ( '______________________Thanks for using elphbolt. Bye!______________________' ) end program elphbolt","tags":"","loc":"sourcefile/elphbolt.f90.html"},{"title":"phonon.f90 – elphbolt","text":"This file depends on sourcefile~~phonon.f90~~EfferentGraph sourcefile~phonon.f90 phonon.f90 sourcefile~misc.f90 misc.f90 sourcefile~phonon.f90->sourcefile~misc.f90 sourcefile~numerics.f90 numerics.f90 sourcefile~phonon.f90->sourcefile~numerics.f90 sourcefile~wannier.f90 wannier.f90 sourcefile~phonon.f90->sourcefile~wannier.f90 sourcefile~params.f90 params.f90 sourcefile~phonon.f90->sourcefile~params.f90 sourcefile~crystal.f90 crystal.f90 sourcefile~phonon.f90->sourcefile~crystal.f90 sourcefile~symmetry.f90 symmetry.f90 sourcefile~phonon.f90->sourcefile~symmetry.f90 sourcefile~delta.f90 delta.f90 sourcefile~phonon.f90->sourcefile~delta.f90 sourcefile~misc.f90->sourcefile~params.f90 sourcefile~numerics.f90->sourcefile~misc.f90 sourcefile~numerics.f90->sourcefile~params.f90 sourcefile~numerics.f90->sourcefile~crystal.f90 sourcefile~wannier.f90->sourcefile~misc.f90 sourcefile~wannier.f90->sourcefile~numerics.f90 sourcefile~wannier.f90->sourcefile~params.f90 sourcefile~wannier.f90->sourcefile~crystal.f90 sourcefile~crystal.f90->sourcefile~misc.f90 sourcefile~crystal.f90->sourcefile~params.f90 sourcefile~symmetry.f90->sourcefile~misc.f90 sourcefile~symmetry.f90->sourcefile~params.f90 sourcefile~symmetry.f90->sourcefile~crystal.f90 sourcefile~spglib_wrapper.f90 spglib_wrapper.f90 sourcefile~symmetry.f90->sourcefile~spglib_wrapper.f90 sourcefile~delta.f90->sourcefile~misc.f90 sourcefile~delta.f90->sourcefile~params.f90 sourcefile~spglib_wrapper.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~phonon.f90~~AfferentGraph sourcefile~phonon.f90 phonon.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 sourcefile~bte.f90 bte.f90 sourcefile~bte.f90->sourcefile~phonon.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~phonon.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules phonon_module Source Code phonon.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module phonon_module !! Module containing type and procedures related to the phononic properties. use params , only : dp , k8 , bohr2nm , pi , twopi , Ryd2eV , oneI use misc , only : print_message , subtitle , expi , distribute_points , & write2file_rank2_real , exit_with_message use numerics_module , only : numerics use wannier_module , only : epw_wannier use crystal_module , only : crystal , calculate_wavevectors_full use symmetry_module , only : symmetry , find_irred_wedge , create_fbz2ibz_map use delta , only : form_tetrahedra_3d , fill_tetrahedra_3d , form_triangles , & fill_triangles implicit none private public phonon , phonon_espresso type phonon !! Data and procedures related to phonons. character ( len = 2 ) :: prefix = 'ph' !! Prefix idenitfying particle type. integer ( k8 ) :: numbranches !! Total number of phonon branches. integer ( k8 ) :: nq !! Number of phonon wave vectors in the full Brillouin zone (FBZ). integer ( k8 ) :: nq_irred !! Number of phonon wave vectors in the irreducible wedge of Brillouin zone (IBZ). integer ( k8 ) :: qmesh ( 3 ) !! Phonon wave vector mesh. real ( dp ), allocatable :: wavevecs (:,:) !! List of all phonon wave vectors (crystal coordinates). real ( dp ), allocatable :: wavevecs_irred (:,:) !! List of irreducible phonon wave vectors (crystal coordinates). integer ( k8 ), allocatable :: indexlist_irred (:) !! List of muxed indices of the IBZ wedge. integer ( k8 ), allocatable :: nequiv (:) !! List of the number of equivalent points for each IBZ point. integer ( k8 ), allocatable :: ibz2fbz_map (:,:,:) !! Map from an IBZ phonon point to its images. !! The third axis contains the pair (symmetry index, image). integer ( k8 ), allocatable :: equiv_map (:,:) !! Map of equivalent points under rotations. !! Axis 1 runs over rotations. !! Axis 2 runs over wave vectors (full Brillouin zone). real ( dp ), allocatable :: symmetrizers (:,:,:) !! Symmetrizers of wave vector dependent vectors. integer ( k8 ), allocatable :: tetra (:,:) !! List of all the wave vector mesh tetrahedra vertices. !! First axis lists tetraheda and the second axis lists the vertices. integer ( k8 ), allocatable :: tetracount (:) !! The number of tetrahedra in which a wave vector belongs. integer ( k8 ), allocatable :: tetramap (:,:,:) !! Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real ( dp ), allocatable :: tetra_evals (:,:,:) !! Tetrahedra vertices filled with eigenvalues. integer ( k8 ), allocatable :: triang (:,:) !! List of all the wave vector mesh triangles vertices. !! First axis lists triangles and the second axis lists the vertices. integer ( k8 ), allocatable :: triangcount (:) !! The number of triangles in which a wave vector belongs. integer ( k8 ), allocatable :: triangmap (:,:,:) !! Mapping from a wave vector to the (triangle, vertex) where it belongs. real ( dp ), allocatable :: triang_evals (:,:,:) !! Triangles vertices filled with eigenvalues. real ( dp ), allocatable :: ens (:,:) !! List of phonon energies on FBZ. real ( dp ), allocatable :: vels (:,:,:) !! List of phonon velocities on IBZ. complex ( dp ), allocatable :: evecs (:,:,:) !! List of all phonon eigenvectors on IBZ. integer ( k8 ) :: scell ( 3 ) !! q-mesh used in DFPT or, equivalently, supercell used in finite displencement !! method for calculating the 2nd order force constants. real ( dp ), allocatable :: ifc2 (:,:,:,:,:,:,:) !! Second order force constants (ifc2) tensor. real ( dp ), allocatable :: ifc3 (:,:,:,:) !! Third order force constants (ifc3) tensor. integer ( k8 ) :: numtriplets !! Number of triplets in the ifc3 file. real ( dp ), allocatable :: R_j (:,:), R_k (:,:) !! Position of the 2nd and 3rd atoms in supercell for an ifc3 triplet. integer ( k8 ), allocatable :: Index_i (:), Index_j (:), Index_k (:) !! Label of primitive cell atoms in the ifc3 triplet. real ( dp ), allocatable :: dos (:,:) !! Branch resolved density of states. !Data read from ifc2 file. This will be used in the phonon calculation. real ( dp ) :: rws ( 124 , 0 : 3 ), cell_r ( 1 : 3 , 0 : 3 ), cell_g ( 1 : 3 , 0 : 3 ) real ( dp ), allocatable :: mm (:,:), rr (:,:,:) contains procedure :: initialize , deallocate_phonon_quantities end type phonon contains subroutine initialize ( ph , crys , sym , num ) !! Initialize the phonon data type, calculate ground state phonon properties, !! and read 3rd order force constants data. class ( phonon ), intent ( out ) :: ph type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( numerics ), intent ( in ) :: num call subtitle ( \"Setting up phonons...\" ) !Set phonon branches ph % numbranches = crys % numatoms * 3 !Set wave vector mesh ph % qmesh = num % qmesh !Set number of phonon wave vectors ph % nq = product ( ph % qmesh (:)) !Read ifc2 and related quantities call read_ifc2 ( ph , crys ) !Calculate harmonic properties call calculate_phonons ( ph , crys , sym , num ) if (. not . num % onlyebte ) then !Read ifc3s and related quantities call read_ifc3 ( ph , crys ) end if end subroutine initialize subroutine deallocate_phonon_quantities ( ph ) !! Deallocate the electron eigenvectors class ( phonon ), intent ( inout ) :: ph deallocate ( ph % evecs , ph % ifc2 , ph % ifc3 , ph % Index_i , ph % Index_j , ph % Index_k , & ph % mm , ph % rr ) end subroutine deallocate_phonon_quantities subroutine calculate_phonons ( ph , crys , sym , num ) !! Calculate phonon quantities on the FBZ and IBZ meshes. class ( phonon ), intent ( inout ) :: ph type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( numerics ), intent ( in ) :: num !Local variables integer ( k8 ) :: i , iq , ii , jj , kk , l , il , s , ib , im , chunk , & num_active_images integer ( k8 ), allocatable :: start [:], end [:] real ( dp ), allocatable :: ens_chunk (:,:)[:], vels_chunk (:,:,:)[:], & symmetrizers_chunk (:,:,:)[:] complex ( dp ), allocatable :: evecs_chunk (:,:,:)[:] !Switch for mesh utilites with or without energy restriction logical :: blocks character ( len = 1024 ) :: numcols blocks = . false . call print_message ( \"Calculating phonon FBZ quantities...\" ) !Allocate start and end coarrays allocate ( start [ * ], end [ * ]) !Divide wave vectors among images call distribute_points ( ph % nq , chunk , start , end , num_active_images ) !Allocate small work variable chunk for each image allocate ( ens_chunk ( chunk , ph % numbranches )[ * ]) allocate ( vels_chunk ( chunk , ph % numbranches , 3 )[ * ]) allocate ( evecs_chunk ( chunk , ph % numbranches , ph % numbranches )[ * ]) !Calculate FBZ mesh call calculate_wavevectors_full ( ph % qmesh , ph % wavevecs , blocks ) !Print phonon FBZ mesh call write2file_rank2_real ( \"ph.wavevecs_fbz\" , ph % wavevecs ) !Calculate FBZ phonon quantities call phonon_espresso ( ph , crys , chunk , ph % wavevecs ( start : end , :), & ens_chunk , evecs_chunk , vels_chunk ) !Gather the chunks from the images allocate ( ph % ens ( ph % nq , ph % numbranches )) allocate ( ph % vels ( ph % nq , ph % numbranches , 3 )) allocate ( ph % evecs ( ph % nq , ph % numbranches , ph % numbranches )) sync all do im = 1 , num_active_images ph % ens ( start [ im ]: end [ im ], :) = ens_chunk (:,:)[ im ] ph % vels ( start [ im ]: end [ im ], :, :) = vels_chunk (:,:,:)[ im ] ph % evecs ( start [ im ]: end [ im ], :, :) = evecs_chunk (:,:,:)[ im ] end do sync all deallocate ( ens_chunk , vels_chunk , evecs_chunk ) !Calculate IBZ mesh call print_message ( \"Calculating IBZ and IBZ -> FBZ mappings...\" ) call find_irred_wedge ( ph % qmesh , ph % nq_irred , ph % wavevecs_irred , & ph % indexlist_irred , ph % nequiv , sym % nsymm_rot , sym % qrotations , & ph % ibz2fbz_map , ph % equiv_map , blocks ) !Print phonon IBZ mesh call write2file_rank2_real ( \"ph.wavevecs_ibz\" , ph % wavevecs_irred ) !Create symmetrizers of wave vector dependent vectors ShengBTE style allocate ( symmetrizers_chunk ( 3 , 3 , chunk )[ * ]) symmetrizers_chunk = 0.0_dp do iq = start , end kk = 0 do jj = 1 , sym % nsymm if ( ph % equiv_map ( jj , iq ) == iq ) then symmetrizers_chunk (:, :, iq - start + 1 ) = & symmetrizers_chunk (:, :, iq - start + 1 ) + & sym % crotations_orig (:, :, jj ) kk = kk + 1 end if end do if ( kk > 1 ) then symmetrizers_chunk (:, :, iq - start + 1 ) = & symmetrizers_chunk (:, :, iq - start + 1 ) / kk end if end do allocate ( ph % symmetrizers ( 3 , 3 , ph % nq )) sync all do im = 1 , num_active_images ph % symmetrizers (:, :, start [ im ]: end [ im ]) = symmetrizers_chunk (:,:,:)[ im ] end do sync all deallocate ( symmetrizers_chunk ) !Symmetrize phonon energies and velocities. do i = 1 , ph % nq_irred !an irreducible point ii = ph % indexlist_irred ( i ) ph % vels ( ii ,:,:) = transpose (& matmul ( ph % symmetrizers (:,:, ii ), transpose ( ph % vels ( ii ,:,:)))) do l = 1 , ph % nequiv ( i ) !number of equivalent points of i il = ph % ibz2fbz_map ( l , i , 2 ) ! (i, l) -> il s = ph % ibz2fbz_map ( l , i , 1 ) ! mapping rotation !energy ph % ens ( il ,:) = ph % ens ( ii ,:) !velocity do ib = 1 , ph % numbranches !here use real space (Cartesian) rotations ph % vels ( il , ib , :) = matmul ( sym % crotations (:, :, s ), ph % vels ( ii , ib , :)) end do end do end do !Print out irreducible phonon energies and velocities if ( this_image () == 1 ) then write ( numcols , \"(I0)\" ) ph % numbranches open ( 1 , file = \"ph.ens_ibz\" , status = \"replace\" ) do iq = 1 , ph % nq_irred write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & ph % ens ( ph % indexlist_irred ( iq ), :) end do close ( 1 ) write ( numcols , \"(I0)\" ) 3 * ph % numbranches open ( 1 , file = \"ph.vels_ibz\" , status = \"replace\" ) do iq = 1 , ph % nq_irred write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & ph % vels ( ph % indexlist_irred ( iq ), :, :) end do close ( 1 ) end if !Calculate phonon tetrahedra if ( num % tetrahedra ) then call print_message ( \"Calculating phonon mesh tetrahedra...\" ) call form_tetrahedra_3d ( ph % nq , ph % qmesh , ph % tetra , ph % tetracount , & ph % tetramap , . false .) call fill_tetrahedra_3d ( ph % tetra , ph % ens , ph % tetra_evals ) else call print_message ( \"Calculating phonon mesh triangles...\" ) call form_triangles ( ph % nq , ph % qmesh , ph % triang , ph % triangcount , & ph % triangmap , . false .) call fill_triangles ( ph % triang , ph % ens , ph % triang_evals ) end if end subroutine calculate_phonons subroutine read_ifc2 ( ph , crys ) !! Read the 2nd order force constants from the Quantum Espresso format. !! This is adapted from ShengBTE. class ( phonon ), intent ( inout ) :: ph type ( crystal ), intent ( in ) :: crys !Local variables integer ( k8 ) :: qscell ( 3 ), tipo ( crys % numatoms ), t1 , t2 , t3 , i , j , & iat , jat , ibrav , ipol , jpol , m1 , m2 , m3 , ntype , nat , nfc2 real ( dp ) :: r ( crys % numatoms , 3 ), wscell ( 3 , 0 : 3 ), celldm ( 6 ), at ( 3 , 3 ), & mass ( crys % numelements ), zeff ( crys % numatoms , 3 , 3 ), eps ( 3 , 3 ), & dnrm2 character ( len = 1 ) :: polar_key character ( len = 6 ) :: label ( crys % numelements ) real ( dp ), parameter :: massfactor = 1.8218779_dp * 6.022e-4_dp allocate ( ph % mm ( crys % numatoms , crys % numatoms )) allocate ( ph % rr ( crys % numatoms , crys % numatoms , 3 )) open ( 1 , file = \"espresso.ifc2\" , status = \"old\" ) !Read some stuff that will not be used in the code. read ( 1 , * ) ntype , nat , ibrav , celldm ( 1 : 6 ) if ( ibrav == 0 ) then read ( 1 , * ) (( at ( i , j ), i = 1 , 3 ), j = 1 , 3 ) end if do i = 1 , ntype read ( 1 , * ) j , label ( i ), mass ( i ) end do mass = crys % masses / massfactor do i = 1 , nat read ( 1 , * ) j , tipo ( i ), r ( i , 1 : 3 ) end do r = transpose ( matmul ( crys % lattvecs , crys % basis )) / bohr2nm read ( 1 , * ) polar_key if ( polar_key == \"T\" ) then do i = 1 , 3 read ( 1 , * ) eps ( i , 1 : 3 ) end do do i = 1 , nat read ( 1 , * ) do j = 1 , 3 read ( 1 , * ) zeff ( i , j , 1 : 3 ) end do end do end if read ( 1 , * ) qscell ( 1 : 3 ) ph % scell = qscell !Read the force constants. allocate ( ph % ifc2 ( 3 , 3 , nat , nat , ph % scell ( 1 ), ph % scell ( 2 ), ph % scell ( 3 ))) nfc2 = 3 * 3 * nat * nat do i = 1 , nfc2 read ( 1 , * ) ipol , jpol , iat , jat do j = 1 , ph % scell ( 1 ) * ph % scell ( 2 ) * ph % scell ( 3 ) read ( 1 , * ) t1 , t2 , t3 , & ph % ifc2 ( ipol , jpol , iat , jat , t1 , t2 , t3 ) end do end do close ( 1 ) !Enforce the conservation of momentum in the simplest way possible. do i = 1 , 3 do j = 1 , 3 do iat = 1 , nat ph % ifc2 ( i , j , iat , iat , 1 , 1 , 1 ) = ph % ifc2 ( i , j , iat , iat , 1 , 1 , 1 ) - & sum ( ph % ifc2 ( i , j , iat , :, :, :, :)) end do end do end do ph % cell_r (:, 1 : 3 ) = transpose ( crys % lattvecs ) / bohr2nm do i = 1 , 3 ph % cell_r ( i , 0 ) = dnrm2 ( 3 , ph % cell_r ( i , 1 : 3 ), 1 ) end do ph % cell_g (:, 1 : 3 ) = transpose ( crys % reclattvecs ) * bohr2nm do i = 1 , 3 ph % cell_g ( i , 0 ) = dnrm2 ( 3 , ph % cell_g ( i , 1 : 3 ), 1 ) end do wscell ( 1 , 1 : 3 ) = ph % cell_r ( 1 , 1 : 3 ) * ph % scell ( 1 ) wscell ( 2 , 1 : 3 ) = ph % cell_r ( 2 , 1 : 3 ) * ph % scell ( 2 ) wscell ( 3 , 1 : 3 ) = ph % cell_r ( 3 , 1 : 3 ) * ph % scell ( 3 ) j = 1 do m1 = - 2 , 2 do m2 = - 2 , 2 do m3 = - 2 , 2 if ( all (( / m1 , m2 , m3 / ). eq . 0 )) then cycle end if do i = 1 , 3 ph % rws ( j , i ) = wscell ( 1 , i ) * m1 + wscell ( 2 , i ) * m2 + wscell ( 3 , i ) * m3 end do ph % rws ( j , 0 ) = 0.5 * dot_product ( ph % rws ( j , 1 : 3 ), ph % rws ( j , 1 : 3 )) j = j + 1 end do end do end do do i = 1 , nat ph % mm ( i , i ) = mass ( tipo ( i )) ph % rr ( i , i , :) = 0 do j = i + 1 , nat ph % mm ( i , j ) = sqrt ( mass ( tipo ( i )) * mass ( tipo ( j ))) ph % rr ( i , j , 1 : 3 ) = r ( i , 1 : 3 ) - r ( j , 1 : 3 ) ph % mm ( j , i ) = ph % mm ( i , j ) ph % rr ( j , i , 1 : 3 ) = - ph % rr ( i , j , 1 : 3 ) end do end do end subroutine read_ifc2 subroutine read_ifc3 ( ph , crys ) !! Read the 3rd order force constants in the thirdorder.py format. !! This subroutine is adapted from ShengBTE. class ( phonon ), intent ( inout ) :: ph type ( crystal ), intent ( in ) :: crys !Local variables real ( dp ) :: tmp ( 3 , 3 ), r ( crys % numatoms , 3 ), celldm ( 6 ), at ( 3 , 3 ), & mass ( crys % numelements ), zeff ( crys % numatoms , 3 , 3 ), eps ( 3 , 3 ) real ( dp ), allocatable :: fc (:,:,:,:) integer ( k8 ) :: ii , jj , ll , mm , nn , ltem , mtem , ntem , info , P ( 3 ), & na1 , na2 , na3 , j1 , j2 , j3 , na1_ , na2_ , na3_ , j1_ , j2_ , j3_ , & triplet_counter , nR , nR_ , qscell ( 3 ), tipo ( crys % numatoms ), i , j , & ibrav , ntype , nat , jn1 , jn2 , jn3 integer ( k8 ), allocatable :: R2 (:,:), R3 (:,:) character ( len = 1 ) :: polar_key character ( len = 6 ) :: label ( crys % numelements ) logical :: sheng_file_exists , d3q_file_exists , save_nR !Check what force constants files have been provided sheng_file_exists = . False . d3q_file_exists = . False . inquire ( file = 'FORCE_CONSTANTS_3RD' , exist = sheng_file_exists ) inquire ( file = 'mat3R' , exist = d3q_file_exists ) if ( sheng_file_exists . and . . not . d3q_file_exists ) then call print_message ( 'Reading ShengBTE format third order force constants...' ) else if ( d3q_file_exists . and . . not . sheng_file_exists ) then call print_message ( 'Reading d3q format third order force constants...' ) else if ( d3q_file_exists . and . sheng_file_exists ) then call print_message (& 'Both ShengBTE and d3q format third order force constants provided. Defaulting to ShengBTE format.' ) d3q_file_exists = . False . else call exit_with_message ( 'Third order force constant file not provided. Exiting.' ) end if if ( sheng_file_exists ) then !The file is in a simple sparse format, described in detail in !the user documentation. See Doc/ShengBTE.pdf. open ( 1 , file = 'FORCE_CONSTANTS_3RD' , status = \"old\" ) read ( 1 , * ) ph % numtriplets allocate ( ph % Index_i ( ph % numtriplets ), ph % Index_j ( ph % numtriplets ), ph % Index_k ( ph % numtriplets )) allocate ( ph % ifc3 ( 3 , 3 , 3 , ph % numtriplets ), ph % R_j ( 3 , ph % numtriplets ), ph % R_k ( 3 , ph % numtriplets )) do ii = 1 , ph % numtriplets read ( 1 , * ) jj read ( 1 , * ) ph % R_j (:, ii ) !Ang read ( 1 , * ) ph % R_k (:, ii ) !Ang read ( 1 , * ) ph % Index_i ( ii ), ph % Index_j ( ii ), ph % Index_k ( ii ) do ll = 1 , 3 do mm = 1 , 3 do nn = 1 , 3 read ( 1 , * ) ltem , mtem , ntem , ph % ifc3 ( ll , mm , nn , ii ) end do end do end do end do close ( 1 ) !IFC3 units are eV/Ang&#94;3 else !See SUBROUTINE read_fc3_grid of fc3_interp.f90 of the d3q code !for more information about the format. open ( 1 , file = 'mat3R' , status = \"old\" ) !Read some stuff that will not be used in the code. read ( 1 , * ) ntype , nat , ibrav , celldm ( 1 : 6 ) if ( ibrav == 0 ) then read ( 1 , * ) (( at ( i , j ), i = 1 , 3 ), j = 1 , 3 ) end if do i = 1 , ntype read ( 1 , * ) j , label ( i ), mass ( i ) end do do i = 1 , nat read ( 1 , * ) j , tipo ( i ), r ( i , 1 : 3 ) end do read ( 1 , * ) polar_key if ( polar_key == \"T\" ) then do i = 1 , 3 read ( 1 , * ) eps ( i , 1 : 3 ) end do do i = 1 , nat read ( 1 , * ) do j = 1 , 3 read ( 1 , * ) zeff ( i , j , 1 : 3 ) end do end do end if read ( 1 , * ) qscell ( 1 : 3 ) save_nR = . true . do na1 = 1 , crys % numatoms do na2 = 1 , crys % numatoms do na3 = 1 , crys % numatoms do j1 = 1 , 3 jn1 = j1 + ( na1 - 1 ) * 3 do j2 = 1 , 3 jn2 = j2 + ( na2 - 1 ) * 3 do j3 = 1 , 3 jn3 = j3 + ( na3 - 1 ) * 3 !Read tensor elements location and triplet atoms. read ( 1 , * ) j1_ , j2_ , j3_ , na1_ , na2_ , na3_ if ( any (( / na1 , na2 , na3 , j1 , j2 , j3 / ) /= & ( / na1_ , na2_ , na3_ , j1_ , j2_ , j3_ / ))) then call exit_with_message (& \"Wrong Triplet indices and/or tensor element location in mat3R file. Exiting.\" ) end if !Read number of unit cells in file. read ( 1 , * ) nR_ !Save this number only the first time it is read. !Also, allocate the various quantities. if ( save_nR ) then nR = nR_ allocate ( R2 ( 3 , nR ), R3 ( 3 , nR ), & fc ( ph % numbranches , ph % numbranches , ph % numbranches , nR )) save_nR = . false . end if if ( nR_ /= nR ) call exit_with_message (& \"Wrong number of unit cells in mat3R file. Exiting.\" ) do ii = 1 , nR !R2 and R3 are the same for every nR chunk. read ( 1 , * ) R2 (:, ii ), R3 (:, ii ), fc ( jn1 , jn2 , jn3 , ii ) !At this point the fc units are Ry/Bohr&#94;3 end do end do end do end do end do end do end do !Number of triplets ph % numtriplets = nR * crys % numatoms ** 3 !Allocate quantities allocate ( ph % Index_i ( ph % numtriplets ), ph % Index_j ( ph % numtriplets ), ph % Index_k ( ph % numtriplets )) allocate ( ph % ifc3 ( 3 , 3 , 3 , ph % numtriplets ), ph % R_j ( 3 , ph % numtriplets ), ph % R_k ( 3 , ph % numtriplets )) !Convert to the standard format. triplet_counter = 0 do ii = 1 , nR do na1 = 1 , crys % numatoms do na2 = 1 , crys % numatoms do na3 = 1 , crys % numatoms triplet_counter = triplet_counter + 1 !Triplet ph % Index_i ( triplet_counter ) = na1 ph % Index_j ( triplet_counter ) = na2 ph % Index_k ( triplet_counter ) = na3 !Positions of the 2nd and 3rd atom in the triplet !converted to Cartesian coordinates (Ang). ph % R_j (:, triplet_counter ) = & matmul ( crys % lattvecs , R2 (:, ii ) * 1 0.0_dp ) !Ang ph % R_k (:, triplet_counter ) = & matmul ( crys % lattvecs , R3 (:, ii ) * 1 0.0_dp ) !Ang do j1 = 1 , 3 jn1 = j1 + ( na1 - 1 ) * 3 do j2 = 1 , 3 jn2 = j2 + ( na2 - 1 ) * 3 do j3 = 1 , 3 jn3 = j3 + ( na3 - 1 ) * 3 ph % ifc3 ( j1 , j2 , j3 , triplet_counter ) = fc ( jn1 , jn2 , jn3 , ii ) end do end do end do end do end do end do end do ph % ifc3 = ph % ifc3 * Ryd2eV / ( bohr2nm * 1 0.0_dp ) ** 3 !eV/Ang&#94;3 end if !Each vector is rounded to the nearest lattice vector. tmp = crys % lattvecs call dgesv ( 3 , ph % numtriplets , tmp , 3 , P , ph % R_j , 3 , info ) ph % R_j = matmul ( crys % lattvecs , anint ( ph % R_j / 1 0.0_dp )) !nm tmp = crys % lattvecs call dgesv ( 3 , ph % numtriplets , tmp , 3 , P , ph % R_k , 3 , info ) ph % R_k = matmul ( crys % lattvecs , anint ( ph % R_k / 1 0.0_dp )) !nm end subroutine read_ifc3 subroutine phonon_espresso ( ph , crys , nk , kpoints , omegas , eigenvect , velocities ) !! Subroutine to calculate phonons from the 2nd order force constants. ! ! This is adapted from ShengBTE's subroutine of the same name. ! ShengBTE is distributed under GPL v3 or later. type ( phonon ), intent ( in ) :: ph type ( crystal ), intent ( in ) :: crys integer ( k8 ), intent ( in ) :: nk real ( dp ), intent ( in ) :: kpoints ( nk , 3 ) real ( dp ), intent ( out ) :: omegas ( nk , ph % numbranches ) real ( dp ), optional , intent ( out ) :: velocities ( nk , ph % numbranches , 3 ) complex ( kind = 8 ), optional , intent ( out ) :: eigenvect ( nk , ph % numbranches , ph % numbranches ) ! QE's 2nd-order files are in Ryd units. real ( kind = 8 ), parameter :: toTHz = 2067 0.687 ,& massfactor = 1.8218779 * 6.022e-4 integer ( k8 ) :: ir , nreq , ntype , nat , nbranches integer ( k8 ) :: i , j , ipol , jpol , iat , jat , idim , jdim , t1 , t2 , t3 , m1 , m2 , m3 , ik integer ( k8 ) :: ndim , nwork , ncell_g ( 3 ) integer ( k8 ), allocatable :: tipo (:) real ( dp ) :: weight , total_weight , exp_g , ck real ( dp ) :: r_ws ( 3 ) real ( dp ) :: alpha , geg , gmax , kt , gr , volume_r , dnrm2 real ( dp ) :: zig ( 3 ), zjg ( 3 ), dgeg ( 3 ), t ( 0 : 3 ), g ( 0 : 3 ), g_old ( 0 : 3 ) real ( dp ), allocatable :: omega2 (:), rwork (:) real ( dp ), allocatable :: k (:,:), mass (:), eps (:,:) real ( dp ), allocatable :: eival (:,:), vels (:,:,:), zeff (:,:,:) complex ( dp ) :: auxi ( 3 ) complex ( dp ), allocatable :: cauxiliar (:), eigenvectors (:,:), work (:) complex ( dp ), allocatable :: dyn (:,:), dyn_s (:,:,:), dyn_g (:,:,:) complex ( dp ), allocatable :: ddyn (:,:,:), ddyn_s (:,:,:,:), ddyn_g (:,:,:,:) ! Quantum Espresso's 2nd-order format contains information about ! lattice vectors, atomic positions, Born effective charges and so ! forth in its header. The information is read but completely ! ignored. It is the user's responsibility to ensure that ! it is consistent with the CONTROL file. nwork = 1 ntype = crys % numelements nat = crys % numatoms ndim = 3 * nat nbranches = ndim allocate ( omega2 ( nbranches )) allocate ( work ( nwork )) allocate ( rwork ( max ( 1 , 9 * nat - 2 ))) allocate ( k ( nk , 3 )) allocate ( mass ( ntype )) allocate ( tipo ( nat )) allocate ( eps ( 3 , 3 )) allocate ( zeff ( nat , 3 , 3 )) allocate ( dyn ( ndim , ndim )) allocate ( dyn_s ( nk , ndim , ndim )) allocate ( dyn_g ( nk , ndim , ndim )) allocate ( eival ( ndim , nk )) allocate ( eigenvectors ( ndim , ndim )) allocate ( cauxiliar ( ndim )) if ( present ( velocities )) then allocate ( ddyn ( ndim , ndim , 3 )) allocate ( ddyn_s ( nk , ndim , ndim , 3 )) allocate ( ddyn_g ( nk , ndim , ndim , 3 )) allocate ( vels ( ndim , nk , 3 )) end if mass = crys % masses / massfactor tipo = crys % atomtypes eps = transpose ( crys % epsilon ) do i = 1 , nat zeff ( i , :, :) = transpose ( crys % born (:, :, i )) end do ! Make sure operations are performed in consistent units. do ik = 1 , nk k ( ik , :) = matmul ( crys % reclattvecs , kpoints ( ik , :)) end do k = k * bohr2nm volume_r = crys % volume / bohr2nm ** 3 gmax = 1 4. alpha = ( twopi * bohr2nm / dnrm2 ( 3 , crys % lattvecs (:, 1 ), 1 )) ** 2 geg = gmax * 4. * alpha ncell_g = int ( sqrt ( geg ) / ph % cell_g (:, 0 )) + 1 dyn_s = 0.0_dp if ( present ( velocities )) ddyn_s = 0.0_dp do iat = 1 , nat do jat = 1 , nat total_weight = 0.0d0 do m1 =- 2 * ph % scell ( 1 ), 2 * ph % scell ( 1 ) do m2 =- 2 * ph % scell ( 2 ), 2 * ph % scell ( 2 ) do m3 =- 2 * ph % scell ( 3 ), 2 * ph % scell ( 3 ) do i = 1 , 3 t ( i ) = m1 * ph % cell_r ( 1 , i ) + m2 * ph % cell_r ( 2 , i ) + m3 * ph % cell_r ( 3 , i ) r_ws ( i ) = t ( i ) + ph % rr ( iat , jat , i ) end do weight = 0.d0 nreq = 1 j = 0 Do ir = 1 , 124 ck = dot_product ( r_ws , ph % rws ( ir , 1 : 3 )) - ph % rws ( ir , 0 ) if ( ck . gt . 1e-6 ) then j = 1 cycle end if if ( abs ( ck ). lt . 1e-6 ) then nreq = nreq + 1 end if end do if ( j . eq . 0 ) then weight = 1.d0 / dble ( nreq ) end if if ( weight . gt . 0.d0 ) then t1 = mod ( m1 + 1 , ph % scell ( 1 )) if ( t1 . le . 0 ) then t1 = t1 + ph % scell ( 1 ) end if t2 = mod ( m2 + 1 , ph % scell ( 2 )) if ( t2 . Le . 0 ) then t2 = t2 + ph % scell ( 2 ) end if t3 = mod ( m3 + 1 , ph % scell ( 3 )) if ( t3 . le . 0 ) then t3 = t3 + ph % scell ( 3 ) end if do ik = 1 , nk kt = dot_product ( k ( ik , 1 : 3 ), t ( 1 : 3 )) do ipol = 1 , 3 idim = ( iat - 1 ) * 3 + ipol do jpol = 1 , 3 jdim = ( jat - 1 ) * 3 + jpol dyn_s ( ik , idim , jdim ) = dyn_s ( ik , idim , jdim ) + & ph % ifc2 ( ipol , jpol , iat , jat , t1 , t2 , t3 ) * & expi ( - kt ) * weight if ( present ( velocities )) then ddyn_s ( ik , idim , jdim , 1 : 3 ) = ddyn_s ( ik , idim , jdim , 1 : 3 ) - & oneI * t ( 1 : 3 ) * & ph % ifc2 ( ipol , jpol , iat , jat , t1 , t2 , t3 ) * & expi ( - kt ) * weight end if end do end do end do end if total_weight = total_weight + weight end do end do end do end do end do ! The nonanalytic correction has two components in this ! approximation. Results may differ slightly between this method ! and the one implemented in the previous subroutine. dyn_g = 0.0_dp if ( present ( velocities )) ddyn_g = 0.0_dp if ( crys % polar ) then do m1 =- ncell_g ( 1 ), ncell_g ( 1 ) do m2 =- ncell_g ( 2 ), ncell_g ( 2 ) do m3 =- ncell_g ( 3 ), ncell_g ( 3 ) g ( 1 : 3 ) = m1 * ph % cell_g ( 1 , 1 : 3 ) + & m2 * ph % cell_g ( 2 , 1 : 3 ) + m3 * ph % cell_g ( 3 , 1 : 3 ) geg = dot_product ( g ( 1 : 3 ), matmul ( eps , g ( 1 : 3 ))) if ( geg . gt . 0.0d0 . and . geg / alpha / 4.0d0 . lt . gmax ) then exp_g = exp ( - geg / alpha / 4.0d0 ) / geg do iat = 1 , nat zig ( 1 : 3 ) = matmul ( g ( 1 : 3 ), zeff ( iat , 1 : 3 , 1 : 3 )) auxi ( 1 : 3 ) = 0. do jat = 1 , nat gr = dot_product ( g ( 1 : 3 ), ph % rr ( iat , jat , 1 : 3 )) zjg ( 1 : 3 ) = matmul ( g ( 1 : 3 ), zeff ( jat , 1 : 3 , 1 : 3 )) auxi ( 1 : 3 ) = auxi ( 1 : 3 ) + zjg ( 1 : 3 ) * expi ( gr ) end do do ipol = 1 , 3 idim = ( iat - 1 ) * 3 + ipol do jpol = 1 , 3 jdim = ( iat - 1 ) * 3 + jpol dyn_g ( 1 : nk , idim , jdim ) = dyn_g ( 1 : nk , idim , jdim ) - & exp_g * zig ( ipol ) * auxi ( jpol ) end do end do end do end if g_old ( 0 : 3 ) = g ( 0 : 3 ) do ik = 1 , nk g ( 1 : 3 ) = g_old ( 1 : 3 ) + k ( ik , 1 : 3 ) geg = dot_product ( g ( 1 : 3 ), matmul ( eps , g ( 1 : 3 ))) if ( geg . gt . 0.0d0 . and . geg / alpha / 4.0d0 . lt . gmax ) then exp_g = exp ( - geg / alpha / 4.0d0 ) / geg dgeg = matmul ( eps + transpose ( eps ), g ( 1 : 3 )) do iat = 1 , nat zig ( 1 : 3 ) = matmul ( g ( 1 : 3 ), zeff ( iat , 1 : 3 , 1 : 3 )) do jat = 1 , nat gr = dot_product ( g ( 1 : 3 ), ph % rr ( iat , jat , 1 : 3 )) zjg ( 1 : 3 ) = matmul ( g ( 1 : 3 ), zeff ( jat , 1 : 3 , 1 : 3 )) do ipol = 1 , 3 idim = ( iat - 1 ) * 3 + ipol do jpol = 1 , 3 jdim = ( jat - 1 ) * 3 + jpol dyn_g ( ik , idim , jdim ) = dyn_g ( ik , idim , jdim ) + & exp_g * zig ( ipol ) * zjg ( jpol ) * expi ( gr ) if ( present ( velocities )) then do i = 1 , 3 ddyn_g ( ik , idim , jdim , i ) = ddyn_g ( ik , idim , jdim , i ) + & exp_g * expi ( gr ) * & ( zjg ( jpol ) * zeff ( iat , i , ipol ) + zig ( ipol ) * zeff ( jat , i , jpol ) + & zig ( ipol ) * zjg ( jpol ) * oneI * ph % rr ( iat , jat , i ) - & zig ( ipol ) * zjg ( jpol ) * ( dgeg ( i ) / alpha / 4.0 + dgeg ( i ) / geg )) end do end if end do end do end do end do end if end do end do end do end do dyn_g = dyn_g * 8.0_dp * pi / volume_r if ( present ( velocities )) ddyn_g = ddyn_g * 8.0_dp * pi / volume_r end if ! Once the dynamical matrix has been built, the frequencies and ! group velocities are extracted exactly like in the previous ! subroutine. do ik = 1 , nk dyn (:,:) = dyn_s ( ik ,:,:) + dyn_g ( ik ,:,:) if ( present ( velocities )) then ddyn (:,:,:) = ddyn_s ( ik ,:,:,:) + ddyn_g ( ik ,:,:,:) end if do ipol = 1 , 3 do jpol = 1 , 3 do iat = 1 , nat do jat = 1 , nat idim = ( iat - 1 ) * 3 + ipol jdim = ( jat - 1 ) * 3 + jpol dyn ( idim , jdim ) = dyn ( idim , jdim ) / ph % mm ( iat , jat ) if ( present ( velocities )) then ddyn ( idim , jdim , 1 : 3 ) = ddyn ( idim , jdim , 1 : 3 ) / ph % mm ( iat , jat ) end if end do end do end do end do call zheev ( \"V\" , \"U\" , nbranches , dyn (:,:), nbranches , omega2 , work , - 1_k8 , rwork , i ) if ( real ( work ( 1 )). gt . nwork ) then nwork = nint ( 2 * real ( work ( 1 ))) deallocate ( work ) allocate ( work ( nwork )) end if call zheev ( \"V\" , \"U\" , nbranches , dyn (:,:), nbranches , omega2 , work , nwork , rwork , i ) if ( present ( eigenvect )) then eigenvect ( ik ,:,:) = transpose ( dyn (:,:)) end if omegas ( ik ,:) = sign ( sqrt ( abs ( omega2 )), omega2 ) if ( present ( velocities )) then do i = 1 , nbranches do j = 1 , 3 velocities ( ik , i , j ) = real ( dot_product ( dyn (:, i ),& matmul ( ddyn (:,:, j ), dyn (:, i )))) end do velocities ( ik , i ,:) = velocities ( ik , i ,:) / ( 2. * omegas ( ik , i )) end do end if !Take care of gamma point. if ( all ( k ( ik , 1 : 3 ) == 0 )) then omegas ( ik , 1 : 3 ) = 0.0_dp if ( present ( velocities )) velocities ( ik , :, :) = 0.0_dp end if end do !Units conversion omegas = omegas * Ryd2eV !eV if ( present ( velocities )) velocities = velocities * toTHz * bohr2nm !Km/s end subroutine phonon_espresso end module phonon_module","tags":"","loc":"sourcefile/phonon.f90.html"},{"title":"bz_sums.f90 – elphbolt","text":"This file depends on sourcefile~~bz_sums.f90~~EfferentGraph sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~misc.f90 misc.f90 sourcefile~bz_sums.f90->sourcefile~misc.f90 sourcefile~electron.f90 electron.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 sourcefile~crystal.f90 crystal.f90 sourcefile~bz_sums.f90->sourcefile~crystal.f90 sourcefile~params.f90 params.f90 sourcefile~bz_sums.f90->sourcefile~params.f90 sourcefile~symmetry.f90 symmetry.f90 sourcefile~bz_sums.f90->sourcefile~symmetry.f90 sourcefile~delta.f90 delta.f90 sourcefile~bz_sums.f90->sourcefile~delta.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 sourcefile~misc.f90->sourcefile~params.f90 sourcefile~electron.f90->sourcefile~misc.f90 sourcefile~electron.f90->sourcefile~crystal.f90 sourcefile~electron.f90->sourcefile~params.f90 sourcefile~electron.f90->sourcefile~symmetry.f90 sourcefile~electron.f90->sourcefile~delta.f90 sourcefile~wannier.f90 wannier.f90 sourcefile~electron.f90->sourcefile~wannier.f90 sourcefile~numerics.f90 numerics.f90 sourcefile~electron.f90->sourcefile~numerics.f90 sourcefile~crystal.f90->sourcefile~misc.f90 sourcefile~crystal.f90->sourcefile~params.f90 sourcefile~symmetry.f90->sourcefile~misc.f90 sourcefile~symmetry.f90->sourcefile~crystal.f90 sourcefile~symmetry.f90->sourcefile~params.f90 sourcefile~spglib_wrapper.f90 spglib_wrapper.f90 sourcefile~symmetry.f90->sourcefile~spglib_wrapper.f90 sourcefile~delta.f90->sourcefile~misc.f90 sourcefile~delta.f90->sourcefile~params.f90 sourcefile~phonon.f90->sourcefile~misc.f90 sourcefile~phonon.f90->sourcefile~crystal.f90 sourcefile~phonon.f90->sourcefile~params.f90 sourcefile~phonon.f90->sourcefile~symmetry.f90 sourcefile~phonon.f90->sourcefile~delta.f90 sourcefile~phonon.f90->sourcefile~wannier.f90 sourcefile~phonon.f90->sourcefile~numerics.f90 sourcefile~wannier.f90->sourcefile~misc.f90 sourcefile~wannier.f90->sourcefile~crystal.f90 sourcefile~wannier.f90->sourcefile~params.f90 sourcefile~wannier.f90->sourcefile~numerics.f90 sourcefile~numerics.f90->sourcefile~misc.f90 sourcefile~numerics.f90->sourcefile~crystal.f90 sourcefile~numerics.f90->sourcefile~params.f90 sourcefile~spglib_wrapper.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~bz_sums.f90~~AfferentGraph sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~bte.f90 bte.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules bz_sums Source Code bz_sums.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module bz_sums !! Module containing the procedures to do Brillouin zone sums. use params , only : dp , k8 , kB , qe , pi , hbar_eVps , perm0 use misc , only : exit_with_message , print_message , write2file_rank2_real , & distribute_points , Bose , Fermi use phonon_module , only : phonon use electron_module , only : electron use crystal_module , only : crystal use delta , only : delta_fn_tetra , delta_fn_triang use symmetry_module , only : symmetry , symmetrize_3x3_tensor implicit none public calculate_dos , calculate_transport_coeff , calculate_qTF private calculate_el_dos , calculate_ph_dos_iso interface calculate_dos module procedure :: calculate_el_dos , calculate_ph_dos_iso end interface calculate_dos contains subroutine calculate_qTF ( crys , el ) !! Calculate Thomas-Fermi screening wavevector in the simple electron-gas model. ! ! qTF**2 = spindeg*e&#94;2*beta/nptq/vol_pcell/perm0/epsilon0*Sum_{BZ}f0_{k}(1-f0_{k}) type ( crystal ), intent ( inout ) :: crys type ( electron ), intent ( in ) :: el !Local variables real ( dp ) :: beta , fFD integer ( k8 ) :: ib , ik beta = 1.0_dp / kB / crys % T / qe !1/J crys % qTF = 0.d0 if ( crys % epsilon0 /= 0 ) then call print_message ( \"Calculating Thomas-Fermi screening...\" ) do ib = 1 , el % numbands do ik = 1 , el % nk fFD = Fermi ( el % ens ( ik , ib ), el % chempot , crys % T ) crys % qTF = crys % qTF + fFD * ( 1.0_dp - fFD ) end do end do crys % qTF = sqrt ( 1.0e9_dp * crys % qTF * el % spindeg * beta * qe ** 2 / product ( el % kmesh )& / crys % volume / perm0 / crys % epsilon0 ) !nm&#94;-1 if ( this_image () == 1 ) then write ( * , \"(A, 1E16.8, A)\" ) ' Thomas-Fermi screening wave length = ' , crys % qTF , ' 1/nm' end if end if end subroutine calculate_qTF subroutine calculate_el_dos ( el , usetetra ) !! Calculate the density of states (DOS) in units of 1/energy. !! The DOS will be evaluates on the IBZ mesh energies. !! !! el Electron data type !! usetetra Use the tetrahedron method for delta functions? type ( electron ), intent ( inout ) :: el logical , intent ( in ) :: usetetra !Local variables integer ( k8 ) :: ik , ib , ikp , ibp , im , chunk , counter , num_active_images integer ( k8 ), allocatable :: start [:], end [:] real ( dp ) :: e , delta real ( dp ), allocatable :: dos_chunk (:,:)[:] call print_message ( \"Calculating electron density of states...\" ) !Allocate start and end coarrays allocate ( start [ * ], end [ * ]) !Divide wave vectors among images call distribute_points ( el % nk_irred , chunk , start , end , num_active_images ) !Allocate small work variable chunk for each image allocate ( dos_chunk ( chunk , el % numbands )[ * ]) !Allocate dos allocate ( el % dos ( el % nk_irred , el % numbands )) !Initialize dos arrays el % dos (:,:) = 0.0_dp dos_chunk (:,:) = 0.0_dp counter = 0 do ik = start , end !Run over IBZ wave vectors !Increase counter counter = counter + 1 do ib = 1 , el % numbands !Run over wave vectors !Grab sample energy from the IBZ e = el % ens_irred ( ik , ib ) do ikp = 1 , el % nk !Sum over FBZ wave vectors do ibp = 1 , el % numbands !Sum over wave vectors if ( usetetra ) then !Evaluate delta[E(iq,ib) - E(iq',ib')] delta = delta_fn_tetra ( e , ikp , ibp , el % kmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( e , ikp , ibp , el % kmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if !Sum over delta function dos_chunk ( counter , ib ) = dos_chunk ( counter , ib ) + delta end do end do end do end do !Multiply with spin degeneracy factor dos_chunk (:,:) = el % spindeg * dos_chunk (:,:) sync all !Collect dos_chunks into dos do im = 1 , num_active_images el % dos ( start [ im ]: end [ im ], :) = dos_chunk (:,:)[ im ] end do sync all !Write dos to file call write2file_rank2_real ( el % prefix // '.dos' , el % dos ) sync all end subroutine calculate_el_dos subroutine calculate_ph_dos_iso ( ph , usetetra , gfactors , subs_gfactors , & atomtypes , W_phiso , W_phsubs , phiso , phsubs ) !! Calculate the phonon density of states (DOS) in units of 1/energy and, !! optionally, the phonon-isotope scattering rates. !! !! The DOS and isotope scattering rates will be evaluates on the IBZ mesh energies. !! !! ph Phonon data type !! usetetra Use the tetrahedron method for delta functions? type ( phonon ), intent ( inout ) :: ph logical , intent ( in ) :: usetetra , phiso , phsubs real ( dp ), intent ( in ) :: gfactors (:), subs_gfactors (:) integer ( k8 ), intent ( in ) :: atomtypes (:) real ( dp ), intent ( out ), allocatable :: W_phiso (:,:), W_phsubs (:,:) !Local variables integer ( k8 ) :: iq , ib , iqp , ibp , im , chunk , counter , num_active_images , & pol , a , numatoms integer ( k8 ), allocatable :: start [:], end [:] real ( dp ) :: e , delta , aux real ( dp ), allocatable :: dos_chunk (:,:)[:], W_phiso_chunk (:,:)[:], & W_phsubs_chunk (:,:)[:] call print_message ( \"Calculating phonon density of states and (if needed) isotope/substitution scattering...\" ) !Number of basis atoms numatoms = size ( atomtypes ) !Allocate start and end coarrays allocate ( start [ * ], end [ * ]) !Divide wave vectors among images call distribute_points ( ph % nq_irred , chunk , start , end , num_active_images ) !Allocate small work variable chunk for each image allocate ( dos_chunk ( chunk , ph % numbranches )[ * ]) if ( phiso ) allocate ( W_phiso_chunk ( chunk , ph % numbranches )[ * ]) if ( phsubs ) allocate ( W_phsubs_chunk ( chunk , ph % numbranches )[ * ]) !Allocate dos and W_phiso allocate ( ph % dos ( ph % nq_irred , ph % numbranches )) allocate ( W_phiso ( ph % nq_irred , ph % numbranches )) allocate ( W_phsubs ( ph % nq_irred , ph % numbranches )) !Initialize arrays and coarrays ph % dos (:,:) = 0.0_dp dos_chunk (:,:) = 0.0_dp W_phiso (:,:) = 0.0_dp W_phsubs (:,:) = 0.0_dp if ( phiso ) W_phiso_chunk (:,:) = 0.0_dp if ( phsubs ) W_phsubs_chunk (:,:) = 0.0_dp counter = 0 do iq = start , end !Run over IBZ wave vectors !Increase counter counter = counter + 1 do ib = 1 , ph % numbranches !Run over wave vectors !Grab sample energy from the IBZ e = ph % ens ( ph % indexlist_irred ( iq ), ib ) do iqp = 1 , ph % nq !Sum over FBZ wave vectors do ibp = 1 , ph % numbranches !Sum over wave vectors !Evaluate delta[E(iq,ib) - E(iq',ib')] if ( usetetra ) then delta = delta_fn_tetra ( e , iqp , ibp , ph % qmesh , ph % tetramap , & ph % tetracount , ph % tetra_evals ) else delta = delta_fn_triang ( e , iqp , ibp , ph % qmesh , ph % triangmap , & ph % triangcount , ph % triang_evals ) end if !Sum over delta function dos_chunk ( counter , ib ) = dos_chunk ( counter , ib ) + delta if ( phiso . or . phsubs ) then do a = 1 , numatoms pol = ( a - 1 ) * 3 aux = ( abs ( dot_product (& ph % evecs ( ph % indexlist_irred ( iq ), ib , pol + 1 : pol + 3 ), & ph % evecs ( iqp , ibp , pol + 1 : pol + 3 )))) ** 2 !Calculate phonon-isotope scattering in the Tamura model if ( phiso ) then W_phiso_chunk ( counter , ib ) = W_phiso_chunk ( counter , ib ) + & delta * aux * gfactors ( atomtypes ( a )) * e ** 2 end if !Calculate phonon-substitution scattering in the Tamura model if ( phsubs ) then W_phsubs_chunk ( counter , ib ) = W_phsubs_chunk ( counter , ib ) + & delta * aux * subs_gfactors ( atomtypes ( a )) * e ** 2 end if end do end if end do end do end do end do if ( phiso ) W_phiso_chunk = W_phiso_chunk * 0.5_dp * pi / hbar_eVps !THz if ( phsubs ) W_phsubs_chunk = W_phsubs_chunk * 0.5_dp * pi / hbar_eVps !THz sync all !Collect chunks into full array do im = 1 , num_active_images ph % dos ( start [ im ]: end [ im ], :) = dos_chunk (:,:)[ im ] if ( phiso ) W_phiso ( start [ im ]: end [ im ], :) = W_phiso_chunk (:,:)[ im ] if ( phsubs ) W_phsubs ( start [ im ]: end [ im ], :) = W_phsubs_chunk (:,:)[ im ] end do sync all !Write to file call write2file_rank2_real ( ph % prefix // '.dos' , ph % dos ) call write2file_rank2_real ( ph % prefix // '.W_rta_phiso' , W_phiso ) call write2file_rank2_real ( ph % prefix // '.W_rta_phsubs' , W_phsubs ) sync all end subroutine calculate_ph_dos_iso subroutine calculate_transport_coeff ( species_prefix , field , T , deg , chempot , ens , vels , & volume , mesh , response , sym , trans_coeff_hc , trans_coeff_cc ) !! Subroutine to calculate transport coefficients. !! !! species_prefix Prefix of particle type !! field Type of field !! T Temperature in K !! deg Degeneracy !! chempot Chemical potential in eV !! ens FBZ energies in eV !! vels FBZ velocities in Km/s !! volume Primitive cell volume in nm&#94;3 !! mesh Wave vector grid !! response FBZ response function !! sym Symmery object !! trans_coeff_hc Heat current coefficient !! trans_coeff_cc Charge current coefficient character ( len = 2 ), intent ( in ) :: species_prefix character ( len = 1 ), intent ( in ) :: field integer ( k8 ), intent ( in ) :: mesh ( 3 ), deg real ( dp ), intent ( in ) :: T , chempot , ens (:,:), vels (:,:,:), volume , response (:,:,:) type ( symmetry ), intent ( in ) :: sym real ( dp ), intent ( out ) :: trans_coeff_hc (:,:,:), trans_coeff_cc (:,:,:) ! Above, h(c)c = heat(charge) current !Local variables integer ( k8 ) :: ik , ib , icart , nk , nbands , pow_hc , pow_cc real ( dp ) :: dist_factor , e , v , fac , A_hc , A_cc nk = size ( ens (:, 1 )) nbands = size ( ens ( 1 ,:)) !Common multiplicative factor fac = 1.0e21 / kB / T / volume / product ( mesh ) !Do checks related to particle and field type if ( species_prefix == 'ph' ) then if ( chempot /= 0.0_dp ) then call exit_with_message (& \"Phonon chemical potential non-zero in calculate_transport_coefficient. Exiting.\" ) end if if ( field == 'T' ) then A_hc = qe * fac pow_hc = 1 A_cc = 0.0_dp pow_cc = 0 else if ( field == 'E' ) then A_hc = - fac pow_hc = 1 A_cc = 0.0_dp pow_cc = 0 else call exit_with_message ( \"Unknown field type in calculate_transport_coefficient. Exiting.\" ) end if else if ( species_prefix == 'el' ) then if ( field == 'T' ) then A_cc = - deg * qe * fac pow_cc = 0 A_hc = deg * qe * fac pow_hc = 1 else if ( field == 'E' ) then A_cc = deg * fac pow_cc = 0 A_hc = - A_cc pow_hc = 1 else call exit_with_message ( \"Unknown field type in calculate_transport_coefficient. Exiting.\" ) end if else call exit_with_message ( \"Unknown particle species in calculate_transport_coefficient. Exiting.\" ) end if trans_coeff_hc = 0.0_dp trans_coeff_cc = 0.0_dp do ik = 1 , nk do ib = 1 , nbands e = ens ( ik , ib ) if ( species_prefix == 'ph' ) then if ( e == 0.0_dp ) cycle !Ignore zero energies phonons dist_factor = Bose ( e , T ) dist_factor = dist_factor * ( 1.0_dp + dist_factor ) else dist_factor = Fermi ( e , chempot , T ) dist_factor = dist_factor * ( 1.0_dp - dist_factor ) end if do icart = 1 , 3 v = vels ( ik , ib , icart ) trans_coeff_hc ( ib , icart , :) = trans_coeff_hc ( ib , icart , :) + & ( e - chempot ) ** pow_hc * dist_factor * v * response ( ik , ib , :) if ( A_cc /= 0.0_dp ) then trans_coeff_cc ( ib , icart , :) = trans_coeff_cc ( ib , icart , :) + & ( e - chempot ) ** pow_cc * dist_factor * v * response ( ik , ib , :) end if end do end do end do !Units: ! W/m/K for thermal conductivity ! 1/Omega/m for charge conductivity ! V/K for thermopower ! A/m/K for alpha/T trans_coeff_hc = A_hc * trans_coeff_hc if ( A_cc /= 0.0_dp ) trans_coeff_cc = A_cc * trans_coeff_cc !Symmetrize transport tensor do ib = 1 , nbands call symmetrize_3x3_tensor ( trans_coeff_hc ( ib , :, :), sym % crotations ) if ( A_cc /= 0.0_dp ) call symmetrize_3x3_tensor ( trans_coeff_cc ( ib , :, :), sym % crotations ) end do end subroutine calculate_transport_coeff subroutine calculate_spectral_transport_coeff ( species , field , T , deg , chempot , & ens , vels , volume , response , en_grid , usetetra , sym , trans_coeff_hc , trans_coeff_cc ) !! Subroutine to calculate the spectral transport coefficients. !! !! species Object of species type !! field Type of field !! T Temperature in K !! deg Degeneracy !! chempot Chemical potential in eV !! ens FBZ energies in eV !! vels FBZ velocities in Km/s !! volume Primitive cell volume in nm&#94;3 !! usetetra Use tetrahedron method? !! sym Symmery object !! trans_coeff_hc Heat current coefficient !! trans_coeff_cc Charge current coefficient class ( * ), intent ( in ) :: species character ( len = 1 ), intent ( in ) :: field integer ( k8 ), intent ( in ) :: deg real ( dp ), intent ( in ) :: T , chempot , ens (:,:), vels (:,:,:), volume , & response (:,:,:), en_grid (:) logical , intent ( in ) :: usetetra type ( symmetry ), intent ( in ) :: sym real ( dp ), intent ( out ) :: trans_coeff_hc (:,:,:,:), trans_coeff_cc (:,:,:,:) !Local variables character ( len = 2 ) :: species_prefix ! Above, h(c)c = heat(charge) current integer ( k8 ) :: ik , ib , ie , icart , nk , nbands , ne , pow_hc , pow_cc real ( dp ) :: dist_factor , e , v , fac , A_hc , A_cc , delta nk = size ( ens (:, 1 )) !Number of (transport active) wave vectors nbands = size ( ens ( 1 ,:)) !Number of bands/branches ne = size ( en_grid (:)) !Number of sampling energy mesh points !Common multiplicative factor fac = 1.0e21 / kB / T / volume !Grab species prefix select type ( species ) class is ( phonon ) species_prefix = species % prefix class is ( electron ) species_prefix = species % prefix class default species_prefix = 'xx' !Unknown species end select !Do checks related to particle and field type if ( species_prefix == 'ph' ) then if ( chempot /= 0.0_dp ) then call exit_with_message (& \"Phonon chemical potential non-zero in calculate_transport_coefficient. Exiting.\" ) end if if ( field == 'T' ) then A_hc = qe * fac pow_hc = 1 A_cc = 0.0_dp pow_cc = 0 else if ( field == 'E' ) then A_hc = - fac pow_hc = 1 A_cc = 0.0_dp pow_cc = 0 else call exit_with_message ( \"Unknown field type in calculate_transport_coefficient. Exiting.\" ) end if else if ( species_prefix == 'el' ) then if ( field == 'T' ) then A_cc = - deg * qe * fac pow_cc = 0 A_hc = deg * qe * fac pow_hc = 1 else if ( field == 'E' ) then A_cc = deg * fac pow_cc = 0 A_hc = - A_cc pow_hc = 1 else call exit_with_message (& \"Unknown field type in calculate_spectral_transport_coefficient. Exiting.\" ) end if else call exit_with_message (& \"Unknown particle species in calculate_spectral_transport_coefficient. Exiting.\" ) end if !Initialize transport coefficients trans_coeff_hc = 0.0_dp trans_coeff_cc = 0.0_dp do ik = 1 , nk !Sum over wave vectors do ib = 1 , nbands !Sum over bands/branches e = ens ( ik , ib ) !Grab energy !Calculate distribution function factor if ( species_prefix == 'ph' ) then if ( e == 0.0_dp ) cycle !Ignore zero energies phonons dist_factor = Bose ( e , T ) dist_factor = dist_factor * ( 1.0_dp + dist_factor ) else dist_factor = Fermi ( e , chempot , T ) dist_factor = dist_factor * ( 1.0_dp - dist_factor ) end if !Run over sampling energies do ie = 1 , ne !Evaluate delta function if ( usetetra ) then select type ( species ) class is ( phonon ) delta = delta_fn_tetra ( en_grid ( ie ), ik , ib , species % qmesh , species % tetramap , & species % tetracount , species % tetra_evals ) class is ( electron ) delta = delta_fn_tetra ( en_grid ( ie ), ik , ib , species % kmesh , species % tetramap , & species % tetracount , species % tetra_evals ) end select else select type ( species ) class is ( phonon ) delta = delta_fn_triang ( en_grid ( ie ), ik , ib , species % qmesh , species % triangmap , & species % triangcount , species % triang_evals ) class is ( electron ) delta = delta_fn_triang ( en_grid ( ie ), ik , ib , species % kmesh , species % triangmap , & species % triangcount , species % triang_evals ) end select end if do icart = 1 , 3 !Run over Cartesian directions v = vels ( ik , ib , icart ) !Grab velocity trans_coeff_hc ( ib , icart , :, ie ) = trans_coeff_hc ( ib , icart , :, ie ) + & ( en_grid ( ie ) - chempot ) ** pow_hc * dist_factor * v * response ( ik , ib , :) * delta if ( A_cc /= 0.0_dp ) then trans_coeff_cc ( ib , icart , :, ie ) = trans_coeff_cc ( ib , icart , :, ie ) + & ( en_grid ( ie ) - chempot ) ** pow_cc * dist_factor * v * response ( ik , ib , :) * delta end if end do end do !ie end do !ib end do !ik !Units: ! W/m/K/eV for thermal conductivity ! 1/Omega/m/eV for charge conductivity ! V/K/eV for thermopower ! A/m/K/eV for alpha/T trans_coeff_hc = A_hc * trans_coeff_hc if ( A_cc /= 0.0_dp ) trans_coeff_cc = A_cc * trans_coeff_cc !Symmetrize transport tensor do ie = 1 , ne do ib = 1 , nbands call symmetrize_3x3_tensor ( trans_coeff_hc ( ib , :, :, ie ), sym % crotations ) if ( A_cc /= 0.0_dp ) call symmetrize_3x3_tensor ( trans_coeff_cc ( ib , :, :, ie ), sym % crotations ) end do end do end subroutine calculate_spectral_transport_coeff end module bz_sums","tags":"","loc":"sourcefile/bz_sums.f90.html"},{"title":"wannier.f90 – elphbolt","text":"This file depends on sourcefile~~wannier.f90~~EfferentGraph sourcefile~wannier.f90 wannier.f90 sourcefile~params.f90 params.f90 sourcefile~wannier.f90->sourcefile~params.f90 sourcefile~misc.f90 misc.f90 sourcefile~wannier.f90->sourcefile~misc.f90 sourcefile~crystal.f90 crystal.f90 sourcefile~wannier.f90->sourcefile~crystal.f90 sourcefile~numerics.f90 numerics.f90 sourcefile~wannier.f90->sourcefile~numerics.f90 sourcefile~misc.f90->sourcefile~params.f90 sourcefile~crystal.f90->sourcefile~params.f90 sourcefile~crystal.f90->sourcefile~misc.f90 sourcefile~numerics.f90->sourcefile~params.f90 sourcefile~numerics.f90->sourcefile~misc.f90 sourcefile~numerics.f90->sourcefile~crystal.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~wannier.f90~~AfferentGraph sourcefile~wannier.f90 wannier.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~phonon.f90->sourcefile~wannier.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~interactions.f90->sourcefile~wannier.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 sourcefile~electron.f90 electron.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~wannier.f90 sourcefile~elphbolt.f90->sourcefile~phonon.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90->sourcefile~electron.f90 sourcefile~bte.f90 bte.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~electron.f90->sourcefile~wannier.f90 sourcefile~bte.f90->sourcefile~phonon.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~bte.f90->sourcefile~electron.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules wannier_module Source Code wannier.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module wannier_module !! Module containing type and procedures related to Wannierization. use params , only : dp , k8 , Ryd2eV , Ryd2radTHz , oneI , pi , twopi , twopiI , & Ryd2amu , bohr2nm use misc , only : exit_with_message , print_message , expi , twonorm , & distribute_points , demux_state , mux_vector , subtitle use numerics_module , only : numerics use crystal_module , only : crystal implicit none private public epw_wannier !EPW File names character ( len =* ), parameter :: filename_epwdata = \"epwdata.fmt\" character ( len =* ), parameter :: filename_epwgwann = \"epmatwp1\" character ( len =* ), parameter :: filename_elwscells = \"rcells_k\" character ( len =* ), parameter :: filename_phwscells = \"rcells_q\" character ( len =* ), parameter :: filename_gwscells = \"rcells_g\" character ( len =* ), parameter :: filename_elwsdeg = \"wsdeg_k\" character ( len =* ), parameter :: filename_phwsdeg = \"wsdeg_q\" character ( len =* ), parameter :: filename_gwsdeg = \"wsdeg_g\" !Unit conversion constant real ( dp ), parameter :: g2unitfactor = Ryd2eV ** 3 * Ryd2amu type epw_wannier !! Data and procedures related to Wannierization. integer ( k8 ) :: numwannbands !! Number of Wannier bands. integer ( k8 ) :: numbranches !! Number of phonon branches. integer ( k8 ) :: nwsk !! Number of real space cells for electrons. integer ( k8 ) :: coarse_qmesh ( 3 ) !! Coarse phonon wave vector mesh in Wannier calculation. integer ( k8 ) :: nwsq !! Number of real space cells for phonons. integer ( k8 ) :: nwsg !! Number of real space cells for electron-phonon vertex. integer ( k8 ), allocatable :: rcells_k (:, :) !! Real space cell locations for electrons. integer ( k8 ), allocatable :: rcells_q (:, :) !! Real space cell locations for phonons. integer ( k8 ), allocatable :: rcells_g (:, :) !! Real space cell locations for electron-phonon vertex. integer ( k8 ), allocatable :: elwsdeg (:) !! Real space cell multiplicity for electrons. integer ( k8 ), allocatable :: phwsdeg (:) !! Real space cell multiplicity for phonons. integer ( k8 ), allocatable :: gwsdeg (:) !! Real space cell multiplicity for electron-phonon vertex. complex ( dp ), allocatable :: Hwann (:, :, :) !! Hamiltonian in Wannier representation. complex ( dp ), allocatable :: Dphwann (:, :, :) !! Dynamical matrix in Wannier representation. complex ( dp ), allocatable :: gwann (:, :, :, :, :) !! e-ph vertex in Wannier representation. contains procedure :: read => read_EPW_Wannier , el_wann_epw , ph_wann_epw , & gkRp_epw , gReq_epw , g2_epw , deallocate_wannier , plot_along_path end type epw_wannier contains subroutine read_EPW_Wannier ( wann , num ) !! Read Wannier representation of the hamiltonian, dynamical matrix, and the !! e-ph matrix elements from file epwdata.fmt. class ( epw_wannier ), intent ( out ) :: wann type ( numerics ), intent ( in ) :: num !Local variables integer ( k8 ) :: iuc , ib , jb integer ( k8 ) :: coarse_qmesh ( 3 ) real ( dp ) :: ef real ( dp ), allocatable :: dummy (:) namelist / wannier / coarse_qmesh call subtitle ( \"Reading EPW Wannier information...\" ) !Open input file open ( 1 , file = 'input.nml' , status = 'old' ) coarse_qmesh = ( / 0 , 0 , 0 / ) read ( 1 , nml = wannier ) if ( any ( coarse_qmesh <= 0 )) then call exit_with_message ( 'Bad input(s) in wannier.' ) end if wann % coarse_qmesh = coarse_qmesh !Close input file close ( 1 ) open ( 1 , file = filename_epwdata , status = 'old' ) read ( 1 , * ) ef !Fermi energy. Read but ignored here. read ( 1 , * ) wann % numwannbands , wann % nwsk , wann % numbranches , wann % nwsq , wann % nwsg allocate ( dummy (( wann % numbranches / 3 + 1 ) * 9 )) !numatoms*9 Born, 9 epsilon elements. read ( 1 , * ) dummy !Born, epsilon. Read but ignored here. !Read real space hamiltonian call print_message ( \"Reading Wannier rep. Hamiltonian...\" ) allocate ( wann % Hwann ( wann % nwsk , wann % numwannbands , wann % numwannbands )) do ib = 1 , wann % numwannbands do jb = 1 , wann % numwannbands do iuc = 1 , wann % nwsk !Number of real space electron cells read ( 1 , * ) wann % Hwann ( iuc , ib , jb ) end do end do end do !Read real space dynamical matrix call print_message ( \"Reading Wannier rep. dynamical matrix...\" ) allocate ( wann % Dphwann ( wann % nwsq , wann % numbranches , wann % numbranches )) do ib = 1 , wann % numbranches do jb = 1 , wann % numbranches do iuc = 1 , wann % nwsq !Number of real space phonon cells read ( 1 , * ) wann % Dphwann ( iuc , ib , jb ) end do end do end do close ( 1 ) if (. not . num % read_gk2 . or . . not . num % read_gq2 . or . & num % plot_along_path ) then !Read real space matrix elements call print_message ( \"Reading Wannier rep. e-ph vertex...\" ) open ( 1 , file = filename_epwgwann , status = 'old' , access = 'stream' ) allocate ( wann % gwann ( wann % numwannbands , wann % numwannbands , wann % nwsk ,& wann % numbranches , wann % nwsg )) wann % gwann = 0.0_dp read ( 1 ) wann % gwann end if close ( 1 ) !Read cell maps of q, k, g meshes. call print_message ( \"Reading Wannier cells and multiplicities...\" ) allocate ( wann % rcells_k ( wann % nwsk , 3 )) allocate ( wann % elwsdeg ( wann % nwsk )) open ( 1 , file = filename_elwscells , status = \"old\" ) open ( 2 , file = filename_elwsdeg , status = \"old\" ) do iuc = 1 , wann % nwsk read ( 1 , * ) wann % rcells_k ( iuc , :) read ( 2 , * ) wann % elwsdeg ( iuc ) end do close ( 1 ) close ( 2 ) allocate ( wann % rcells_q ( wann % nwsq , 3 )) allocate ( wann % phwsdeg ( wann % nwsq )) open ( 1 , file = filename_phwscells , status = \"old\" ) open ( 2 , file = filename_phwsdeg , status = \"old\" ) do iuc = 1 , wann % nwsq read ( 1 , * ) wann % rcells_q ( iuc , :) read ( 2 , * ) wann % phwsdeg ( iuc ) end do close ( 1 ) close ( 2 ) allocate ( wann % rcells_g ( wann % nwsg , 3 )) allocate ( wann % gwsdeg ( wann % nwsg )) open ( 1 , file = filename_gwscells , status = \"old\" ) open ( 2 , file = filename_gwsdeg , status = \"old\" ) do iuc = 1 , wann % nwsg read ( 1 , * ) wann % rcells_g ( iuc , :) read ( 2 , * ) wann % gwsdeg ( iuc ) end do close ( 1 ) close ( 2 ) end subroutine read_EPW_Wannier subroutine el_wann_epw ( wann , crys , nk , kvecs , energies , velocities , evecs ) !! Wannier interpolate electrons on list of arb. k-vecs class ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys integer ( k8 ), intent ( in ) :: nk real ( dp ), intent ( in ) :: kvecs ( nk , 3 ) !Crystal coordinates real ( dp ), intent ( out ) :: energies ( nk , wann % numwannbands ) real ( dp ), optional , intent ( out ) :: velocities ( nk , wann % numwannbands , 3 ) complex ( dp ), optional , intent ( out ) :: evecs ( nk , wann % numwannbands , wann % numwannbands ) !Local variables integer ( k8 ) :: iuc , ib , jb , ipol , ik , nwork , tmp real ( dp ) :: rcart ( 3 ) real ( dp ), allocatable :: rwork (:) complex ( dp ), allocatable :: work (:) complex ( dp ) :: caux , H ( wann % numwannbands , wann % numwannbands ), & dH ( 3 , wann % numwannbands , wann % numwannbands ) !Catch error for optional velocity calculation if ( present ( velocities ) . and . . not . present ( evecs )) & call exit_with_message ( \"In Wannier, velocity is present but not eigenvecs.\" ) nwork = 1 allocate ( work ( nwork )) allocate ( rwork ( max ( 1 , 7 * wann % numwannbands ))) do ik = 1 , nk !Form Hamiltonian (H) and k-derivative of H (dH) !from Hwann, rcells_k, and elwsdeg H = 0 dH = 0 do iuc = 1 , wann % nwsk caux = expi ( twopi * dot_product ( kvecs ( ik ,:), wann % rcells_k ( iuc ,:)))& / wann % elwsdeg ( iuc ) H = H + caux * wann % Hwann ( iuc ,:,:) if ( present ( velocities )) then rcart = matmul ( crys % lattvecs , wann % rcells_k ( iuc ,:)) do ipol = 1 , 3 dH ( ipol ,:,:) = dH ( ipol ,:,:) + & oneI * rcart ( ipol ) * caux * wann % Hwann ( iuc ,:,:) end do end if end do !Force Hermiticity do ib = 1 , wann % numwannbands do jb = ib + 1 , wann % numwannbands H ( ib , jb ) = ( H ( ib , jb ) + conjg ( H ( jb , ib ))) * 0.5_dp H ( jb , ib ) = H ( ib , jb ) end do end do !Diagonalize H call zheev ( \"V\" , \"U\" , wann % numwannbands , H (:,:), wann % numwannbands , energies ( ik ,:), & work , - 1_k8 , rwork , tmp ) if ( real ( work ( 1 )) > nwork ) then nwork = nint ( 2 * real ( work ( 1 ))) deallocate ( work ) allocate ( work ( nwork )) end if call zheev ( \"V\" , \"U\" , wann % numwannbands , H (:,:), wann % numwannbands , energies ( ik ,:), & work , nwork , rwork , tmp ) if ( present ( evecs )) then evecs ( ik ,:,:) = transpose ( H (:,:)) end if if ( present ( velocities )) then !Calculate velocities using Feynman-Hellmann thm do ib = 1 , wann % numwannbands do ipol = 1 , 3 velocities ( ik , ib , ipol ) = real ( dot_product ( evecs ( ik , ib ,:), & matmul ( dH ( ipol ,:,:), evecs ( ik , ib ,:)))) end do end do end if !energies(ik,:) = energies(ik,:)*Rydberg2radTHz !2piTHz energies ( ik ,:) = energies ( ik ,:) * Ryd2eV !eV if ( present ( velocities )) then velocities ( ik ,:,:) = velocities ( ik ,:,:) * Ryd2radTHz !nmTHz = Km/s end if end do !ik end subroutine el_wann_epw subroutine ph_wann_epw ( wann , crys , nq , qvecs , energies , evecs ) !! Wannier interpolate phonons on list of arb. q-vec class ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys !Local variables integer ( k8 ), intent ( in ) :: nq real ( dp ), intent ( in ) :: qvecs ( nq , 3 ) !Crystal coordinates real ( dp ), intent ( out ) :: energies ( nq , wann % numbranches ) complex ( dp ), intent ( out ), optional :: evecs ( nq , wann % numbranches , wann % numbranches ) integer ( k8 ) :: iuc , ib , jb , iq , na , nb , nwork , aux complex ( dp ) :: caux real ( dp ), allocatable :: rwork (:) complex ( dp ), allocatable :: work (:) real ( dp ) :: omega2 ( wann % numbranches ), massnorm complex ( dp ) :: dynmat ( wann % numbranches , wann % numbranches ) nwork = 1 allocate ( work ( nwork )) allocate ( rwork ( max ( 1 , 9 * crys % numatoms - 2 ))) do iq = 1 , nq !Form dynamical matrix dynmat = ( 0.0_dp , 0.0_dp ) do iuc = 1 , wann % nwsq caux = expi ( twopi * dot_product ( qvecs ( iq , :), wann % rcells_q ( iuc , :)))& / wann % phwsdeg ( iuc ) dynmat = dynmat + caux * wann % Dphwann ( iuc , :, :) end do !Non-analytic correction if ( crys % polar ) then call dyn_nonanalytic ( wann , crys , matmul ( crys % reclattvecs , qvecs ( iq ,:)) * bohr2nm , dynmat ) end if !Force Hermiticity do ib = 1 , wann % numbranches do jb = ib + 1 , wann % numbranches dynmat ( ib , jb ) = ( dynmat ( ib , jb ) + conjg ( dynmat ( jb , ib ))) * 0.5_dp dynmat ( jb , ib ) = dynmat ( ib , jb ) end do end do !Mass normalize do na = 1 , crys % numatoms do nb = 1 , crys % numatoms massnorm = 1.d0 / sqrt ( crys % masses ( crys % atomtypes ( na )) * & crys % masses ( crys % atomtypes ( nb ))) * Ryd2amu dynmat ( 3 * ( na - 1 ) + 1 : 3 * na , 3 * ( nb - 1 ) + 1 : 3 * nb ) = & dynmat ( 3 * ( na - 1 ) + 1 : 3 * na , 3 * ( nb - 1 ) + 1 : 3 * nb ) * massnorm end do end do !Diagonalize dynmat call zheev ( \"V\" , \"U\" , wann % numbranches , dynmat (:, :), wann % numbranches , omega2 , work , - 1_k8 , rwork , aux ) if ( real ( work ( 1 )) > nwork ) then nwork = nint ( 2 * real ( work ( 1 ))) deallocate ( work ) allocate ( work ( nwork )) end if call zheev ( \"V\" , \"U\" , wann % numbranches , dynmat (:, :), wann % numbranches , omega2 , work , nwork , rwork , aux ) energies ( iq , :) = sign ( sqrt ( abs ( omega2 )), omega2 ) if ( present ( evecs )) then evecs ( iq , :, :) = transpose ( dynmat (:, :)) end if !energies(iq, :) = energies(iq, :)*Rydberg2radTHz !2piTHz !energies(iq, :) = energies(iq, :)*Rydberg2eV*1.0e3_dp !meV energies ( iq , :) = energies ( iq , :) * Ryd2eV !eV !Take care of gamma point. if ( all ( qvecs ( iq ,:) == 0 )) then energies ( iq , 1 : 3 ) = 0 end if !Handle negative energy phonons do ib = 1 , wann % numbranches if ( energies ( iq , ib ) < - 0.005_dp ) then call exit_with_message ( 'Large negative phonon energy found! Stopping!' ) else if ( energies ( iq , ib ) < 0 . and . energies ( iq , ib ) > - 0.005_dp ) then energies ( iq , ib ) = 0 end if end do end do !iq end subroutine ph_wann_epw subroutine dyn_nonanalytic ( wann , crys , q , dyn ) !! Calculate the long-range correction to the !! dynamical matrix and its derivative for a given phonon mode. !! !! q: the phonon wave vector in Cartesian coords., Bohr&#94;-1 !! dyn: the dynamical matrix ! ! This is adapted from ShengBTE's subroutine phonon_espresso. ! ShengBTE is distributed under GPL v3 or later. class ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys !Local variables real ( dp ), intent ( in ) :: q ( 3 ) !Cartesian complex ( dp ), intent ( inout ) :: dyn ( wann % numbranches , wann % numbranches ) complex ( dp ) :: dyn_l ( wann % numbranches , wann % numbranches ), fnat ( 3 ) real ( dp ) :: qeq , arg , zig ( 3 ), zjg ( 3 ), g ( 3 ), gmax , alph , & tpiba , dgeg ( 3 ), rr ( crys % numatoms , crys % numatoms , 3 ) integer ( k8 ) :: iat , jat , idim , jdim , ipol , jpol , m1 , m2 , m3 , nq1 , nq2 , nq3 complex ( dp ) :: fac , facqd , facq tpiba = twopi / twonorm ( crys % lattvecs (:, 1 )) * bohr2nm !Recall that the phonon supercell in elphbolt is the !same as the EPW coarse phonon mesh. nq1 = wann % coarse_qmesh ( 1 ) nq2 = wann % coarse_qmesh ( 2 ) nq3 = wann % coarse_qmesh ( 3 ) gmax = 1 4.0_dp !dimensionless alph = tpiba ** 2 !bohr&#94;-2 !In Ry units, qe = sqrt(2.0) fac = 8.0_dp * pi / ( crys % volume / bohr2nm ** 3 ) dyn_l = ( 0.0_dp , 0.0_dp ) do m1 = - nq1 , nq1 do m2 = - nq2 , nq2 do m3 = - nq3 , nq3 g (:) = ( m1 * crys % reclattvecs (:, 1 ) + m2 * crys % reclattvecs (:, 2 ) + m3 * crys % reclattvecs (:, 3 )) * bohr2nm qeq = dot_product ( g , matmul ( crys % epsilon , g )) if ( qeq > 0.0_dp . and . qeq / alph / 4.0_dp < gmax ) then facqd = exp ( - qeq / alph / 4.0_dp ) / qeq do iat = 1 , crys % numatoms zig (:) = matmul ( g , crys % born (:,:, iat )) fnat (:) = ( 0.0_dp , 0.0_dp ) do jat = 1 , crys % numatoms rr ( iat , jat ,:) = ( crys % basis_cart (:, iat ) - crys % basis_cart (:, jat )) / bohr2nm arg = dot_product ( g , rr ( iat , jat ,:)) zjg (:) = matmul ( g , crys % born (:,:, jat )) fnat (:) = fnat (:) + zjg (:) * expi ( arg ) end do do ipol = 1 , 3 idim = ( iat - 1 ) * 3 + ipol do jpol = 1 , 3 jdim = ( iat - 1 ) * 3 + jpol dyn_l ( idim , jdim ) = dyn_l ( idim , jdim ) - & facqd * zig ( ipol ) * fnat ( jpol ) end do end do end do end if g = g + q qeq = dot_product ( g , matmul ( crys % epsilon , g )) if ( qeq > 0.0_dp . and . qeq / alph / 4.0_dp < gmax ) then facqd = exp ( - qeq / alph / 4.0_dp ) / qeq dgeg = matmul ( crys % epsilon + transpose ( crys % epsilon ), g ) do iat = 1 , crys % numatoms zig (:) = matmul ( g , crys % born (:,:, iat )) do jat = 1 , crys % numatoms rr ( iat , jat ,:) = ( crys % basis_cart (:, iat ) - crys % basis_cart (:, jat )) / bohr2nm zjg (:) = matmul ( g , crys % born (:,:, jat )) arg = dot_product ( g , rr ( iat , jat ,:)) facq = facqd * expi ( arg ) do ipol = 1 , 3 idim = ( iat - 1 ) * 3 + ipol do jpol = 1 , 3 jdim = ( jat - 1 ) * 3 + jpol dyn_l ( idim , jdim ) = dyn_l ( idim , jdim ) + facq * & zig ( ipol ) * zjg ( jpol ) end do end do end do end do end if end do end do end do dyn = dyn + dyn_l * fac end subroutine dyn_nonanalytic function g2_epw ( wann , crys , kvec , qvec , el_evec_k , el_evec_kp , ph_evec_q , ph_en , & gmixed , wannspace ) !! Function to calculate |g|&#94;2. !! This works with EPW real space data !! kvec: electron wave vector in crystal coords !! qvec: phonon wave vector in crystal coords !! el_evec_k(kp): initial(final) electron eigenvector in bands m(n) !! ph_evec_q: phonon eigenvector branchs !! ph_en: phonon energy in mode (s,qvec) !! gmixed: e-ph matrix element in mixed Wannier-Bloch representation !! wannspace: the species that is in Wannier representation class ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys real ( dp ), intent ( in ) :: kvec ( 3 ), qvec ( 3 ), ph_en complex ( dp ), intent ( in ) :: el_evec_k ( wann % numwannbands ),& el_evec_kp ( wann % numwannbands ), ph_evec_q ( wann % numbranches ), & gmixed (:,:,:,:) character ( len = 2 ) :: wannspace !Local variables integer ( k8 ) :: ip , iws , nws , np , mp , sp , mtype complex ( dp ) :: caux , u ( wann % numbranches ), gbloch , unm , & overlap ( wann % numwannbands , wann % numwannbands ), glprefac complex ( dp ), allocatable :: UkpgUk (:, :), UkpgUkuq (:) real ( dp ) :: g2_epw if ( wannspace /= 'el' . and . wannspace /= 'ph' ) then call exit_with_message (& \"Invalid value of wannspace in call to g2_epw. Exiting.\" ) end if !Mass normalize the phonon matrix do ip = 1 , wann % numbranches ! d.o.f of basis atoms !demux atom type from d.o.f mtype = ( ip - 1 ) / 3 + 1 !normalize and conjugate eigenvector u ( ip ) = ph_evec_q ( ip ) / sqrt ( crys % masses ( crys % atomtypes ( mtype ))) end do if ( ph_en == 0 ) then !zero out matrix elements for energy phonons g2_epw = 0 else if ( wannspace == 'ph' ) then nws = wann % nwsg else nws = wann % nwsk end if allocate ( UkpgUk ( wann % numbranches , nws ), UkpgUkuq ( nws )) UkpgUk = 0 !g(k,Rp) or g(Re,q) rotated by the electron U(k), U(k') matrices UkpgUkuq = 0 !above quantity rotated by the phonon u(q) matrix gbloch = 0 !Create the <n'|m'> overlap matrix do np = 1 , wann % numwannbands !over final electron band do mp = 1 , wann % numwannbands !over initial electron band overlap ( mp , np ) = conjg ( el_evec_kp ( np )) * el_evec_k ( mp ) end do end do do iws = 1 , nws !over matrix elements WS cell !Apply electron rotations do sp = 1 , wann % numbranches caux = 0 do np = 1 , wann % numwannbands !over final electron band do mp = 1 , wann % numwannbands !over initial electron band caux = caux + overlap ( mp , np ) * gmixed ( np , mp , sp , iws ) end do end do UkpgUk ( sp , iws ) = UkpgUk ( sp , iws ) + caux end do end do do iws = 1 , nws !over matrix elements WS cell !Apply phonon rotation UkpgUkuq ( iws ) = UkpgUkuq ( iws ) + dot_product ( conjg ( u ), UkpgUk (:, iws )) end do do iws = 1 , nws !over matrix elements WS cell if ( wannspace == 'ph' ) then !Fourier transform to q-space caux = expi ( twopi * dot_product ( qvec , wann % rcells_g ( iws , :)))& / wann % gwsdeg ( iws ) else caux = expi ( twopi * dot_product ( kvec , wann % rcells_k ( iws ,:)))& / wann % elwsdeg ( iws ) end if gbloch = gbloch + caux * UkpgUkuq ( iws ) end do if ( crys % polar ) then !Long-range correction unm = dot_product ( conjg ( el_evec_k ), el_evec_kp ) call long_range_prefac ( wann , crys , & matmul ( crys % reclattvecs , qvec ) * bohr2nm , u , glprefac ) gbloch = gbloch + glprefac * unm end if g2_epw = 0.5_dp * real ( gbloch * conjg ( gbloch )) / & ph_en * g2unitfactor !eV&#94;2 end if end function g2_epw subroutine long_range_prefac ( wann , crys , q , uqs , glprefac ) !! Calculate the long-range correction prefactor of !! the e-ph matrix element for a given phonon mode. !! q: phonon wvec in Cartesian coords., Bohr&#94;-1 !! uqs: phonon eigenfn for mode (s,q) !! glprefac: is the output in Ry units (EPW/QE) ! ! This is similar to the subroutine dyn_nonanalytic above, ! adapted from ShengBTE's subroutine phonon_espresso. ! ShengBTE is distributed under GPL v3 or later. class ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys real ( dp ), intent ( in ) :: q ( 3 ) !Cartesian complex ( dp ), intent ( in ) :: uqs ( wann % numbranches ) complex ( dp ), intent ( out ) :: glprefac real ( dp ) :: qeq , arg , zaq , g ( 3 ), gmax , alph , tpiba integer ( k8 ) :: na , ipol , m1 , m2 , m3 , nq1 , nq2 , nq3 complex ( dp ) :: fac , facqd , facq tpiba = twopi / twonorm ( crys % lattvecs (:, 1 )) * bohr2nm !Recall that the phonon supercell in elphbolt is the !same as the EPW coarse phonon mesh. nq1 = wann % coarse_qmesh ( 1 ) nq2 = wann % coarse_qmesh ( 2 ) nq3 = wann % coarse_qmesh ( 3 ) gmax = 1 4.d0 !dimensionless alph = tpiba ** 2 !bohr&#94;-2 !In Ry units, qe = sqrt(2.0) and epsilon_0 = 1/(4\\pi) fac = 8.d0 * pi / ( crys % volume / bohr2nm ** 3 ) * oneI glprefac = ( 0.d0 , 0.d0 ) do m1 = - nq1 , nq1 do m2 = - nq2 , nq2 do m3 = - nq3 , nq3 g (:) = ( m1 * crys % reclattvecs (:, 1 ) + m2 * crys % reclattvecs (:, 2 ) + m3 * crys % reclattvecs (:, 3 )) * bohr2nm + q qeq = dot_product ( g , matmul ( crys % epsilon , g )) if ( qeq > 0.d0 . and . qeq / alph / 4.d0 < gmax ) then facqd = exp ( - qeq / alph / 4.0d0 ) / qeq do na = 1 , crys % numatoms arg = - dot_product ( g , crys % basis_cart (:, na )) / bohr2nm facq = facqd * expi ( arg ) do ipol = 1 , 3 zaq = dot_product ( g , crys % born (:, ipol , na )) glprefac = glprefac + facq * zaq * uqs ( 3 * ( na - 1 ) + ipol ) end do end do end if end do end do end do glprefac = glprefac * fac end subroutine long_range_prefac subroutine gkRp_epw ( wann , num , ik , kvec ) !! Calculate the Bloch-Wannier mixed rep. e-ph matrix elements g(k,Rp), !! where k is an IBZ electron wave vector and Rp is a phonon unit cell. !! Note: this step *DOES NOT* perform the rotation over the Wannier bands space. !! !! The result will be saved to disk tagged with k-index. class ( epw_wannier ), intent ( in ) :: wann type ( numerics ), intent ( in ) :: num integer ( k8 ), intent ( in ) :: ik real ( dp ), intent ( in ) :: kvec ( 3 ) !Local variables integer ( k8 ) :: iuc complex ( dp ) :: caux complex ( dp ), allocatable :: gmixed (:,:,:,:) character ( len = 1024 ) :: filename allocate ( gmixed ( wann % numwannbands , wann % numwannbands , wann % numbranches , wann % nwsq )) !Fourier transform to k-space gmixed = 0 do iuc = 1 , wann % nwsk caux = expi ( twopi * dot_product ( kvec , wann % rcells_k ( iuc ,:))) / wann % elwsdeg ( iuc ) gmixed (:,:,:,:) = gmixed (:,:,:,:) + caux * wann % gwann (:,:, iuc ,:,:) end do !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) ik filename = 'gkRp.ik' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) gmixed close ( 1 ) !Change back to working directory call chdir ( num % cwd ) end subroutine gkRp_epw subroutine gReq_epw ( wann , num , iq , qvec ) !! Calculate the Bloch-Wannier mixed rep. e-ph matrix elements g(Re,q), !! where q is an IBZ phonon wave vector and Re is a phonon unit cell. !! Note: this step *DOES NOT* perform the rotation over the Wannier bands space. !! !! The result will be saved to disk tagged with k-index. class ( epw_wannier ), intent ( in ) :: wann type ( numerics ), intent ( in ) :: num integer ( k8 ), intent ( in ) :: iq real ( dp ), intent ( in ) :: qvec ( 3 ) !Local variables integer ( k8 ) :: iuc , s complex ( dp ) :: caux complex ( dp ), allocatable :: gmixed (:,:,:,:) character ( len = 1024 ) :: filename allocate ( gmixed ( wann % numwannbands , wann % numwannbands , wann % numbranches , wann % nwsk )) !Fourier transform to q-space gmixed = 0 do iuc = 1 , wann % nwsg caux = expi ( twopi * dot_product ( qvec , wann % rcells_g ( iuc ,:))) / wann % gwsdeg ( iuc ) do s = 1 , wann % numbranches gmixed (:,:, s ,:) = gmixed (:,:, s ,:) + caux * wann % gwann (:,:,:, s , iuc ) end do end do !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) iq filename = 'gReq.iq' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) gmixed close ( 1 ) !Change back to working directory call chdir ( num % cwd ) end subroutine gReq_epw subroutine deallocate_wannier ( wann , num ) !! Deallocates some Wannier quantities class ( epw_wannier ), intent ( inout ) :: wann type ( numerics ), intent ( in ) :: num deallocate ( wann % rcells_k , wann % rcells_q , wann % rcells_g , & wann % elwsdeg , wann % phwsdeg , wann % gwsdeg , & wann % Hwann , wann % Dphwann ) if (. not . num % read_gk2 . and . . not . num % read_gq2 . or . & num % plot_along_path ) then deallocate ( wann % gwann ) end if end subroutine deallocate_wannier subroutine plot_along_path ( wann , crys , num ) !! Subroutine to plot bands, dispersions, e-ph matrix elements !! using the Wannier interpolation method with EPW inputs. class ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys type ( numerics ), intent ( in ) :: num !Local variables integer ( k8 ) :: i , nqpath , m , n , s , deg_count , mp , np , sp , icart real ( dp ) :: k ( 1 , 3 ), kp ( 1 , 3 ), thres , aux , el_en , ph_en real ( dp ), allocatable :: qpathvecs (:,:), ph_ens_path (:,:), & el_ens_path (:,:), el_ens_kp (:,:), & el_vels_kp (:,:,:), g2_qpath (:,:,:,:), el_ens_k (:,:), el_vels_k (:,:,:) complex ( dp ), allocatable :: ph_evecs_path (:,:,:), el_evecs_kp (:,:,:), & el_evecs_k (:,:,:), gmixed_k (:,:,:,:) character ( len = 1024 ) :: filename character ( len = 8 ) :: saux call print_message ( \"Plotting bands, dispersions, and e-ph vertex along path...\" ) if ( this_image () == 1 ) then !Threshold used to measure degeneracy thres = 1.0e-6_dp !0.001 meV !Read list of wavevectors in crystal coordinates open ( 1 , file = trim ( 'highsympath.txt' ), status = 'old' ) read ( 1 , * ) nqpath allocate ( qpathvecs ( nqpath , 3 )) do i = 1 , nqpath read ( 1 , * ) qpathvecs ( i ,:) end do !Calculate phonon dispersions allocate ( ph_ens_path ( nqpath , wann % numbranches ), & ph_evecs_path ( nqpath , wann % numbranches , wann % numbranches )) call ph_wann_epw ( wann , crys , nqpath , qpathvecs , ph_ens_path , ph_evecs_path ) !Output phonon dispersions write ( saux , \"(I0)\" ) wann % numbranches open ( 1 , file = \"ph.ens_qpath\" , status = \"replace\" ) do i = 1 , nqpath write ( 1 , \"(\" // trim ( adjustl ( saux )) // \"E20.10)\" ) ph_ens_path ( i ,:) end do close ( 1 ) !Calculate electron bands allocate ( el_ens_path ( nqpath , wann % numwannbands )) call el_wann_epw ( wann , crys , nqpath , qpathvecs , el_ens_path ) !Output electron dispersions write ( saux , \"(I0)\" ) wann % numwannbands open ( 1 , file = \"el.ens_kpath\" , status = \"replace\" ) do i = 1 , nqpath write ( 1 , \"(\" // trim ( adjustl ( saux )) // \"E20.10)\" ) el_ens_path ( i ,:) end do close ( 1 ) allocate ( el_ens_k ( 1 , wann % numwannbands ), el_vels_k ( 1 , wann % numwannbands , 3 ),& el_evecs_k ( 1 , wann % numwannbands , wann % numwannbands )) allocate ( el_ens_kp ( 1 , wann % numwannbands ), el_vels_kp ( 1 , wann % numwannbands , 3 ),& el_evecs_kp ( 1 , wann % numwannbands , wann % numwannbands )) allocate ( g2_qpath ( nqpath , wann % numbranches , wann % numwannbands , wann % numwannbands )) !Read wave vector of initial electron open ( 1 , file = trim ( 'initialk.txt' ), status = 'old' ) read ( 1 , * ) k ( 1 , :) !Calculate g(k, Rp) call wann % gkRp_epw ( num , 0_k8 , k ( 1 ,:)) !Load gmixed from file !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) allocate ( gmixed_k ( wann % numwannbands , wann % numwannbands , wann % numbranches , wann % nwsq )) filename = 'gkRp.ik0' open ( 1 , file = filename , status = \"old\" , access = 'stream' ) read ( 1 ) gmixed_k close ( 1 ) !Change back to working directory call chdir ( num % cwd ) call el_wann_epw ( wann , crys , 1_k8 , k , el_ens_k , el_vels_k , el_evecs_k ) do i = 1 , nqpath !Over phonon wave vectors path kp ( 1 , :) = k ( 1 , :) + qpathvecs ( i , :) do icart = 1 , 3 if ( kp ( 1 , icart ) >= 1.0_dp ) kp ( 1 , icart ) = kp ( 1 , icart ) - 1.0_dp end do !Calculate electrons at this final wave vector call el_wann_epw ( wann , crys , 1_k8 , kp , el_ens_kp , el_vels_kp , el_evecs_kp ) do n = 1 , wann % numwannbands do m = 1 , wann % numwannbands do s = 1 , wann % numbranches !Calculate |g(k,k')|&#94;2 g2_qpath ( i , s , m , n ) = wann % g2_epw ( crys , k , qpathvecs ( i , :), & el_evecs_k ( 1 , m , :), el_evecs_kp ( 1 , n , :), ph_evecs_path ( i , s , :), & ph_ens_path ( i , s ), gmixed_k , 'ph' ) end do end do end do !The gauge arbitrariness of |g| due to the band and branch degeneraries !are removed below. The code below is closely following the change !to elphon.f90 of Quantum Espresso by C. Verdi and S. Ponce. ! !This modified elphon.f90 was made available during EPW's 2018 !ICTP/Psi-k/CECAM School on Electron-Phonon Physics from First Principles. !Visit for more info: https://docs.epw-code.org/doc/School2018.html !Average over degenerate phonon branches do m = 1 , wann % numwannbands do n = 1 , wann % numwannbands do s = 1 , wann % numbranches deg_count = 0 aux = 0.0_dp ph_en = ph_ens_path ( i , s ) do sp = 1 , wann % numbranches if ( abs ( ph_en - ph_ens_path ( i , sp )) < thres ) then deg_count = deg_count + 1 aux = aux + g2_qpath ( i , sp , m , n ) end if end do g2_qpath ( i , s , m , n ) = aux / dble ( deg_count ) end do end do end do !Average over initial electron bands do s = 1 , wann % numbranches do n = 1 , wann % numwannbands do m = 1 , wann % numwannbands deg_count = 0 aux = 0.0_dp el_en = el_ens_k ( 1 , m ) do mp = 1 , wann % numwannbands if ( abs ( el_en - el_ens_k ( 1 , mp )) < thres ) then deg_count = deg_count + 1 aux = aux + g2_qpath ( i , s , mp , n ) end if end do g2_qpath ( i , s , m , n ) = aux / dble ( deg_count ) end do end do end do !Average over final electron bands do s = 1 , wann % numbranches do m = 1 , wann % numwannbands do n = 1 , wann % numwannbands deg_count = 0 aux = 0.0_dp el_en = el_ens_kp ( 1 , n ) do np = 1 , wann % numwannbands if ( abs ( el_en - el_ens_kp ( 1 , np )) < thres ) then deg_count = deg_count + 1 aux = aux + g2_qpath ( i , s , m , np ) end if end do g2_qpath ( i , s , m , n ) = aux / dble ( deg_count ) end do end do end do end do !Print out |gk(m,n,s,qpath)| open ( 1 , file = 'gk_qpath' , status = \"replace\" ) write ( 1 , * ) '   m    n    s    |gk|[eV]' do i = 1 , nqpath do m = 1 , wann % numwannbands do n = 1 , wann % numwannbands do s = 1 , wann % numbranches write ( 1 , \"(I5, I5, I5, E20.10)\" ) m , n , s , sqrt ( g2_qpath ( i , s , m , n )) end do end do end do end do close ( 1 ) end if sync all end subroutine plot_along_path end module wannier_module","tags":"","loc":"sourcefile/wannier.f90.html"},{"title":"interactions.f90 – elphbolt","text":"This file depends on sourcefile~~interactions.f90~~EfferentGraph sourcefile~interactions.f90 interactions.f90 sourcefile~misc.f90 misc.f90 sourcefile~interactions.f90->sourcefile~misc.f90 sourcefile~electron.f90 electron.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~numerics.f90 numerics.f90 sourcefile~interactions.f90->sourcefile~numerics.f90 sourcefile~wannier.f90 wannier.f90 sourcefile~interactions.f90->sourcefile~wannier.f90 sourcefile~params.f90 params.f90 sourcefile~interactions.f90->sourcefile~params.f90 sourcefile~crystal.f90 crystal.f90 sourcefile~interactions.f90->sourcefile~crystal.f90 sourcefile~delta.f90 delta.f90 sourcefile~interactions.f90->sourcefile~delta.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 sourcefile~misc.f90->sourcefile~params.f90 sourcefile~electron.f90->sourcefile~misc.f90 sourcefile~electron.f90->sourcefile~numerics.f90 sourcefile~electron.f90->sourcefile~wannier.f90 sourcefile~electron.f90->sourcefile~params.f90 sourcefile~electron.f90->sourcefile~crystal.f90 sourcefile~electron.f90->sourcefile~delta.f90 sourcefile~symmetry.f90 symmetry.f90 sourcefile~electron.f90->sourcefile~symmetry.f90 sourcefile~numerics.f90->sourcefile~misc.f90 sourcefile~numerics.f90->sourcefile~params.f90 sourcefile~numerics.f90->sourcefile~crystal.f90 sourcefile~wannier.f90->sourcefile~misc.f90 sourcefile~wannier.f90->sourcefile~numerics.f90 sourcefile~wannier.f90->sourcefile~params.f90 sourcefile~wannier.f90->sourcefile~crystal.f90 sourcefile~crystal.f90->sourcefile~misc.f90 sourcefile~crystal.f90->sourcefile~params.f90 sourcefile~delta.f90->sourcefile~misc.f90 sourcefile~delta.f90->sourcefile~params.f90 sourcefile~phonon.f90->sourcefile~misc.f90 sourcefile~phonon.f90->sourcefile~numerics.f90 sourcefile~phonon.f90->sourcefile~wannier.f90 sourcefile~phonon.f90->sourcefile~params.f90 sourcefile~phonon.f90->sourcefile~crystal.f90 sourcefile~phonon.f90->sourcefile~delta.f90 sourcefile~phonon.f90->sourcefile~symmetry.f90 sourcefile~symmetry.f90->sourcefile~misc.f90 sourcefile~symmetry.f90->sourcefile~params.f90 sourcefile~symmetry.f90->sourcefile~crystal.f90 sourcefile~spglib_wrapper.f90 spglib_wrapper.f90 sourcefile~symmetry.f90->sourcefile~spglib_wrapper.f90 sourcefile~spglib_wrapper.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~interactions.f90~~AfferentGraph sourcefile~interactions.f90 interactions.f90 sourcefile~bte.f90 bte.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules interactions Source Code interactions.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module interactions !! Module containing the procedures related to the computation of interactions. use params , only : k8 , dp , pi , twopi , amu , qe , hbar_eVps , perm0 use misc , only : exit_with_message , print_message , distribute_points , & demux_state , mux_vector , mux_state , expi , Bose , binsearch , Fermi , & twonorm use wannier_module , only : epw_wannier use crystal_module , only : crystal use electron_module , only : electron use phonon_module , only : phonon , phonon_espresso use numerics_module , only : numerics use delta , only : delta_fn_tetra , delta_fn_triang implicit none private public calculate_gReq , calculate_gkRp , calculate_3ph_interaction , & calculate_ph_rta_rates , read_transition_probs_e , & calculate_eph_interaction_ibzq , calculate_eph_interaction_ibzk , & calculate_echimp_interaction_ibzk , calculate_el_rta_rates contains pure real ( dp ) function transfac ( v1 , v2 ) !! Calculate the \"transport factor\" that suppresses forward scattering !! v1, v2: vectors in cartesian coordinates real ( dp ), intent ( in ) :: v1 ( 3 ), v2 ( 3 ) real ( dp ) :: v1sc , v2sc , thresh thresh = 1.0e-8_dp transfac = 0.0_dp v1sc = twonorm ( v1 ) v2sc = twonorm ( v2 ) if ( v1sc /= v2sc . and . v1sc > thresh . and . v2sc > thresh ) then transfac = 1.0_dp - dot_product ( v1 , v2 ) / v1sc / v2sc end if end function transfac pure real ( dp ) function qdist ( q , reclattvecs ) !! Function to calculate the smallest wave vector distance in the BZ. !! q is in crystal coordinates. !! qdist will be in nm&#94;-1 real ( dp ), intent ( in ) :: q ( 3 ), reclattvecs ( 3 , 3 ) real ( dp ) :: distfromcorners ( 3 ** 3 ) integer ( k8 ) :: i , j , k , count count = 1 do i = - 1 , 1 do j = - 1 , 1 do k = - 1 , 1 distfromcorners ( count ) = twonorm ( matmul ( reclattvecs , q - ( / i , j , k / ))) count = count + 1 end do end do end do qdist = minval ( distfromcorners ) end function qdist pure real ( dp ) function gchimp2 ( el , crys , q ) !! Function to calculate the squared electron-charged impurity vertex. !! !! This is the Fourier transform of the Yukawa potential, c.f. Eq. 33 !! of RevModPhys.53.745 (1981). type ( crystal ), intent ( in ) :: crys type ( electron ), intent ( in ) :: el real ( dp ), intent ( in ) :: q gchimp2 = 1.0e-3_dp / crys % volume / (( perm0 * crys % epsilon0 ) * ( q ** 2 + crys % qTF ** 2 )) ** 2 * & ( el % chimp_conc_n * ( qe * el % Zn ** 2 ) ** 2 + el % chimp_conc_p * ( qe * el % Zp ** 2 ) ** 2 ) !ev&#94;2 end function gchimp2 pure real ( dp ) function Vm2_3ph ( ev1_s1 , conjg_ev2_s2 , conjg_ev3_s3 , & Index_i , Index_j , Index_k , ifc3 , phases_q2q3 , ntrip , nb ) !! Function to calculate the squared 3-ph interaction vertex |V-|&#94;2. integer ( k8 ), intent ( in ) :: ntrip , Index_i ( ntrip ), Index_j ( ntrip ), Index_k ( ntrip ), nb complex ( dp ), intent ( in ) :: phases_q2q3 ( ntrip ), ev1_s1 ( nb ), conjg_ev2_s2 ( nb ), conjg_ev3_s3 ( nb ) real ( dp ), intent ( in ) :: ifc3 ( 3 , 3 , 3 , ntrip ) !Local variables integer ( k8 ) :: it , a , b , c , aind , bind , cind complex ( dp ) :: aux1 , aux2 , aux3 , V0 aux1 = ( 0.0_dp , 0.0_dp ) do it = 1 , ntrip aind = 3 * ( Index_k ( it ) - 1 ) bind = 3 * ( Index_j ( it ) - 1 ) cind = 3 * ( Index_i ( it ) - 1 ) V0 = ( 0.0_dp , 0.0_dp ) do a = 1 , 3 aux2 = conjg_ev3_s3 ( a + aind ) do b = 1 , 3 aux3 = aux2 * conjg_ev2_s2 ( b + bind ) do c = 1 , 3 if ( ifc3 ( c , b , a , it ) /= 0.0_dp ) then V0 = V0 + ifc3 ( c , b , a , it ) * ev1_s1 ( c + cind ) * aux3 end if end do end do end do aux1 = aux1 + V0 * phases_q2q3 ( it ) end do Vm2_3ph = abs ( aux1 ) ** 2 end function Vm2_3ph subroutine calculate_3ph_interaction ( ph , crys , num , key ) !! Parallel driver of the 3-ph vertex calculator for all IBZ phonon wave vectors. !! This subroutine calculates |V-(s1<q1>|s2q2,s3q3)|&#94;2, W-(s1<q1>|s2q2,s3q3), !! and W+(s1<q1>|s2q2,s3q3) for each irreducible phonon and saves the results to disk. !! !! key = 'V', 'W' for vertex, transition probabilitiy calculation, respectively. type ( phonon ), intent ( in ) :: ph type ( crystal ), intent ( in ) :: crys type ( numerics ), intent ( in ) :: num character ( len = 1 ), intent ( in ) :: key !Local variables integer ( k8 ) :: start , end , chunk , istate1 , nstates_irred , & nprocs , s1 , s2 , s3 , iq1_ibz , iq1 , iq2 , iq3_minus , it , & q1_indvec ( 3 ), q2_indvec ( 3 ), q3_minus_indvec ( 3 ), index_minus , index_plus , & neg_iq2 , neg_q2_indvec ( 3 ), num_active_images , plus_count , minus_count real ( dp ) :: en1 , en2 , en3 , massfac , q1 ( 3 ), q2 ( 3 ), q3_minus ( 3 ), q2_cart ( 3 ), q3_minus_cart ( 3 ), & occup_fac , const , bose2 , bose3 , delta_minus , delta_plus real ( dp ), allocatable :: Vm2_1 (:), Vm2_2 (:), Wm (:), Wp (:) integer ( k8 ), allocatable :: istate2_plus (:), istate3_plus (:), istate2_minus (:), istate3_minus (:) complex ( dp ) :: phases_q2q3 ( ph % numtriplets ) character ( len = 1024 ) :: filename , filename_Wm , filename_Wp if ( key /= 'V' . and . key /= 'W' ) then call exit_with_message ( \"Invalid value of key in call to calculate_3ph_interaction. Exiting.\" ) end if if ( key == 'V' ) then call print_message ( \"Calculating 3-ph vertices for all IBZ phonons...\" ) else call print_message ( \"Calculating 3-ph transition probabilities for all IBZ phonons...\" ) end if !Conversion factor in transition probability expression const = pi / 4.0_dp * hbar_eVps ** 5 * ( qe / amu ) ** 3 * 1.0d-12 !Total number of IBZ blocks states nstates_irred = ph % nq_irred * ph % numbranches !Maximum total number of 3-phonon processes for a given initial phonon state nprocs = ph % nq * ph % numbranches ** 2 !Allocate |V&#94;-|&#94;2 if ( key == 'V' ) allocate ( Vm2_1 ( nprocs ), Vm2_2 ( nprocs )) ! Above, we split the |V-|&#94;2 vertices into two parts: ! 1. that are non-zero when the minus-type processes are energetically allowed ! 2. that are non-zero when the symmetry-related plus-type processes are energetically allowed !Allocate W- and W+ if ( key == 'W' ) then allocate ( Wp ( nprocs ), Wm ( nprocs )) allocate ( istate2_plus ( nprocs ), istate3_plus ( nprocs ),& istate2_minus ( nprocs ), istate3_minus ( nprocs )) end if !Divide phonon states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" #states = \" , nstates_irred write ( * , \"(A, I10)\" ) \" #states/image = \" , chunk end if !Run over first phonon IBZ states do istate1 = start , end !Load |V&#94;-|&#94;2 from disk for scattering rates calculation if ( key == 'W' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % Vdir ))) !Read data in binary format write ( filename , '(I9)' ) istate1 filename = 'Vm2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'old' , access = 'stream' ) read ( 1 ) minus_count if ( allocated ( Vm2_1 )) deallocate ( Vm2_1 ) allocate ( Vm2_1 ( minus_count )) if ( minus_count > 0 ) read ( 1 ) Vm2_1 read ( 1 ) plus_count if ( allocated ( Vm2_2 )) deallocate ( Vm2_2 ) allocate ( Vm2_2 ( plus_count )) if ( plus_count > 0 ) read ( 1 ) Vm2_2 close ( 1 ) !Change back to working directory call chdir ( num % cwd ) !Initialize transition probabilities Wp (:) = 0.0_dp Wm (:) = 0.0_dp istate2_plus (:) = 0_k8 istate3_plus (:) = 0_k8 istate2_minus (:) = 0_k8 istate3_minus (:) = 0_k8 end if !Initialize transition probabilities plus_count = 0_k8 minus_count = 0_k8 !Demux state index into branch (s) and wave vector (iq) indices call demux_state ( istate1 , ph % numbranches , s1 , iq1_ibz ) !Muxed index of wave vector from the IBZ index list. !This will be used to access IBZ information from the FBZ quantities. iq1 = ph % indexlist_irred ( iq1_ibz ) !Energy of phonon 1 en1 = ph % ens ( iq1 , s1 ) !Initial (IBZ blocks) wave vector (crystal coords.) q1 = ph % wavevecs ( iq1 , :) !Convert from crystal to 0-based index vector q1_indvec = nint ( q1 * ph % qmesh ) !Run over second (FBZ) phonon wave vectors do iq2 = 1 , ph % nq !Initial (IBZ blocks) wave vector (crystal coords.) q2 = ph % wavevecs ( iq2 , :) !Convert from crystal to 0-based index vector q2_indvec = nint ( q2 * ph % qmesh ) !Folded final phonon wave vector q3_minus_indvec = modulo ( q1_indvec - q2_indvec , ph % qmesh ) !0-based index vector q3_minus = q3_minus_indvec / dble ( ph % qmesh ) !crystal coords. !Muxed index of q3_minus iq3_minus = mux_vector ( q3_minus_indvec , ph % qmesh , 0_k8 ) if ( key == 'V' ) then if ( en1 /= 0.0_dp ) then !Calculate the numtriplet number of mass-normalized phases for this (q2,q3) pair do it = 1 , ph % numtriplets massfac = 1.0_dp / sqrt (& crys % masses ( crys % atomtypes ( ph % Index_i ( it ))) * & crys % masses ( crys % atomtypes ( ph % Index_j ( it ))) * & crys % masses ( crys % atomtypes ( ph % Index_k ( it )))) q2_cart = matmul ( crys % reclattvecs , q2 ) q3_minus_cart = matmul ( crys % reclattvecs , q3_minus ) phases_q2q3 ( it ) = massfac * & expi ( - dot_product ( q2_cart , ph % R_j (:, it )) - & dot_product ( q3_minus_cart , ph % R_k (:, it ))) end do end if end if !Run over branches of second phonon do s2 = 1 , ph % numbranches !Energy of phonon 2 en2 = ph % ens ( iq2 , s2 ) !Get index of -q2 neg_q2_indvec = modulo ( - q2_indvec , ph % qmesh ) neg_iq2 = mux_vector ( neg_q2_indvec , ph % qmesh , 0_k8 ) if ( key == 'W' ) then !Bose factor for phonon 2 bose2 = Bose ( en2 , crys % T ) end if !Run over branches of third phonon do s3 = 1 , ph % numbranches !Minus process index index_minus = (( iq2 - 1 ) * ph % numbranches + ( s2 - 1 )) * ph % numbranches + s3 !Energy of phonon 3 en3 = ph % ens ( iq3_minus , s3 ) !Evaluate delta functions if ( num % tetrahedra ) then delta_minus = delta_fn_tetra ( en1 - en3 , iq2 , s2 , ph % qmesh , ph % tetramap , & ph % tetracount , ph % tetra_evals ) !minus process delta_plus = delta_fn_tetra ( en3 - en1 , neg_iq2 , s2 , ph % qmesh , ph % tetramap , & ph % tetracount , ph % tetra_evals ) !plus process else delta_minus = delta_fn_triang ( en1 - en3 , iq2 , s2 , ph % qmesh , ph % triangmap , & ph % triangcount , ph % triang_evals ) !minus process delta_plus = delta_fn_triang ( en3 - en1 , neg_iq2 , s2 , ph % qmesh , ph % triangmap , & ph % triangcount , ph % triang_evals ) !plus process end if if ( key == 'V' ) then if ( en1 * en2 * en3 == 0.0_dp ) cycle if ( delta_minus > 0.0_dp ) then !Increase counter for energetically available minus process minus_count = minus_count + 1 !Save the index of this process !V1_indexlist(minus_count) = index_minus !Calculate and save the minus process vertex Vm2_1 ( minus_count ) = Vm2_3ph ( ph % evecs ( iq1 , s1 , :), & conjg ( ph % evecs ( iq2 , s2 , :)), conjg ( ph % evecs ( iq3_minus , s3 , :)), & ph % Index_i (:), ph % Index_j (:), ph % Index_k (:), ph % ifc3 (:,:,:,:), & phases_q2q3 , ph % numtriplets , ph % numbranches ) end if if ( delta_plus > 0.0_dp ) then !Increase counter for energetically available plus process plus_count = plus_count + 1 !Calculate and save the minus process vertex Vm2_2 ( plus_count ) = Vm2_3ph ( ph % evecs ( iq1 , s1 , :), & conjg ( ph % evecs ( iq2 , s2 , :)), conjg ( ph % evecs ( iq3_minus , s3 , :)), & ph % Index_i (:), ph % Index_j (:), ph % Index_k (:), ph % ifc3 (:,:,:,:), & phases_q2q3 , ph % numtriplets , ph % numbranches ) end if end if if ( key == 'W' ) then if ( en1 * en2 * en3 == 0.0_dp ) cycle !Bose factor for phonon 3 bose3 = Bose ( en3 , crys % T ) !Calculate W-: !Temperature dependent occupation factor !(bose1 + 1)*bose2*bose3/(bose1*(bose1 + 1)) ! = (bose2 + bose3 + 1) occup_fac = ( bose2 + bose3 + 1.0_dp ) if ( delta_minus > 0.0_dp ) then !Non-zero process counter minus_count = minus_count + 1 !Save W- !Wm(minus_count) = Vm2(index_minus)*occup_fac*delta_minus/en1/en2/en3 Wm ( minus_count ) = Vm2_1 ( minus_count ) * occup_fac * delta_minus / en1 / en2 / en3 istate2_minus ( minus_count ) = mux_state ( ph % numbranches , s2 , iq2 ) istate3_minus ( minus_count ) = mux_state ( ph % numbranches , s3 , iq3_minus ) end if !Calculate W+: !Grab index of corresponding plus process using !V-(s1q1|s2q2,s3q3) = V+(s1q1|s2-q2,s3q3) index_plus = (( neg_iq2 - 1 ) * ph % numbranches + ( s2 - 1 )) * ph % numbranches + s3 !Temperature dependent occupation factor !(bose1 + 1)*(bose2 + 1)*bose3/(bose1*(bose1 + 1)) ! = bose2 - bose3. occup_fac = ( bose2 - bose3 ) if ( delta_plus > 0.0_dp ) then !Non-zero process counter plus_count = plus_count + 1 !Save W+ Wp ( plus_count ) = Vm2_2 ( plus_count ) * occup_fac * delta_plus / en1 / en2 / en3 istate2_plus ( plus_count ) = mux_state ( ph % numbranches , s2 , neg_iq2 ) istate3_plus ( plus_count ) = mux_state ( ph % numbranches , s3 , iq3_minus ) end if end if end do !s3 end do !s2 end do !iq2 if ( key == 'V' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % Vdir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate1 filename = 'Vm2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) minus_count write ( 1 ) Vm2_1 ( 1 : minus_count ) write ( 1 ) plus_count write ( 1 ) Vm2_2 ( 1 : plus_count ) close ( 1 ) end if if ( key == 'W' ) then !Multiply constant factor, unit factor, etc. Wm (:) = const * Wm (:) !THz Wp (:) = const * Wp (:) !THz !Write W+ and W- to disk !Change to data output directory call chdir ( trim ( adjustl ( num % Wdir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate1 filename_Wm = 'Wm.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename_Wm ), status = 'replace' , access = 'stream' ) write ( 1 ) minus_count write ( 1 ) Wm ( 1 : minus_count ) write ( 1 ) istate2_minus ( 1 : minus_count ) write ( 1 ) istate3_minus ( 1 : minus_count ) close ( 1 ) filename_Wp = 'Wp.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename_Wp ), status = 'replace' , access = 'stream' ) write ( 1 ) plus_count write ( 1 ) Wp ( 1 : plus_count ) write ( 1 ) istate2_plus ( 1 : plus_count ) write ( 1 ) istate3_plus ( 1 : plus_count ) close ( 1 ) end if !Change back to working directory call chdir ( num % cwd ) end do !istate1 sync all end subroutine calculate_3ph_interaction subroutine calculate_gReq ( wann , ph , num ) !! Parallel driver of gReq_epw over IBZ phonon wave vectors. type ( epw_wannier ), intent ( in ) :: wann type ( phonon ), intent ( in ) :: ph type ( numerics ), intent ( in ) :: num !Local variables integer ( k8 ) :: iq , iqstart , iqend , chunk , num_active_images call print_message ( \"Calculating g(Re,Rp) -> g(Re,q) for all IBZ q...\" ) call distribute_points ( ph % nq_irred , chunk , iqstart , iqend , num_active_images ) if ( this_image () == 1 ) then print * , \"   #q = \" , ph % nq_irred print * , \"   #q/image = \" , chunk end if do iq = iqstart , iqend call wann % gReq_epw ( num , iq , ph % wavevecs_irred ( iq , :)) end do sync all end subroutine calculate_gReq subroutine calculate_gkRp ( wann , el , num ) !! Parallel driver of gkRp_epw over IBZ electron wave vectors. type ( epw_wannier ), intent ( in ) :: wann type ( electron ), intent ( in ) :: el type ( numerics ), intent ( in ) :: num !Local variables integer ( k8 ) :: ik , ikstart , ikend , chunk , num_active_images call print_message ( \"Calculating g(Re,Rp) -> g(k,Rp) for all IBZ k...\" ) call distribute_points ( el % nk_irred , chunk , ikstart , ikend , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" #k = \" , el % nk_irred write ( * , \"(A, I10)\" ) \" #k/image = \" , chunk end if do ik = ikstart , ikend call wann % gkRp_epw ( num , ik , el % wavevecs_irred ( ik , :)) end do sync all end subroutine calculate_gkRp subroutine calculate_eph_interaction_ibzq ( wann , crys , el , ph , num , key ) !! Parallel driver of g2(q,k) over IBZ phonon states. !! !! This subroutine will calculate the full Bloch rep. matrix elements for !! all the energy window restricted electron-phonon processes for a given !! irreducible initial phonon state = (branch, wave vector). !! This list will be written to disk in files tagged with the muxed state index. !! !! key = 'g', 'Y' for vertex, transition probability calculation, respectively. ! !In the FBZ and IBZ blocks a wave vector was retained when at least one !band belonged within the energy window. Here the bands outside the energy !window will be skipped in the calculation as they are irrelevant for transport. type ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys type ( electron ), intent ( in ) :: el type ( phonon ), intent ( in ) :: ph type ( numerics ), intent ( in ) :: num character ( len = 1 ), intent ( in ) :: key !Local variables integer ( k8 ) :: nstates_irred , istate , m , iq , iq_fbz , n , ik , ikp , s , & ikp_window , start , end , chunk , k_indvec ( 3 ), kp_indvec ( 3 ), & q_indvec ( 3 ), nprocs , count , num_active_images integer ( k8 ), allocatable :: istate1 (:), istate2 (:) real ( dp ) :: k ( 3 ), q ( 3 ), en_ph , en_el , en_elp , const , delta , & invboseplus1 , fermi1 , fermi2 , occup_fac real ( dp ), allocatable :: g2_istate (:), Y_istate (:) complex ( dp ) :: gReq_iq ( wann % numwannbands , wann % numwannbands , wann % numbranches , wann % nwsk ) character ( len = 1024 ) :: filename if ( key /= 'g' . and . key /= 'Y' ) then call exit_with_message (& \"Invalid value of key in call to calculate_eph_interaction_ibzq. Exiting.\" ) end if if ( key == 'g' ) then call print_message ( \"Calculating g(Re,q) -> |g(k,q)|&#94;2 for all IBZ phonons...\" ) else call print_message ( \"Calculating ph-e transition probabilities for all IBZ phonons...\" ) end if !Allocate and initialize g2_istate if ( key == 'g' ) then !Maximum length of g2_istate nprocs = el % nstates_inwindow * ph % numbranches allocate ( g2_istate ( nprocs )) g2_istate (:) = 0.0_dp end if !Conversion factor in transition probability expression const = twopi / hbar_eVps !Total number of IBZ blocks states nstates_irred = ph % nq_irred * ph % numbranches call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" #states = \" , nstates_irred write ( * , \"(A, I10)\" ) \" #states/image = \" , chunk end if do istate = start , end !over IBZ blocks states !Demux state index into branch (s) and wave vector (iq) indices call demux_state ( istate , ph % numbranches , s , iq ) if ( key == 'g' ) then !Load gReq(iq) here for use inside the loops below call chdir ( trim ( adjustl ( num % g2dir ))) write ( filename , '(I6)' ) iq filename = 'gReq.iq' // trim ( adjustl ( filename )) open ( 1 , file = filename , status = \"old\" , access = 'stream' ) read ( 1 ) gReq_iq close ( 1 ) call chdir ( num % cwd ) end if !Get the muxed index of FBZ wave vector from the IBZ blocks index list iq_fbz = ph % indexlist_irred ( iq ) !Energy of phonon en_ph = ph % ens ( iq_fbz , s ) !1/(1 + Bose factor) for phonon if ( key == 'Y' ) then if ( en_ph /= 0.0_dp ) then invboseplus1 = 1.0_dp / ( 1.0_dp + Bose ( en_ph , crys % T )) else invboseplus1 = 0.0_dp end if end if !Initial (IBZ blocks) wave vector (crystal coords.) q = ph % wavevecs ( iq_fbz , :) !Convert from crystal to 0-based index vector q_indvec = nint ( q * ph % qmesh ) !Load g2_istate from disk for scattering rates calculation if ( key == 'Y' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Read data in binary format write ( filename , '(I9)' ) istate filename = 'gq2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'old' , access = 'stream' ) read ( 1 ) nprocs if ( allocated ( g2_istate )) deallocate ( g2_istate , Y_istate , istate1 , istate2 ) allocate ( g2_istate ( nprocs )) if ( nprocs > 0 ) read ( 1 ) g2_istate close ( 1 ) !Change back to working directory call chdir ( num % cwd ) !Allocate and initialize quantities related to transition probabilities allocate ( Y_istate ( nprocs )) allocate ( istate1 ( nprocs ), istate2 ( nprocs )) istate1 (:) = - 1_k8 istate2 (:) = - 1_k8 Y_istate (:) = 0.0_dp end if !Initialize process counter count = 0 !Run over initial (in-window, FBZ blocks) electron wave vectors do ik = 1 , el % nk !Initial wave vector (crystal coords.) k = el % wavevecs ( ik , :) !Convert from crystal to 0-based index vector k_indvec = nint ( k * el % kmesh ) !Find final electron wave vector kp_indvec = modulo ( k_indvec + el % mesh_ref_array * q_indvec , el % kmesh ) !0-based index vector !Muxed index of kp ikp = mux_vector ( kp_indvec , el % kmesh , 0_k8 ) !Check if final electron wave vector is within energy window call binsearch ( el % indexlist , ikp , ikp_window ) if ( ikp_window < 0 ) cycle !Run over initial electron bands do m = 1 , el % numbands !Energy of initial electron en_el = el % ens ( ik , m ) !Apply energy window to initial electron if ( abs ( en_el - el % enref ) > el % fsthick ) cycle !Fermi factor for initial and final electrons if ( key == 'Y' ) then fermi1 = Fermi ( en_el , el % chempot , crys % T ) fermi2 = Fermi ( en_el + en_ph , el % chempot , crys % T ) end if !Run over final electron bands do n = 1 , el % numbands !Energy of final electron en_elp = el % ens ( ikp_window , n ) !Apply energy window to final electron if ( abs ( en_elp - el % enref ) > el % fsthick ) cycle !Increment g2 process counter count = count + 1 if ( key == 'g' ) then !Calculate |g_mns(k,<q>)|&#94;2 g2_istate ( count ) = wann % g2_epw ( crys , k , q , el % evecs ( ik , m , :), & el % evecs ( ikp_window , n , :), ph % evecs ( iq_fbz , s , :), & ph % ens ( iq_fbz , s ), gReq_iq , 'el' ) end if if ( key == 'Y' ) then !Calculate Y: !Evaluate delta function if ( num % tetrahedra ) then delta = delta_fn_tetra ( en_elp - en_ph , ik , m , el % kmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( en_elp - en_ph , ik , m , el % kmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if !Temperature dependent occupation factor occup_fac = fermi1 * ( 1.0_dp - fermi2 ) * invboseplus1 !Save Y if ( en_ph >= 0.5e-3 ) then !Use a small phonon energy cut-off Y_istate ( count ) = g2_istate ( count ) * occup_fac * delta end if !Save initial and final electron states istate1 ( count ) = mux_state ( el % numbands , m , ik ) istate2 ( count ) = mux_state ( el % numbands , n , ikp_window ) end if end do !n end do !m end do !ik if ( key == 'g' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'gq2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) g2_istate ( 1 : count ) close ( 1 ) end if if ( key == 'Y' ) then !Multiply constant factor, unit factor, etc. Y_istate ( 1 : count ) = const * Y_istate ( 1 : count ) !THz !Change to data output directory call chdir ( trim ( adjustl ( num % Ydir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'Y.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) Y_istate ( 1 : count ) write ( 1 ) istate1 ( 1 : count ) write ( 1 ) istate2 ( 1 : count ) close ( 1 ) end if !Change back to working directory call chdir ( num % cwd ) if ( key == 'Y' ) deallocate ( g2_istate , Y_istate , istate1 , istate2 ) end do sync all if ( key == 'g' ) then !Delete the gReq disk data if ( this_image () == 1 ) then call chdir ( trim ( adjustl ( num % g2dir ))) call system ( 'rm gReq.*' ) call chdir ( num % cwd ) end if end if sync all end subroutine calculate_eph_interaction_ibzq subroutine calculate_eph_interaction_ibzk ( wann , crys , el , ph , num , key ) !! Parallel driver of g2(k,q) over IBZ electron states. !! !! This subroutine will calculate the full Bloch rep. matrix elements for !! all the energy window restricted electron-phonon processes for a given !! irreducible initial electron state = (band, wave vector). !! This list will be written to disk in files tagged with the muxed state index. !! !! key = 'g', 'X' for vertex, transition probability calculation, respectively. ! !In the FBZ and IBZ blocks a wave vector was retained when at least one !band belonged within the energy window. Here the bands outside the energy !window will be skipped in the calculation as they are irrelevant for transport. type ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys type ( electron ), intent ( in ) :: el type ( phonon ), intent ( in ) :: ph type ( numerics ), intent ( in ) :: num character ( len = 1 ), intent ( in ) :: key !Local variables integer ( k8 ) :: nstates_irred , istate , m , ik , n , ikp , s , & iq , start , end , chunk , k_indvec ( 3 ), kp_indvec ( 3 ), & q_indvec ( 3 ), count , nprocs , num_active_images real ( dp ) :: k ( 3 ), kp ( 3 ), q ( 3 ), ph_ens_iq ( 1 , ph % numbranches ), qlist ( 1 , 3 ), & const , bosefac , fermi_minus_fac , fermi_plus_fac , en_ph , en_el , delta , occup_fac real ( dp ), allocatable :: g2_istate (:), Xplus_istate (:), Xminus_istate (:) integer ( k8 ), allocatable :: istate_el (:), istate_ph (:) complex ( dp ) :: gkRp_ik ( wann % numwannbands , wann % numwannbands , wann % numbranches , wann % nwsq ), & ph_evecs_iq ( 1 , ph % numbranches , ph % numbranches ) character ( len = 1024 ) :: filename logical :: needfinephon if ( key /= 'g' . and . key /= 'X' ) then call exit_with_message (& \"Invalid value of key in call to calculate_eph_interaction_ibzk. Exiting.\" ) end if if ( key == 'g' ) then call print_message ( \"Calculating g(k,Rp) -> |g(k,q)|&#94;2 for all IBZ electrons...\" ) else call print_message ( \"Calculating e-ph transition probabilities for all IBZ electrons...\" ) end if !Allocate and initialize g2_istate if ( key == 'g' ) then !Length of g2_istate nprocs = el % nstates_inwindow * wann % numbranches allocate ( g2_istate ( nprocs )) g2_istate (:) = 0.0_dp end if !Conversion factor in transition probability expression const = twopi / hbar_eVps !Total number of IBZ blocks states nstates_irred = el % nk_irred * wann % numwannbands call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" #states = \" , nstates_irred write ( * , \"(A, I10)\" ) \" #states/image = \" , chunk end if do istate = start , end !over IBZ blocks states !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , wann % numwannbands , m , ik ) if ( key == 'g' ) then !Load gkRp(ik) here for use inside the loops below call chdir ( trim ( adjustl ( num % g2dir ))) write ( filename , '(I6)' ) ik filename = 'gkRp.ik' // trim ( adjustl ( filename )) open ( 1 , file = filename , status = \"old\" , access = 'stream' ) read ( 1 ) gkRp_ik close ( 1 ) call chdir ( num % cwd ) end if !Get the muxed index of FBZ wave vector from the IBZ blocks index list !ik_fbz = el%indexlist_irred(ik) !Electron energy en_el = el % ens_irred ( ik , m ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( en_el - el % enref ) > el % fsthick ) cycle !Initial (IBZ blocks) wave vector (crystal coords.) k = el % wavevecs_irred ( ik , :) !Convert from crystal to 0-based index vector k_indvec = nint ( k * el % kmesh ) !Load g2_istate from disk for scattering rates calculation if ( key == 'X' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Read data in binary format write ( filename , '(I9)' ) istate filename = 'gk2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'old' , access = 'stream' ) read ( 1 ) nprocs if ( allocated ( g2_istate )) deallocate ( g2_istate , Xplus_istate , Xminus_istate , & istate_el , istate_ph ) allocate ( g2_istate ( nprocs )) if ( nprocs > 0 ) read ( 1 ) g2_istate close ( 1 ) !Change back to working directory call chdir ( num % cwd ) !Allocate and initialize quantities related to transition probabilities allocate ( Xplus_istate ( nprocs ), Xminus_istate ( nprocs )) allocate ( istate_el ( nprocs ), istate_ph ( nprocs )) istate_el (:) = 0_k8 istate_ph (:) = 0_k8 Xplus_istate (:) = 0.0_dp Xminus_istate (:) = 0.0_dp end if !Initialize eligible process counter for this state count = 0 !Run over final (FBZ blocks) electron wave vectors do ikp = 1 , el % nk !Final wave vector (crystal coords.) kp = el % wavevecs ( ikp , :) !Convert from crystal to 0-based index vector kp_indvec = nint ( kp * el % kmesh ) !Find interacting phonon wave vector !Note that q, k, and k' are all on the same mesh q_indvec = kp_indvec - k_indvec needfinephon = . false . if ( any ( mod ( q_indvec (:), el % mesh_ref_array ) /= 0_k8 )) then needfinephon = . true . q_indvec = modulo ( q_indvec , el % kmesh ) !0-based index vector q = q_indvec / dble ( el % kmesh ) !crystal coords. !Muxed index of q iq = mux_vector ( q_indvec , el % kmesh , 0_k8 ) !Calculate the fine mesh phonon. qlist ( 1 , :) = q !This could be very slow: !call phonon_espresso(ph, crys, 1_k8, qlist, ph_ens_iq, ph_evecs_iq) !This is much faster: call wann % ph_wann_epw ( crys , 1_k8 , qlist , ph_ens_iq , ph_evecs_iq ) else !Original (coarser) mesh phonon q_indvec = modulo ( q_indvec / el % mesh_ref_array , ph % qmesh ) !0-based index vector q = q_indvec / dble ( ph % qmesh ) !crystal coords. !Muxed index of q iq = mux_vector ( q_indvec , ph % qmesh , 0_k8 ) end if !Run over final electron bands do n = 1 , wann % numwannbands !Apply energy window to final electron if ( abs ( el % ens ( ikp , n ) - el % enref ) > el % fsthick ) cycle !Run over phonon branches do s = 1 , wann % numbranches !Increment g2 processes counter count = count + 1 if ( key == 'g' ) then !Calculate |g_mns(<k>,q)|&#94;2 if ( needfinephon ) then g2_istate ( count ) = wann % g2_epw ( crys , k , q , el % evecs_irred ( ik , m , :), & el % evecs ( ikp , n , :), ph_evecs_iq ( 1 , s , :), & ph_ens_iq ( 1 , s ), gkRp_ik , 'ph' ) else g2_istate ( count ) = wann % g2_epw ( crys , k , q , el % evecs_irred ( ik , m , :), & el % evecs ( ikp , n , :), ph % evecs ( iq , s , :), & ph % ens ( iq , s ), gkRp_ik , 'ph' ) end if end if if ( key == 'X' ) then !Phonon energy if ( needfinephon ) then en_ph = ph_ens_iq ( 1 , s ) else en_ph = ph % ens ( iq , s ) end if !Bose and Fermi factors if ( en_ph /= 0.0_dp ) then bosefac = Bose ( en_ph , crys % T ) else bosefac = 0.0_dp end if fermi_plus_fac = Fermi ( en_el + en_ph , el % chempot , crys % T ) fermi_minus_fac = Fermi ( en_el - en_ph , el % chempot , crys % T ) !Calculate X+: !Evaulate delta function if ( num % tetrahedra ) then delta = delta_fn_tetra ( en_el + en_ph , ikp , n , el % kmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( en_el + en_ph , ikp , n , el % kmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if !Temperature dependent occupation factor occup_fac = bosefac + fermi_plus_fac !Save X+ if ( en_ph >= 0.5e-3 ) then !Use a small phonon energy cut-off Xplus_istate ( count ) = g2_istate ( count ) * occup_fac * delta end if !Calculate X-: !Evaulate delta function if ( num % tetrahedra ) then delta = delta_fn_tetra ( en_el - en_ph , ikp , n , el % kmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( en_el - en_ph , ikp , n , el % kmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if !Temperature dependent occupation factor occup_fac = 1.0_dp + bosefac - fermi_minus_fac !Save X- if ( en_ph >= 0.5e-3 ) then !Use a small phonon energy cut-off Xminus_istate ( count ) = g2_istate ( count ) * occup_fac * delta end if !Save final electron and interacting phonon states (same for + and -) istate_el ( count ) = mux_state ( el % numbands , n , ikp ) if ( needfinephon ) then !Write fine phonon index as negative so that the iterator !knows to interpolate phonon quantities at this wave vector. istate_ph ( count ) = - mux_state ( ph % numbranches , s , iq ) else istate_ph ( count ) = mux_state ( ph % numbranches , s , iq ) end if end if end do !s end do !n end do !ikp if ( key == 'g' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'gk2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) g2_istate close ( 1 ) end if if ( key == 'X' ) then !Multiply constant factor, unit factor, etc. Xplus_istate ( 1 : count ) = const * Xplus_istate ( 1 : count ) !THz Xminus_istate ( 1 : count ) = const * Xminus_istate ( 1 : count ) !THz !Change to data output directory call chdir ( trim ( adjustl ( num % Xdir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'Xplus.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) Xplus_istate ( 1 : count ) write ( 1 ) istate_el ( 1 : count ) write ( 1 ) istate_ph ( 1 : count ) close ( 1 ) write ( filename , '(I9)' ) istate filename = 'Xminus.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) Xminus_istate ( 1 : count ) write ( 1 ) istate_el ( 1 : count ) write ( 1 ) istate_ph ( 1 : count ) close ( 1 ) end if !Change back to working directory call chdir ( num % cwd ) if ( key == 'X' ) deallocate ( g2_istate , Xplus_istate , Xminus_istate , & istate_el , istate_ph ) end do sync all if ( key == 'g' ) then !Delete the gkRp disk data if ( this_image () == 1 ) then call chdir ( trim ( adjustl ( num % g2dir ))) call system ( 'rm gkRp.*' ) call chdir ( num % cwd ) endif end if sync all end subroutine calculate_eph_interaction_ibzk subroutine calculate_echimp_interaction_ibzk ( crys , el , num ) !! Parallel driver of |g_e-chimp(k,k')|&#94;2 over IBZ electron states. !! ! !In the FBZ and IBZ blocks a wave vector was retained when at least one !band belonged within the energy window. Here the bands outside the energy !window will be skipped in the calculation as they are irrelevant for transport. type ( crystal ), intent ( in ) :: crys type ( electron ), intent ( in ) :: el type ( numerics ), intent ( in ) :: num !Local variables integer ( k8 ) :: nstates_irred , istate , m , ik , n , ikp , & start , end , chunk , k_indvec ( 3 ), kp_indvec ( 3 ), & q_indvec ( 3 ), count , nprocs , num_active_images real ( dp ) :: k ( 3 ), kp ( 3 ), q_mag , const , en_el , delta , g2 real ( dp ), allocatable :: Xchimp_istate (:) integer ( k8 ), allocatable :: istate_el (:) character ( len = 1024 ) :: filename call print_message ( \"Calculating e-ch. imp. transition probabilities for all IBZ electrons...\" ) !Conversion factor in transition probability expression const = twopi / hbar_eVps !Length of nprocs = el % nstates_inwindow allocate ( Xchimp_istate ( nprocs ), istate_el ( nprocs )) Xchimp_istate (:) = 0.0_dp istate_el (:) = 0_k8 !Total number of IBZ blocks states nstates_irred = el % nk_irred * el % numbands call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" #states = \" , nstates_irred write ( * , \"(A, I10)\" ) \" #states/image = \" , chunk end if do istate = start , end !over IBZ blocks states !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , el % numbands , m , ik ) !Electron energy en_el = el % ens_irred ( ik , m ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( en_el - el % enref ) > el % fsthick ) cycle !Initial (IBZ blocks) wave vector (crystal coords.) k = el % wavevecs_irred ( ik , :) !Convert from crystal to 0-based index vector k_indvec = nint ( k * el % kmesh ) !Initialize eligible process counter for this state count = 0 !Run over final (FBZ blocks) electron wave vectors do ikp = 1 , el % nk !Final wave vector (crystal coords.) kp = el % wavevecs ( ikp , :) !Convert from crystal to 0-based index vector kp_indvec = nint ( kp * el % kmesh ) !Find interacting phonon wave vector !Note that q, k, and k' are all on the same mesh q_indvec = kp_indvec - k_indvec !0-based index vector !Calculate length of the wave vector q_mag = qdist ( q_indvec / dble ( el % kmesh ), crys % reclattvecs ) !Calculate matrix element g2 = gchimp2 ( el , crys , q_mag ) !Run over final electron bands do n = 1 , el % numbands !Apply energy window to final electron if ( abs ( el % ens ( ikp , n ) - el % enref ) > el % fsthick ) cycle !Increment g2 processes counter count = count + 1 !Evaulate delta function if ( num % tetrahedra ) then delta = delta_fn_tetra ( en_el , ikp , n , el % kmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( en_el , ikp , n , el % kmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if !Save Xchimp Xchimp_istate ( count ) = g2 * transfac ( matmul ( crys % reclattvecs , k ), & matmul ( crys % reclattvecs , kp )) * delta !Save final electron state istate_el ( count ) = mux_state ( el % numbands , n , ikp ) end do !n end do !ikp !Multiply constant factor, unit factor, etc. Xchimp_istate ( 1 : count ) = const * Xchimp_istate ( 1 : count ) !THz !Change to data output directory call chdir ( trim ( adjustl ( num % Xdir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'Xchimp.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) Xchimp_istate ( 1 : count ) write ( 1 ) istate_el ( 1 : count ) close ( 1 ) !Change back to working directory call chdir ( num % cwd ) end do sync all end subroutine calculate_echimp_interaction_ibzk subroutine calculate_ph_rta_rates ( rta_rates_3ph , rta_rates_phe , num , crys , ph , el ) !! Subroutine for parallel reading of the 3-ph and ph-e transition probabilities !! from disk and calculating the relaxation time approximation (RTA) !! scattering rates for the 3-ph and ph-e channels. real ( dp ), allocatable , intent ( out ) :: rta_rates_3ph (:,:) real ( dp ), allocatable , intent ( out ) :: rta_rates_phe (:,:) type ( numerics ), intent ( in ) :: num type ( crystal ), intent ( in ) :: crys type ( phonon ), intent ( in ) :: ph type ( electron ), intent ( in ), optional :: el !Local variables integer ( k8 ) :: nstates_irred , istate , nprocs_3ph_plus , nprocs_3ph_minus , & nprocs_phe , iproc , chunk , s , iq , num_active_images integer ( k8 ), allocatable :: start [:], end [:] real ( dp ), allocatable :: rta_rates_3ph_psum (:,:)[:], rta_rates_phe_psum (:,:)[:], & W (:), Y (:) character ( len = 1024 ) :: filepath_Wm , filepath_Wp , filepath_Y , tag !Set output directory of transition probilities write ( tag , \"(E9.3)\" ) crys % T !Total number of IBZ blocks states nstates_irred = ph % nq_irred * ph % numbranches !Allocate start and end coarrays allocate ( start [ * ], end [ * ]) !Divide phonon states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) !Allocate and initialize scattering rates coarrays allocate ( rta_rates_3ph_psum ( ph % nq_irred , ph % numbranches )[ * ]) rta_rates_3ph_psum (:, :) = 0.0_dp if ( present ( el )) then allocate ( rta_rates_phe_psum ( ph % nq_irred , ph % numbranches )[ * ]) rta_rates_phe_psum (:, :) = 0.0_dp end if !Allocate and initialize scattering rates allocate ( rta_rates_3ph ( ph % nq_irred , ph % numbranches ), rta_rates_phe ( ph % nq_irred , ph % numbranches )) rta_rates_3ph (:, :) = 0.0_dp rta_rates_phe (:, :) = 0.0_dp !Allocate transition probabilities variable !allocate(W(nprocs_3ph)) !Run over first phonon IBZ states do istate = start , end !Demux state index into branch (s) and wave vector (iq) indices call demux_state ( istate , ph % numbranches , s , iq ) !Set W+ filename write ( tag , '(I9)' ) istate filepath_Wp = trim ( adjustl ( num % Wdir )) // '/Wp.istate' // trim ( adjustl ( tag )) !Read W+ from file !call read_transition_probs_3ph(trim(adjustl(filepath_Wp)), W) if ( allocated ( W )) deallocate ( W ) call read_transition_probs_e ( trim ( adjustl ( filepath_Wp )), nprocs_3ph_plus , W ) do iproc = 1 , nprocs_3ph_plus rta_rates_3ph_psum ( iq , s ) = rta_rates_3ph_psum ( iq , s ) + W ( iproc ) end do !Set W- filename filepath_Wm = trim ( adjustl ( num % Wdir )) // '/Wm.istate' // trim ( adjustl ( tag )) !Read W- from file !call read_transition_probs_3ph(trim(adjustl(filepath_Wm)), W) if ( allocated ( W )) deallocate ( W ) call read_transition_probs_e ( trim ( adjustl ( filepath_Wm )), nprocs_3ph_minus , W ) do iproc = 1 , nprocs_3ph_minus rta_rates_3ph_psum ( iq , s ) = rta_rates_3ph_psum ( iq , s ) + 0.5_dp * W ( iproc ) end do if ( present ( el )) then !Set Y filename filepath_Y = trim ( adjustl ( num % Ydir )) // '/Y.istate' // trim ( adjustl ( tag )) !Read Y from file if ( allocated ( Y )) deallocate ( Y ) call read_transition_probs_e ( trim ( adjustl ( filepath_Y )), nprocs_phe , Y ) do iproc = 1 , nprocs_phe rta_rates_phe_psum ( iq , s ) = rta_rates_phe_psum ( iq , s ) + el % spindeg * Y ( iproc ) end do end if end do !Reduce coarray partial sums call co_sum ( rta_rates_3ph_psum ) rta_rates_3ph = rta_rates_3ph_psum if ( present ( el )) then call co_sum ( rta_rates_phe_psum ) rta_rates_phe = rta_rates_phe_psum end if end subroutine calculate_ph_rta_rates subroutine calculate_el_rta_rates ( rta_rates_eph , rta_rates_echimp , num , crys , el ) !! Subroutine for parallel reading of the e-ph transition probabilities !! from disk and calculating the relaxation time approximation (RTA) !! scattering rates for the e-ph channel. real ( dp ), allocatable , intent ( out ) :: rta_rates_eph (:,:), rta_rates_echimp (:,:) type ( numerics ), intent ( in ) :: num type ( crystal ), intent ( in ) :: crys type ( electron ), intent ( in ) :: el !Local variables integer ( k8 ) :: nstates_irred , istate , nprocs_eph , & iproc , chunk , m , ik , num_active_images integer ( k8 ), allocatable :: start [:], end [:] real ( dp ), allocatable :: rta_rates_eph_psum (:,:)[:], & rta_rates_echimp_psum (:,:)[:], X (:) character ( len = 1024 ) :: filepath_Xp , filepath_Xm , tag !Set output directory of transition probilities write ( tag , \"(E9.3)\" ) crys % T !Total number of IBZ blocks states nstates_irred = el % nk_irred * el % numbands !Allocate start and end coarrays allocate ( start [ * ], end [ * ]) !Divide phonon states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) !Allocate and initialize scattering rates coarrays allocate ( rta_rates_eph_psum ( el % nk_irred , el % numbands )[ * ]) rta_rates_eph_psum (:, :) = 0.0_dp if ( num % elchimp ) then allocate ( rta_rates_echimp_psum ( el % nk_irred , el % numbands )[ * ]) rta_rates_echimp_psum (:, :) = 0.0_dp end if !Allocate and initialize scattering rates allocate ( rta_rates_eph ( el % nk_irred , el % numbands )) rta_rates_eph (:, :) = 0.0_dp allocate ( rta_rates_echimp ( el % nk_irred , el % numbands )) rta_rates_echimp (:, :) = 0.0_dp do istate = start , end !over IBZ blocks states !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , el % numbands , m , ik ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( el % ens_irred ( ik , m ) - el % enref ) > el % fsthick ) cycle !Set X+ filename write ( tag , '(I9)' ) istate filepath_Xp = trim ( adjustl ( num % Xdir )) // '/Xplus.istate' // trim ( adjustl ( tag )) !Read X+ from file if ( allocated ( X )) deallocate ( X ) call read_transition_probs_e ( trim ( adjustl ( filepath_Xp )), nprocs_eph , X ) do iproc = 1 , nprocs_eph rta_rates_eph_psum ( ik , m ) = rta_rates_eph_psum ( ik , m ) + X ( iproc ) end do !Set X- filename write ( tag , '(I9)' ) istate filepath_Xm = trim ( adjustl ( num % Xdir )) // '/Xminus.istate' // trim ( adjustl ( tag )) !Read X- from file if ( allocated ( X )) deallocate ( X ) call read_transition_probs_e ( trim ( adjustl ( filepath_Xm )), nprocs_eph , X ) do iproc = 1 , nprocs_eph rta_rates_eph_psum ( ik , m ) = rta_rates_eph_psum ( ik , m ) + X ( iproc ) end do if ( num % elchimp ) then !Set Xchimp filename write ( tag , '(I9)' ) istate filepath_Xm = trim ( adjustl ( num % Xdir )) // '/Xchimp.istate' // trim ( adjustl ( tag )) !Read Xchimp from file if ( allocated ( X )) deallocate ( X ) call read_transition_probs_e ( trim ( adjustl ( filepath_Xm )), nprocs_eph , X ) do iproc = 1 , nprocs_eph rta_rates_echimp_psum ( ik , m ) = rta_rates_echimp_psum ( ik , m ) + X ( iproc ) end do end if end do !Reduce coarray partial sums call co_sum ( rta_rates_eph_psum ) rta_rates_eph = rta_rates_eph_psum if ( num % elchimp ) then call co_sum ( rta_rates_echimp_psum ) rta_rates_echimp = rta_rates_echimp_psum end if end subroutine calculate_el_rta_rates subroutine read_transition_probs_e ( filepath , N , TP , istate1 , istate2 ) !! Subroutine to read transition probabilities from disk for interaction processes. character ( len = * ), intent ( in ) :: filepath integer ( k8 ), intent ( out ) :: N real ( dp ), allocatable , intent ( out ) :: TP (:) integer ( k8 ), allocatable , intent ( out ), optional :: istate1 (:), istate2 (:) !Read data open ( 1 , file = trim ( adjustl ( filepath )), status = 'old' , access = 'stream' ) read ( 1 ) N allocate ( TP ( N )) if ( N > 0 ) read ( 1 ) TP if ( present ( istate1 )) then allocate ( istate1 ( N )) if ( N > 0 ) then read ( 1 ) istate1 end if if ( present ( istate2 )) then allocate ( istate2 ( N )) if ( N > 0 ) then read ( 1 ) istate2 end if end if end if close ( 1 ) end subroutine read_transition_probs_e end module interactions","tags":"","loc":"sourcefile/interactions.f90.html"},{"title":"misc.f90 – elphbolt","text":"This file depends on sourcefile~~misc.f90~~EfferentGraph sourcefile~misc.f90 misc.f90 sourcefile~params.f90 params.f90 sourcefile~misc.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~misc.f90~~AfferentGraph sourcefile~misc.f90 misc.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~interactions.f90->sourcefile~misc.f90 sourcefile~numerics.f90 numerics.f90 sourcefile~interactions.f90->sourcefile~numerics.f90 sourcefile~electron.f90 electron.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~crystal.f90 crystal.f90 sourcefile~interactions.f90->sourcefile~crystal.f90 sourcefile~wannier.f90 wannier.f90 sourcefile~interactions.f90->sourcefile~wannier.f90 sourcefile~delta.f90 delta.f90 sourcefile~interactions.f90->sourcefile~delta.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 sourcefile~numerics.f90->sourcefile~misc.f90 sourcefile~numerics.f90->sourcefile~crystal.f90 sourcefile~electron.f90->sourcefile~misc.f90 sourcefile~electron.f90->sourcefile~numerics.f90 sourcefile~electron.f90->sourcefile~crystal.f90 sourcefile~electron.f90->sourcefile~wannier.f90 sourcefile~symmetry.f90 symmetry.f90 sourcefile~electron.f90->sourcefile~symmetry.f90 sourcefile~electron.f90->sourcefile~delta.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~bz_sums.f90->sourcefile~misc.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 sourcefile~bz_sums.f90->sourcefile~crystal.f90 sourcefile~bz_sums.f90->sourcefile~symmetry.f90 sourcefile~bz_sums.f90->sourcefile~delta.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 sourcefile~bte.f90 bte.f90 sourcefile~bte.f90->sourcefile~misc.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~bte.f90->sourcefile~numerics.f90 sourcefile~bte.f90->sourcefile~electron.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~bte.f90->sourcefile~crystal.f90 sourcefile~bte.f90->sourcefile~symmetry.f90 sourcefile~bte.f90->sourcefile~phonon.f90 sourcefile~crystal.f90->sourcefile~misc.f90 sourcefile~wannier.f90->sourcefile~misc.f90 sourcefile~wannier.f90->sourcefile~numerics.f90 sourcefile~wannier.f90->sourcefile~crystal.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~misc.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90->sourcefile~numerics.f90 sourcefile~elphbolt.f90->sourcefile~electron.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 sourcefile~elphbolt.f90->sourcefile~crystal.f90 sourcefile~elphbolt.f90->sourcefile~wannier.f90 sourcefile~elphbolt.f90->sourcefile~symmetry.f90 sourcefile~elphbolt.f90->sourcefile~phonon.f90 sourcefile~symmetry.f90->sourcefile~misc.f90 sourcefile~symmetry.f90->sourcefile~crystal.f90 sourcefile~delta.f90->sourcefile~misc.f90 sourcefile~phonon.f90->sourcefile~misc.f90 sourcefile~phonon.f90->sourcefile~numerics.f90 sourcefile~phonon.f90->sourcefile~crystal.f90 sourcefile~phonon.f90->sourcefile~wannier.f90 sourcefile~phonon.f90->sourcefile~symmetry.f90 sourcefile~phonon.f90->sourcefile~delta.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules misc Source Code misc.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module misc !! Module containing miscellaneous math and numerics related functions and subroutines. use params , only : dp , k8 , kB implicit none public private :: sort_int , sort_real interface sort module procedure :: sort_int , sort_real end interface sort contains subroutine linspace ( grid , min , max , num ) !! Create equidistant grid. real ( dp ), allocatable , intent ( out ) :: grid (:) real ( dp ), intent ( in ) :: min , max integer ( k8 ), intent ( in ) :: num !Local variables integer ( k8 ) :: i real ( dp ) :: spacing !Allocate grid array allocate ( grid ( num )) !Calculate grid spacing spacing = ( max - min ) / dble ( num - 1 ) !Calculate grid do i = 1 , num grid ( i ) = min + ( i - 1 ) * spacing end do end subroutine linspace subroutine exit_with_message ( message ) !! Exit with error message. character ( len = * ), intent ( in ) :: message if ( this_image () == 1 ) then write ( * , \"(A)\" ) trim ( message ) stop end if end subroutine exit_with_message subroutine print_message ( message ) !! Print message. character ( len = * ), intent ( in ) :: message if ( this_image () == 1 ) write ( * , \"(A)\" ) trim ( message ) end subroutine print_message subroutine write2file_rank2_real ( filename , data ) !! Write rank-2 data to file. character ( len = * ), intent ( in ) :: filename real ( dp ), intent ( in ) :: data (:,:) integer ( k8 ) :: ik , nk character ( len = 1024 ) :: numcols nk = size ( data (:, 1 )) write ( numcols , \"(I0)\" ) size ( data ( 1 , :)) if ( this_image () == 1 ) then open ( 1 , file = trim ( filename ), status = \"replace\" ) do ik = 1 , nk write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & data ( ik , :) end do close ( 1 ) end if sync all end subroutine write2file_rank2_real subroutine write2file_rank3_real ( filename , data ) !! Write rank-3 data to file. character ( len = * ), intent ( in ) :: filename real ( dp ), intent ( in ) :: data (:,:,:) integer ( k8 ) :: ik , nk character ( len = 1024 ) :: numcols nk = size ( data (:, 1 , 1 )) write ( numcols , \"(I0)\" ) size ( data ( 1 , :, 1 )) * size ( data ( 1 , 1 , :)) if ( this_image () == 1 ) then open ( 1 , file = trim ( filename ), status = \"replace\" ) do ik = 1 , nk write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & data ( ik , :, :) end do close ( 1 ) end if end subroutine write2file_rank3_real subroutine write2file_response ( filename , data , bandlist ) !! Write list of vectors to band/branch resolved files. character ( len = * ), intent ( in ) :: filename real ( dp ), intent ( in ) :: data (:,:,:) integer ( k8 ), intent ( in ), optional :: bandlist (:) !Local variables integer ( k8 ) :: ib , ibstart , ibend , nb , ik , nk , dim character ( len = 1 ) :: numcols character ( len = 1024 ) :: bandtag real ( dp ), allocatable :: aux (:,:) if ( this_image () == 1 ) then nk = size ( data (:, 1 , 1 )) if ( present ( bandlist )) then nb = size ( bandlist ) ibstart = bandlist ( 1 ) ibend = bandlist ( nb ) else nb = size ( data ( 1 , :, 1 )) ibstart = 1 ibend = nb end if dim = size ( data ( 1 , 1 , :)) write ( numcols , \"(I0)\" ) dim !Band/branch summed open ( 1 , file = trim ( filename // \"tot\" ), status = \"replace\" ) allocate ( aux ( nk , 3 )) aux = sum ( data , dim = 2 ) do ik = 1 , nk write ( 1 , \"(3(1E20.10),x)\" ) aux ( ik , :) end do close ( 1 ) !Band/branch resolved do ib = ibstart , ibend write ( bandtag , \"(I0)\" ) ib open ( 2 , file = trim ( filename // bandtag ), status = \"replace\" ) do ik = 1 , nk write ( 2 , \"(3(1E20.10),x)\" ) data ( ik , ib , :) end do close ( 2 ) end do end if sync all end subroutine write2file_response subroutine readfile_response ( filename , data , bandlist ) !! Read list of vectors to band/branch resolved files. character ( len = * ), intent ( in ) :: filename real ( dp ), intent ( out ) :: data (:,:,:) integer ( k8 ), intent ( in ), optional :: bandlist (:) !Local variables integer ( k8 ) :: ib , ibstart , ibend , nb , ik , nk , dim character ( len = 1 ) :: numcols character ( len = 1024 ) :: bandtag nk = size ( data (:, 1 , 1 )) if ( present ( bandlist )) then nb = size ( bandlist ) ibstart = bandlist ( 1 ) ibend = bandlist ( nb ) else nb = size ( data ( 1 , :, 1 )) ibstart = 1 ibend = nb end if dim = size ( data ( 1 , 1 , :)) write ( numcols , \"(I0)\" ) dim !Band/branch resolved do ib = ibstart , ibend write ( bandtag , \"(I0)\" ) ib open ( 1 , file = trim ( filename // bandtag ), status = \"old\" ) do ik = 1 , nk read ( 1 , * ) data ( ik , ib , :) end do close ( 1 ) end do sync all end subroutine readfile_response subroutine append2file_transport_tensor ( filename , it , data , bandlist ) !! Append 3x3 tensor to band/branch resolved files. character ( len = * ), intent ( in ) :: filename integer ( k8 ), intent ( in ) :: it real ( dp ), intent ( in ) :: data (:,:,:) integer ( k8 ), intent ( in ), optional :: bandlist (:) !Local variables integer ( k8 ) :: ib , nb , ibstart , ibend character ( len = 1 ) :: numcols character ( len = 1024 ) :: bandtag if ( this_image () == 1 ) then if ( present ( bandlist )) then nb = size ( bandlist ) ibstart = bandlist ( 1 ) ibend = bandlist ( nb ) else nb = size ( data (:, 1 , 1 )) ibstart = 1 ibend = nb end if write ( numcols , \"(I0)\" ) 9 !Band/branch summed if ( it == 0 ) then open ( 1 , file = trim ( filename // \"tot\" ), status = \"replace\" ) else open ( 1 , file = trim ( filename // \"tot\" ), access = \"append\" , status = \"old\" ) end if write ( 1 , \"(I3, \" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & it , sum ( data , dim = 1 ) close ( 1 ) !Band/branch resolved do ib = ibstart , ibend write ( bandtag , \"(I0)\" ) ib if ( it == 0 ) then open ( 2 , file = trim ( filename // bandtag ), status = \"replace\" ) else open ( 2 , file = trim ( filename // bandtag ), access = \"append\" , status = \"old\" ) end if write ( 2 , \"(I3, \" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & it , data ( ib , :, :) close ( 2 ) end do end if sync all end subroutine append2file_transport_tensor subroutine write2file_spectral_tensor ( filename , data , bandlist ) !! Append 3x3 spectral transport tensor to band/branch resolved files. character ( len = * ), intent ( in ) :: filename real ( dp ), intent ( in ) :: data (:,:,:,:) integer ( k8 ), intent ( in ), optional :: bandlist (:) !Local variables integer ( k8 ) :: ie , ne , ib , nb , ibstart , ibend character ( len = 1 ) :: numcols character ( len = 1024 ) :: bandtag real ( dp ) :: aux ( 3 , 3 ) if ( this_image () == 1 ) then !Number of energy points on grid ne = size ( data ( 1 , 1 , 1 , :)) !Number of bands/branches and bounds if ( present ( bandlist )) then nb = size ( bandlist ) ibstart = bandlist ( 1 ) ibend = bandlist ( nb ) else nb = size ( data (:, 1 , 1 , 1 )) ibstart = 1 ibend = nb end if write ( numcols , \"(I0)\" ) 9 !Band/branch summed open ( 1 , file = trim ( filename // \"tot\" ), status = \"replace\" ) do ie = 1 , ne aux = 0.0_dp do ib = ibstart , ibend aux (:,:) = aux (:,:) + data ( ib , :, :, ie ) end do write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) aux end do close ( 1 ) !Band/branch resolved do ib = ibstart , ibend write ( bandtag , \"(I0)\" ) ib open ( 2 , file = trim ( filename // bandtag ), status = \"replace\" ) do ie = 1 , ne write ( 2 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & data ( ib , :, :, ie ) end do close ( 2 ) end do end if sync all end subroutine write2file_spectral_tensor subroutine int_div ( num , denom , q , r ) !! Quotient(q) and remainder(r) of the integer division num/denom. integer ( k8 ), intent ( in ) :: num , denom integer ( k8 ), intent ( out ) :: q , r q = num / denom r = mod ( num , denom ) end subroutine int_div subroutine distribute_points ( npts , chunk , istart , iend , num_active_images ) !! Distribute points among processes integer ( k8 ), intent ( in ) :: npts integer ( k8 ), intent ( out ) :: chunk , istart , iend , num_active_images !Number of active images num_active_images = min ( npts , num_images ()) !Number of points per process chunk = ceiling ( dble ( npts ) / num_images ()) !Start index istart = ( this_image () - 1 ) * chunk + 1 !End index iend = min ( chunk * this_image (), npts ) !Update chunk if ( istart < iend ) then chunk = iend - istart + 1 else chunk = 1 end if end subroutine distribute_points function cross_product ( A , B ) !! Cross product of A and B. real ( dp ), intent ( in ) :: A ( 3 ), B ( 3 ) real ( dp ) :: cross_product ( 3 ) cross_product ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) cross_product ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) cross_product ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) end function cross_product pure complex ( dp ) function expi ( x ) !! Calculate exp(i*x) = cos(x) + isin(x) real ( dp ), intent ( in ) :: x !expi = cmplx(cos(x), sin(x)) expi = cmplx ( cos ( x ), sin ( x ), dp ) end function expi pure real ( dp ) function twonorm ( v ) !! 2-norm of a vector real ( dp ), intent ( in ) :: v (:) integer ( k8 ) :: i , s s = size ( v ) twonorm = 0.0_dp do i = 1 , s twonorm = v ( i ) ** 2 + twonorm end do twonorm = sqrt ( twonorm ) end function twonorm pure real ( dp ) function trace ( mat ) !! Trace of square matrix real ( dp ), intent ( in ) :: mat (:,:) integer ( k8 ) :: i , dim dim = size ( mat (:, 1 )) trace = 0.0_dp do i = 1 , dim trace = trace + mat ( i , i ) end do end function trace subroutine sort_int ( list ) !! Swap sort list of integers integer ( k8 ), intent ( inout ) :: list (:) integer ( k8 ) :: i , j , n integer ( k8 ) :: aux , tmp n = size ( list ) do i = 1 , n aux = list ( i ) do j = i + 1 , n if ( aux > list ( j )) then tmp = list ( j ) list ( j ) = aux list ( i ) = tmp aux = tmp end if end do end do end subroutine sort_int subroutine sort_real ( list ) !! Swap sort list of reals real ( dp ), intent ( inout ) :: list (:) real ( kind = 8 ) :: aux , tmp integer ( k8 ) :: i , j , n n = size ( list ) do i = 1 , n aux = list ( i ) do j = i + 1 , n if ( aux > list ( j )) then tmp = list ( j ) list ( j ) = aux list ( i ) = tmp aux = tmp end if end do end do end subroutine sort_real subroutine binsearch ( array , e , m ) !! Binary search in a list of integers and return index. integer ( k8 ), intent ( in ) :: array (:), e integer ( k8 ), intent ( out ) :: m integer ( k8 ) :: a , b , mid a = 1 b = size ( array ) m = ( b + a ) / 2 mid = array ( m ) do while ( mid /= e ) if ( e > mid ) then a = m + 1 else if ( e < mid ) then b = m - 1 end if if ( a > b ) then m = - 1 exit end if m = ( b + a ) / 2 mid = array ( m ) end do end subroutine binsearch function mux_vector ( v , mesh , base ) !! Multiplex index of a single wave vector. !! v is the demultiplexed triplet of a wave vector. !! i is the multiplexed index of a wave vector (always 1-based). !! mesh is the number of wave vectors along the three reciprocal lattice vectors. !! base states whether v has 0- or 1-based indexing. integer ( k8 ), intent ( in ) :: v ( 3 ), mesh ( 3 ), base integer ( k8 ) :: mux_vector if ( base < 0 . or . base > 1 ) then call exit_with_message ( \"Base has to be either 0 or 1 in misc.f90:mux_vector\" ) end if if ( base == 0 ) then mux_vector = ( v ( 3 ) * mesh ( 2 ) + v ( 2 )) * mesh ( 1 ) + v ( 1 ) + 1 else mux_vector = (( v ( 3 ) - 1 ) * mesh ( 2 ) + ( v ( 2 ) - 1 )) * mesh ( 1 ) + v ( 1 ) end if end function mux_vector subroutine demux_vector ( i , v , mesh , base ) !! Demultiplex index of a single wave vector. !! i is the multiplexed index of a wave vector (always 1-based). !! v is the demultiplexed triplet of a wave vector. !! mesh is the number of wave vectors along the three reciprocal lattice vectors. !! base chooses whether v has 0- or 1-based indexing. integer ( k8 ), intent ( in ) :: i , mesh ( 3 ), base integer ( k8 ), intent ( out ) :: v ( 3 ) integer ( k8 ) :: aux if ( base < 0 . or . base > 1 ) then call exit_with_message ( \"Base has to be either 0 or 1 in misc.f90:demux_vector\" ) end if call int_div ( i - 1 , mesh ( 1 ), aux , v ( 1 )) call int_div ( aux , mesh ( 2 ), v ( 3 ), v ( 2 )) if ( base == 1 ) then v ( 1 ) = v ( 1 ) + 1 v ( 2 ) = v ( 2 ) + 1 v ( 3 ) = v ( 3 ) + 1 end if end subroutine demux_vector subroutine demux_mesh ( index_mesh , nmesh , mesh , base , indexlist ) !! Demultiplex all wave vector indices !! (optionally, from a list of indices). !! Internally uses demux_vector. integer ( k8 ), intent ( in ) :: nmesh , mesh ( 3 ), base integer ( k8 ), optional , intent ( in ) :: indexlist ( nmesh ) integer ( k8 ), intent ( out ) :: index_mesh ( 3 , nmesh ) integer ( k8 ) :: i do i = 1 , nmesh !over total number of wave vectors if ( present ( indexlist )) then call demux_vector ( indexlist ( i ), index_mesh (:, i ), mesh , base ) else call demux_vector ( i , index_mesh (:, i ), mesh , base ) end if end do end subroutine demux_mesh pure integer ( k8 ) function mux_state ( nbands , iband , ik ) !! Multiplex a (band index, wave vector index) pair into a state index !! !! nbands is the number of bands !! iband is the band index !! ik is the wave vector index integer ( k8 ), intent ( in ) :: nbands , ik , iband mux_state = ( ik - 1 ) * nbands + iband end function mux_state subroutine demux_state ( m , nbands , iband , ik ) !! Demultiplex a state index into (band index, wave vector index) pair !! !! m is the multiplexed state index !! nbands is the number of bands !! iband is the band index !! ik is the wave vector index integer ( k8 ), intent ( in ) :: m , nbands integer ( k8 ), intent ( out ) :: ik , iband iband = modulo ( m - 1 , nbands ) + 1 ik = int (( m - 1 ) / nbands ) + 1 end subroutine demux_state pure real ( dp ) function Bose ( e , T ) !! e Energy in eV !! T temperature in K real ( dp ), intent ( in ) :: e , T Bose = 1.0_dp / ( exp ( e / kB / T ) - 1.0_dp ) end function Bose pure real ( dp ) function Fermi ( e , chempot , T ) !! e Energy in eV !! chempot Chemical potential in eV !! T temperature in K real ( dp ), intent ( in ) :: e , chempot , T Fermi = 1.0_dp / ( exp (( e - chempot ) / kB / T ) + 1.0_dp ) end function Fermi subroutine interpolate ( coarsemesh , refinement , f , q , interpolation ) !! Subroutine to perform BZ interpolation. !! !! coarsemesh The coarse mesh. !! refinement The mesh refinement factor. !! f The coarse mesh function to be interpolated. !! q The 0-based index vector where to evaluate f. !! interpolation The result integer ( k8 ), intent ( in ) :: coarsemesh ( 3 ), q ( 3 ), refinement ( 3 ) real ( dp ), intent ( in ) :: f (:) real ( dp ), intent ( out ) :: interpolation integer ( k8 ) :: info , r0 ( 3 ), r1 ( 3 ), ipol , mode , count integer ( k8 ), allocatable :: pivot (:) integer ( k8 ) :: i000 , i100 , i010 , i110 , i001 , i101 , i011 , i111 , equalpol real ( dp ) :: x0 , x1 , y0 , y1 , z0 , z1 , x , y , z , v ( 2 ), v0 ( 2 ), v1 ( 2 ) real ( dp ), allocatable :: T (:, :), c (:) real ( dp ) :: aux aux = 0.0_dp equalpol = 0_k8 !Find on the coarse mesh the two diagonals. r0 = modulo ( floor ( q / dble ( refinement )), coarsemesh ) r1 = modulo ( ceiling ( q / dble ( refinement )), coarsemesh ) mode = 0 do ipol = 1 , 3 if ( r1 ( ipol ) == r0 ( ipol )) then mode = mode + 1 end if end do !mode = 0: 3d interpolation !mode = 1: 2d interpolation !mode = 2: 1d interpolation if ( mode == 0 ) then !3d allocate ( pivot ( 8 ), T ( 8 , 8 ), c ( 8 )) !Fine mesh point x = q ( 1 ) / dble ( refinement ( 1 ) * coarsemesh ( 1 )) y = q ( 2 ) / dble ( refinement ( 2 ) * coarsemesh ( 2 )) z = q ( 3 ) / dble ( refinement ( 3 ) * coarsemesh ( 3 )) !Coarse mesh walls x0 = floor ( q ( 1 ) / dble ( refinement ( 1 ))) / dble ( coarsemesh ( 1 )) y0 = floor ( q ( 2 ) / dble ( refinement ( 2 ))) / dble ( coarsemesh ( 2 )) z0 = floor ( q ( 3 ) / dble ( refinement ( 3 ))) / dble ( coarsemesh ( 3 )) x1 = ceiling ( q ( 1 ) / dble ( refinement ( 1 ))) / dble ( coarsemesh ( 1 )) y1 = ceiling ( q ( 2 ) / dble ( refinement ( 2 ))) / dble ( coarsemesh ( 2 )) z1 = ceiling ( q ( 3 ) / dble ( refinement ( 3 ))) / dble ( coarsemesh ( 3 )) !Coarse mesh corners i000 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 i010 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i110 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 i001 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i101 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 i011 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i111 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 !Evaluate functions at the corners and form rhs c = ( / f ( i000 ), f ( i100 ), f ( i010 ), f ( i110 ),& f ( i001 ), f ( i101 ), f ( i011 ), f ( i111 ) / ) !Form the transformation matrix T T ( 1 ,:) = ( / 1.0_dp , x0 , y0 , z0 , x0 * y0 , x0 * z0 , y0 * z0 , x0 * y0 * z0 / ) T ( 2 ,:) = ( / 1.0_dp , x1 , y0 , z0 , x1 * y0 , x1 * z0 , y0 * z0 , x1 * y0 * z0 / ) T ( 3 ,:) = ( / 1.0_dp , x0 , y1 , z0 , x0 * y1 , x0 * z0 , y1 * z0 , x0 * y1 * z0 / ) T ( 4 ,:) = ( / 1.0_dp , x1 , y1 , z0 , x1 * y1 , x1 * z0 , y1 * z0 , x1 * y1 * z0 / ) T ( 5 ,:) = ( / 1.0_dp , x0 , y0 , z1 , x0 * y0 , x0 * z1 , y0 * z1 , x0 * y0 * z1 / ) T ( 6 ,:) = ( / 1.0_dp , x1 , y0 , z1 , x1 * y0 , x1 * z1 , y0 * z1 , x1 * y0 * z1 / ) T ( 7 ,:) = ( / 1.0_dp , x0 , y1 , z1 , x0 * y1 , x0 * z1 , y1 * z1 , x0 * y1 * z1 / ) T ( 8 ,:) = ( / 1.0_dp , x1 , y1 , z1 , x1 * y1 , x1 * z1 , y1 * z1 , x1 * y1 * z1 / ) !Solve Ta = c for a, !where c is an array containing the function values at the 8 corners. call dgesv ( 8 , 1 , T , 8 , pivot , c , 8 , info ) !Approximate f(x,y,z) in terms of a. aux = c ( 1 ) + c ( 2 ) * x + c ( 3 ) * y + c ( 4 ) * z + & c ( 5 ) * x * y + c ( 6 ) * x * z + c ( 7 ) * y * z + c ( 8 ) * x * y * z else if ( mode == 1 ) then !2d allocate ( pivot ( 4 ), T ( 4 , 4 ), c ( 4 )) count = 1 do ipol = 1 , 3 if ( r1 ( ipol ) . eq . r0 ( ipol )) then equalpol = ipol else v ( count ) = q ( ipol ) / dble ( refinement ( ipol ) * coarsemesh ( ipol )) v0 ( count ) = floor ( q ( ipol ) / dble ( refinement ( ipol ))) / dble ( coarsemesh ( ipol )) v1 ( count ) = ceiling ( q ( ipol ) / dble ( refinement ( ipol ))) / dble ( coarsemesh ( ipol )) count = count + 1 end if end do i000 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 if ( equalpol . eq . 1 ) then !1st 2 subindices of i are y,z i010 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i110 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 else if ( equalpol . eq . 2 ) then !x,z i010 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 i110 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 else !x,y i010 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 i110 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 end if c = ( / f ( i000 ), f ( i010 ), f ( i100 ), f ( i110 ) / ) T ( 1 ,:) = ( / 1.0_dp , v0 ( 1 ), v0 ( 2 ), v0 ( 1 ) * v0 ( 2 ) / ) T ( 2 ,:) = ( / 1.0_dp , v0 ( 1 ), v1 ( 2 ), v0 ( 1 ) * v1 ( 2 ) / ) T ( 3 ,:) = ( / 1.0_dp , v1 ( 1 ), v0 ( 2 ), v1 ( 1 ) * v0 ( 2 ) / ) T ( 4 ,:) = ( / 1.0_dp , v1 ( 1 ), v1 ( 2 ), v1 ( 1 ) * v1 ( 2 ) / ) call dgesv ( 4 , 1 , T , 4 , pivot , c , 4 , info ) aux = c ( 1 ) + c ( 2 ) * v ( 1 ) + c ( 3 ) * v ( 2 ) + c ( 4 ) * v ( 1 ) * v ( 2 ) else !1d do ipol = 1 , 3 if ( r1 ( ipol ) /= r0 ( ipol )) then x = q ( ipol ) / dble ( refinement ( ipol ) * coarsemesh ( ipol )) x0 = floor ( q ( ipol ) / dble ( refinement ( ipol ))) / dble ( coarsemesh ( ipol )) x1 = ceiling ( q ( ipol ) / dble ( refinement ( ipol ))) / dble ( coarsemesh ( ipol )) i000 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 if ( ipol . eq . 1 ) then i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 else if ( ipol . eq . 2 ) then i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 else i100 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 end if aux = f ( i000 ) + ( x - x0 ) * ( f ( i100 ) - f ( i000 )) / ( x1 - x0 ) end if end do end if interpolation = aux end subroutine interpolate subroutine welcome !! Subroutine to print a pretty banner. if ( this_image () == 1 ) then write ( * , '(A75)' ) \"+-------------------------------------------------------------------------+\" write ( * , '(A75)' ) \"| \\                                                                       |\" write ( * , '(A75)' ) \"|  \\                                                                      |\" write ( * , '(A75)' ) \"|   \\   \\                                                                 |\" write ( * , '(A75)' ) \"|    \\   \\                                                                |\" write ( * , '(A75)' ) \"|   __\\   \\              _        _    _           _    _                 |\" write ( * , '(A75)' ) \"|   \\      \\         ___|.|      |.|  | |__   ___ |.|_ / /__              |\" write ( * , '(A75)' ) \"|    \\    __\\       / _ \\.|   _  |.|_ | '_ \\ / _ \\|.|_  ___/              |\" write ( * , '(A75)' ) \"|     \\  \\         |  __/.| |/ \\_|/  \\| |_) : (_) |.|/ /__                |\" write ( * , '(A75)' ) \"|      \\ \\          \\___|_|/|__/ |   /| ___/ \\___/|_|\\___/                |\" write ( * , '(A75)' ) \"|       \\ \\                /|                                             |\" write ( * , '(A75)' ) \"|        \\\\                \\|                                             |\" write ( * , '(A75)' ) \"|         \\\\                '                                             |\" write ( * , '(A75)' ) \"|          \\                                                              |\" write ( * , '(A75)' ) \"|           \\                                                             |\" write ( * , '(A75)' ) \"| A solver for the coupled electron-phonon Boltzmann transport equations. |\" write ( * , '(A75)' ) \"| Copyright (C) 2020- Nakib Haider Protik.                                |\" write ( * , '(A75)' ) \"|                                                                         |\" write ( * , '(A75)' ) \"| This is a 'free as in freedom'[*] software, distributed under the GPLv3.|\" write ( * , '(A75)' ) \"| [*] https://www.gnu.org/philosophy/free-sw.en.html                      |\" write ( * , '(A75)' ) \"+-------------------------------------------------------------------------+\" print * , ' ' write ( * , '(A, I5)' ) 'Number of coarray images = ' , num_images () end if end subroutine welcome subroutine subtitle ( text ) !! Subroutine to print a subtitle. character ( len = * ), intent ( in ) :: text integer ( k8 ) :: length character ( len = 75 ) :: string2print length = len ( text ) string2print = '___________________________________________________________________________' if ( this_image () == 1 ) write ( * , '(A75)' ) string2print string2print ( 75 - length + 1 : 75 ) = text if ( this_image () == 1 ) write ( * , '(A75)' ) string2print end subroutine subtitle end module misc","tags":"","loc":"sourcefile/misc.f90.html"},{"title":"symmetry.f90 – elphbolt","text":"This file depends on sourcefile~~symmetry.f90~~EfferentGraph sourcefile~symmetry.f90 symmetry.f90 sourcefile~params.f90 params.f90 sourcefile~symmetry.f90->sourcefile~params.f90 sourcefile~misc.f90 misc.f90 sourcefile~symmetry.f90->sourcefile~misc.f90 sourcefile~crystal.f90 crystal.f90 sourcefile~symmetry.f90->sourcefile~crystal.f90 sourcefile~spglib_wrapper.f90 spglib_wrapper.f90 sourcefile~symmetry.f90->sourcefile~spglib_wrapper.f90 sourcefile~misc.f90->sourcefile~params.f90 sourcefile~crystal.f90->sourcefile~params.f90 sourcefile~crystal.f90->sourcefile~misc.f90 sourcefile~spglib_wrapper.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~symmetry.f90~~AfferentGraph sourcefile~symmetry.f90 symmetry.f90 sourcefile~electron.f90 electron.f90 sourcefile~electron.f90->sourcefile~symmetry.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~bz_sums.f90->sourcefile~symmetry.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 sourcefile~bte.f90 bte.f90 sourcefile~bte.f90->sourcefile~symmetry.f90 sourcefile~bte.f90->sourcefile~electron.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~bte.f90->sourcefile~phonon.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~symmetry.f90 sourcefile~elphbolt.f90->sourcefile~electron.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 sourcefile~elphbolt.f90->sourcefile~phonon.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~phonon.f90->sourcefile~symmetry.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules symmetry_module Source Code symmetry.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module symmetry_module !! Module containing type and procedures related to crystal and !! Brillouin zone symmetries. use params , only : dp , k8 use misc , only : mux_vector , demux_mesh , demux_vector , & exit_with_message , subtitle , distribute_points use crystal_module !, only :: crystal use spglib_wrapper , only : get_operations , get_cartesian_operations , get_num_operations implicit none private public symmetry , find_equiv_map , find_irred_wedge , create_fbz2ibz_map , & fbz2ibz , symmetrize_3x3_tensor type symmetry !! Data and procedure related to symmetries. integer ( k8 ) :: nsymm !! Number of spacegroup symmetries. integer ( k8 ) :: nsymm_rot !! Number of rotations. integer ( k8 ), allocatable :: rotations_orig (:,:,:) !! Rotations without time-reversal, real space, crystal coordinates. real ( dp ), allocatable :: crotations_orig (:,:,:) !! Rotations without time-reversal, real space, Cartesian coordinates. real ( dp ), allocatable :: qrotations_orig (:,:,:) !! Rotations without time-reversal, reciprocal space, crystal coordinates. !And with time-reversal (time reversed sector is the 2nd half of last axis): integer ( k8 ), allocatable :: rotations (:,:,:) !! Rotations with time-reversal, real space, crystal coordinates. real ( dp ), allocatable :: crotations (:,:,:) !! Rotations with time-reversal, real space, Cartesian coordinates. real ( dp ), allocatable :: qrotations (:,:,:) !! Rotations with time-reversal, reciprocal space, crystal coordinates. character ( len = 10 ) :: international !! Spacegroup in Hermann–Mauguin (or international) notation. contains procedure :: calculate_symmetries end type symmetry contains subroutine calculate_symmetries ( sym , crys , mesh ) !! Subroutine to generate the symmetry related data for a given crystal. !! !! This subroutine closely follows parts of config.f90 of the ShengBTE code. class ( symmetry ), intent ( out ) :: sym type ( crystal ), intent ( in ) :: crys integer ( k8 ), intent ( in ) :: mesh ( 3 ) !Internal variables: integer ( k8 ) :: i , ii , jj , kk , ll , info , nq , nlen integer ( k8 ) :: P ( 3 ) integer ( k8 ), allocatable :: rtmp (:,:,:), local_equiv_map (:,:) logical , allocatable :: valid (:) real ( dp ), allocatable :: crtmp (:,:,:), qrtmp (:,:,:) real ( dp ), allocatable :: translations (:,:), ctranslations (:,:) real ( dp ) :: tmp1 ( 3 , 3 ), tmp2 ( 3 , 3 ), tmp3 ( 3 , 3 ) call subtitle ( \"Analyzing symmetry...\" ) !Number of points in wave vector mesh nq = product ( mesh ) !Number of crystal symmetries. sym % nsymm = get_num_operations ( crys % lattvecs , crys % numatoms , crys % atomtypes , crys % basis ) !Double the above to take time reversal symetry (TRS) into account. sym % nsymm_rot = 2 * sym % nsymm allocate ( sym % rotations ( 3 , 3 , sym % nsymm_rot ), sym % crotations ( 3 , 3 , sym % nsymm_rot ),& sym % qrotations ( 3 , 3 , sym % nsymm_rot ), sym % rotations_orig ( 3 , 3 , sym % nsymm ),& sym % crotations_orig ( 3 , 3 , sym % nsymm ), sym % qrotations_orig ( 3 , 3 , sym % nsymm ),& translations ( 3 , sym % nsymm ), ctranslations ( 3 , sym % nsymm )) !Get symmetry operations. call get_operations ( crys % lattvecs , crys % numatoms , crys % atomtypes ,& crys % basis , sym % nsymm , sym % rotations_orig , translations , sym % international ) sym % rotations (:,:, 1 : sym % nsymm ) = sym % rotations_orig if ( this_image () == 1 ) then !This is a hacky fix to the problem of a trailing binary character !printing that happens on some machines. nlen = len ( trim ( sym % international )) - 1 write ( * , \"(A, A)\" ) \"Crystal symmetry group = \" , sym % international ( 1 : nlen ) write ( * , \"(A, I5)\" ) \"Number of crystal symmetries (without time-reversal) = \" , sym % nsymm end if !Get symmertry operations in Cartesian basis. call get_cartesian_operations ( crys % lattvecs , sym % nsymm ,& sym % rotations_orig , translations ,& sym % crotations_orig , ctranslations ) sym % crotations (:,:, 1 : sym % nsymm ) = sym % crotations_orig !Transform the rotation matrices to the reciprocal-space basis. do i = 1 , sym % nsymm tmp1 = matmul ( transpose ( crys % lattvecs ), crys % lattvecs ) tmp2 = transpose ( sym % rotations_orig (:, :, i )) tmp3 = tmp1 call dgesv ( 3 , 3 , tmp1 , 3 , P , tmp2 , 3 , info ) sym % qrotations_orig (:,:, i ) = transpose ( matmul ( tmp2 , tmp3 )) end do sym % qrotations (:,:, 1 : sym % nsymm ) = sym % qrotations_orig !Fill the second half of the rotation matrix list using TRS. sym % rotations (:,:, sym % nsymm + 1 : 2 * sym % nsymm ) = - sym % rotations_orig (:,:, 1 : sym % nsymm ) sym % qrotations (:,:, sym % nsymm + 1 : 2 * sym % nsymm ) = - sym % qrotations_orig (:,:, 1 : sym % nsymm ) sym % crotations (:,:, sym % nsymm + 1 : 2 * sym % nsymm ) = - sym % crotations_orig (:,:, 1 : sym % nsymm ) !Find rotations that are either duplicated or incompatible with mesh. allocate ( local_equiv_map ( sym % nsymm_rot , nq )) call find_equiv_map ( sym % nsymm_rot , local_equiv_map , mesh , sym % qrotations ) allocate ( valid ( sym % nsymm_rot )) valid = . true . jj = 0 do ii = 1 , sym % nsymm_rot if ( valid ( ii ) . and . any ( local_equiv_map ( ii ,:) == - 1 )) then valid ( ii ) = . false . jj = jj + 1 end if end do if ( this_image () == 1 . and . jj /= 0 ) then print * , jj , & \"Rotations are incompatible with the wave vector mesh and will be discarded.\" end if ll = 0 do ii = 2 , sym % nsymm_rot do i = 1 , ii - 1 if (. not . valid ( i )) cycle if ( all ( sym % rotations (:,:, ii ) == sym % rotations (:,:, i ))) then valid ( ii ) = . false . ll = ll + 1 exit end if end do end do if ( this_image () == 1 . and . ll == 0 ) then write ( * , \"(A, I5)\" ) \"Number of duplicated rotations to be discarded = \" , ll end if !Filter out those rotations through a series of move_alloc calls. !Arrays to take into account: rotations,crotations,qrotations. if ( ll + jj /= 0 ) then allocate ( rtmp ( 3 , 3 , sym % nsymm_rot - ll - jj )) allocate ( crtmp ( 3 , 3 , sym % nsymm_rot - ll - jj )) allocate ( qrtmp ( 3 , 3 , sym % nsymm_rot - ll - jj )) kk = 0 do ii = 1 , sym % nsymm_rot if ( valid ( ii )) then kk = kk + 1 rtmp (:,:, kk ) = sym % rotations (:,:, ii ) crtmp (:,:, kk ) = sym % crotations (:,:, ii ) qrtmp (:,:, kk ) = sym % qrotations (:,:, ii ) end if end do sym % nsymm_rot = sym % nsymm_rot - ll - jj call move_alloc ( rtmp , sym % rotations ) call move_alloc ( crtmp , sym % crotations ) call move_alloc ( qrtmp , sym % qrotations ) end if end subroutine calculate_symmetries subroutine find_star ( q_in , q_out , mesh , qrotations ) !! Compute all images of a wave vector (crystal coords.) under the !! rotational symmetry operations. integer ( k8 ), intent ( in ) :: q_in ( 3 ), mesh ( 3 ) real ( dp ), intent ( in ) :: qrotations (:,:,:) real ( dp ), intent ( out ) :: q_out (:,:) integer ( k8 ) :: ii , nsymm_rot nsymm_rot = size ( qrotations ( 1 , 1 ,:)) do ii = 1 , nsymm_rot q_out (:, ii ) = mesh * matmul ( qrotations (:, :, ii ), dble ( q_in ) / mesh ) end do end subroutine find_star subroutine find_equiv_map ( nsymm_rot , equiv_map , mesh , qrotations , indexlist ) !! Subroutine to create the map of equivalent wave vectors. integer ( k8 ), intent ( in ) :: nsymm_rot , mesh ( 3 ) real ( dp ), intent ( in ) :: qrotations (:,:,:) integer ( k8 ), optional , intent ( in ) :: indexlist (:) integer ( k8 ), intent ( out ) :: equiv_map (:,:) integer ( k8 ) :: nmesh , chunk , counter , im , num_active_images integer ( k8 ), allocatable :: index_mesh (:,:) integer ( k8 ) :: i , isym , ivec ( 3 ), base real ( dp ) :: vec ( 3 ), vec_star ( 3 , nsymm_rot ), dnrm2 integer ( k8 ), allocatable :: start [:], end [:], equiv_map_chunk (:,:)[:] if ( present ( indexlist )) then nmesh = size ( indexlist ) else nmesh = product ( mesh ) end if allocate ( index_mesh ( 3 , nmesh )) !Create mesh of demuxed 0-based indices. base = 0 if ( present ( indexlist )) then call demux_mesh ( index_mesh , nmesh , mesh , base , indexlist ) else call demux_mesh ( index_mesh , nmesh , mesh , base ) end if !Allocate start and end coarrays allocate ( start [ * ], end [ * ]) !Divide wave vectors among images call distribute_points ( nmesh , chunk , start , end , num_active_images ) !Allocate small work variable chunk for each image allocate ( equiv_map_chunk ( nsymm_rot , chunk )[ * ]) counter = 0 do i = start , end !Run over total number of wave vectors. !Increase counter counter = counter + 1 call find_star ( index_mesh (:, i ), vec_star , mesh , qrotations ) !Find star of wave vector. do isym = 1 , nsymm_rot !Run over all rotational symmetries of system. vec = vec_star (:, isym ) !Pick image. ivec = nint ( vec ) !Snap to nearest integer grid. !Check norm and save mapping: if ( dnrm2 ( 3 , abs ( vec - dble ( ivec )), 1 ) >= 1e-2_dp ) then equiv_map_chunk ( isym , counter ) = - 1 else equiv_map_chunk ( isym , counter ) = mux_vector ( modulo ( ivec , mesh ), mesh , base ) end if end do end do !Collect equiv_map_chunks in equiv_map sync all do im = 1 , num_active_images equiv_map (:, start [ im ]: end [ im ]) = equiv_map_chunk (:,:)[ im ] end do end subroutine find_equiv_map subroutine find_irred_wedge ( mesh , nwavevecs_irred , wavevecs_irred , & indexlist_irred , nequivalent , nsymm_rot , qrotations , ibz2fbz_map , equivalence_map , blocks , indexlist ) !! Find the irreducible wedge of the FBZ and other quantities. !! Wedge finding algorithm is inspired by ShengBTE. !! !! mesh is the array of number of points along the reciprocal lattice vectors !! nwavevecs_irred is the number of irreducible vectors !! wavevecs_irred are the irreducible vectors !! indexlist_irred is the list containing the muxed indices of the irreducible wave vectors !! nequivalent lists the number of equivalent points of each irreducible point !! ibz2fbz_map contains the map from an irreducible BZ (IBZ) vector to its FBZ images !!   The third axis contains the pair (symmetry index, image) !! equivalence_map is a map of the equivalent points under rotations !! blocks chooses whether the FBZ is energy restricted or not !! indexlist is the sorted list of indices of the wavevectors !!   in the energy restricted FBZ which must be present if blocks is true integer ( k8 ), intent ( in ) :: mesh ( 3 ) logical , intent ( in ) :: blocks integer ( k8 ), intent ( in ) :: nsymm_rot real ( dp ), intent ( in ) :: qrotations (:,:,:) integer ( k8 ), optional , intent ( in ) :: indexlist (:) integer ( k8 ), intent ( out ) :: nwavevecs_irred integer ( k8 ), allocatable , intent ( out ) :: indexlist_irred (:), & nequivalent (:), ibz2fbz_map (:,:,:), equivalence_map (:,:) real ( dp ), allocatable , intent ( out ) :: wavevecs_irred (:,:) !Local variables integer ( k8 ) :: nwavevecs , i , imux , s , image , imagelist ( nsymm_rot ), & nrunninglist , counter , ijk ( 3 ), aux , num_active_images , chunk integer ( k8 ), allocatable :: runninglist (:), & indexlist_irred_tmp (:), nequivalent_tmp (:), ibz2fbz_map_tmp (:,:,:), & start [:], end [:], check [:] logical :: in_list if ( blocks . and . . not . present ( indexlist )) & call exit_with_message ( \"If blocks is true then indexlist must be present\" ) if ( blocks ) then nwavevecs = size ( indexlist ) else nwavevecs = product ( mesh ) end if allocate ( equivalence_map ( nsymm_rot , nwavevecs )) if ( blocks ) then call find_equiv_map ( nsymm_rot , equivalence_map , mesh , qrotations , indexlist ) else call find_equiv_map ( nsymm_rot , equivalence_map , mesh , qrotations ) end if allocate ( indexlist_irred_tmp ( nwavevecs ), nequivalent_tmp ( nwavevecs ), & runninglist ( nwavevecs ), ibz2fbz_map_tmp ( nsymm_rot , nwavevecs , 2 )) !Allocate coarrays allocate ( start [ * ], end [ * ], check [ * ]) runninglist = 0 nrunninglist = 0 nwavevecs_irred = 0 nequivalent_tmp = 0 counter = 0 do i = 1 , nwavevecs !Take a point from the FBZ !Get the muxed index of the wave vector if ( blocks ) then imux = indexlist ( i ) else imux = i end if !Check if point is not already in the running list of points in_list = . false . if ( nrunninglist > 0 ) then !Divide wave vectors among images call distribute_points ( nrunninglist , chunk , start , end , num_active_images ) check = 0 if ( any ( runninglist ( start : end ) == imux )) check = 1 call co_sum ( check ) if ( check > 0 ) in_list = . true . end if sync all if (. not . in_list ) then !Increment irreducible point counter nwavevecs_irred = nwavevecs_irred + 1 !Save point to irreducible wedge list indexlist_irred_tmp ( nwavevecs_irred ) = imux !Generate images of this irreducible point do s = 1 , nsymm_rot !Take a rotation image = equivalence_map ( s , i ) !This is the image !Check if image is not already in the list of images if (. not . any ( imagelist ( 1 : nequivalent_tmp ( nwavevecs_irred )) == image )) then !Increment equivalent image counter nequivalent_tmp ( nwavevecs_irred ) = & nequivalent_tmp ( nwavevecs_irred ) + 1 aux = nequivalent_tmp ( nwavevecs_irred ) !Save image to list of images and running list of !points that have already been considered imagelist ( aux ) = image nrunninglist = nrunninglist + 1 runninglist ( nrunninglist ) = image !Save mapping of the irreducible point to its FBZ image ibz2fbz_map_tmp ( aux , & nwavevecs_irred , :) = ( / s , image / ) end if end do counter = counter + nequivalent_tmp ( nwavevecs_irred ) end if end do !Check for error if ( nwavevecs /= counter ) call exit_with_message ( \"Severe error: Could not find irreducible wedge.\" ) if ( this_image () == 1 ) write ( * , \"(A, I10)\" ) \" Number of FBZ wave vectors = \" , counter if ( this_image () == 1 ) write ( * , \"(A, I10)\" ) \" Number IBZ wave vectors = \" , nwavevecs_irred !Deallocate some internal data deallocate ( runninglist ) !Copy the tmp data into (much) smaller sized global data holders allocate ( indexlist_irred ( nwavevecs_irred ), nequivalent ( nwavevecs_irred ), & ibz2fbz_map ( nsymm_rot , nwavevecs_irred , 2 )) indexlist_irred ( 1 : nwavevecs_irred ) = indexlist_irred_tmp ( 1 : nwavevecs_irred ) nequivalent ( 1 : nwavevecs_irred ) = nequivalent_tmp ( 1 : nwavevecs_irred ) ibz2fbz_map (:, 1 : nwavevecs_irred , :) = ibz2fbz_map_tmp (:, 1 : nwavevecs_irred , :) !Deallocate some internal data deallocate ( indexlist_irred_tmp , nequivalent_tmp , ibz2fbz_map_tmp ) !Create crystal coords IBZ wave vectors allocate ( wavevecs_irred ( nwavevecs_irred , 3 )) do i = 1 , nwavevecs_irred !run over total number of vectors imux = indexlist_irred ( i ) call demux_vector ( imux , ijk , mesh , 0_k8 ) !get 0-based (i,j,k) indices wavevecs_irred ( i ,:) = dble ( ijk ) / mesh !wave vectors in crystal coordinates end do end subroutine find_irred_wedge function fbz2ibz ( iwvmux , nwv_irred , nequiv , ibz2fbz_map ) !! Find index in IBZ blocks list for a given FBZ blocks muxed vector index integer ( k8 ), intent ( in ) :: iwvmux , nwv_irred , nequiv ( nwv_irred ), ibz2fbz_map (:,:,:) integer ( k8 ) :: i , l , il , fbz2ibz fbz2ibz = - 1 !Sum over all ibz points do i = 1 , nwv_irred !an irreducible point do l = 1 , nequiv ( i ) !number of equivalent points of i !Get (i, l) -> il, the muxed vector index of image il = ibz2fbz_map ( l , i , 2 ) if ( il == iwvmux ) then fbz2ibz = i exit end if end do end do if ( fbz2ibz == - 1 ) then print * , 'Error in fbz2ibz for input index = ' , iwvmux end if end function fbz2ibz subroutine create_fbz2ibz_map ( fbz2ibz_map , nwv , nwv_irred , indexlist , nequiv , ibz2fbz_map ) !! Subroutine to create map of FBZ blocks to IBZ blocks integer ( k8 ), intent ( in ) :: nwv , nwv_irred , indexlist ( nwv ), & nequiv ( nwv_irred ), ibz2fbz_map (:,:,:) integer ( k8 ), intent ( out ), allocatable :: fbz2ibz_map (:) integer ( k8 ) :: iwv allocate ( fbz2ibz_map ( nwv )) do iwv = 1 , nwv !Run over all wave vectors fbz2ibz_map ( iwv ) = fbz2ibz ( indexlist ( iwv ), nwv_irred , nequiv , ibz2fbz_map ) end do end subroutine create_fbz2ibz_map subroutine symmetrize_3x3_tensor ( tensor , crotations ) !! Symmetrize a 3x3 tensor. real ( dp ), intent ( inout ) :: tensor ( 3 , 3 ) real ( dp ), intent ( in ) :: crotations (:,:,:) integer ( k8 ) :: irot , nrots real ( dp ) :: aux ( 3 , 3 ) nrots = size ( crotations ( 1 , 1 , :)) aux (:,:) = 0.0_dp do irot = 1 , nrots aux (:,:) = aux (:,:) + matmul ( crotations (:, :, irot ),& matmul ( tensor , transpose ( crotations (:, :, irot )))) end do tensor (:,:) = aux (:,:) / nrots end subroutine symmetrize_3x3_tensor end module symmetry_module","tags":"","loc":"sourcefile/symmetry.f90.html"},{"title":"numerics.f90 – elphbolt","text":"This file depends on sourcefile~~numerics.f90~~EfferentGraph sourcefile~numerics.f90 numerics.f90 sourcefile~params.f90 params.f90 sourcefile~numerics.f90->sourcefile~params.f90 sourcefile~misc.f90 misc.f90 sourcefile~numerics.f90->sourcefile~misc.f90 sourcefile~crystal.f90 crystal.f90 sourcefile~numerics.f90->sourcefile~crystal.f90 sourcefile~misc.f90->sourcefile~params.f90 sourcefile~crystal.f90->sourcefile~params.f90 sourcefile~crystal.f90->sourcefile~misc.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~numerics.f90~~AfferentGraph sourcefile~numerics.f90 numerics.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~interactions.f90->sourcefile~numerics.f90 sourcefile~electron.f90 electron.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~wannier.f90 wannier.f90 sourcefile~interactions.f90->sourcefile~wannier.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 sourcefile~electron.f90->sourcefile~numerics.f90 sourcefile~electron.f90->sourcefile~wannier.f90 sourcefile~bte.f90 bte.f90 sourcefile~bte.f90->sourcefile~numerics.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~bte.f90->sourcefile~electron.f90 sourcefile~bte.f90->sourcefile~phonon.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~wannier.f90->sourcefile~numerics.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~numerics.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90->sourcefile~electron.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 sourcefile~elphbolt.f90->sourcefile~wannier.f90 sourcefile~elphbolt.f90->sourcefile~phonon.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~phonon.f90->sourcefile~numerics.f90 sourcefile~phonon.f90->sourcefile~wannier.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules numerics_module Source Code numerics.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module numerics_module !! Module containing type and procedures related to the numerics. use params , only : dp , k8 , twopi use misc , only : exit_with_message , subtitle use crystal_module , only : crystal implicit none private public numerics type numerics !! Data and procedures related to the numerics. integer ( k8 ) :: qmesh ( 3 ) !! Phonon wave vector mesh. integer ( k8 ) :: mesh_ref !! Electron mesh refinement factor compared to the phonon mesh. real ( dp ) :: fsthick !! Fermi surface thickness in eV. character ( len = 1024 ) :: cwd !! Current working directory. character ( len = 1024 ) :: datadumpdir !! Runtime data dump repository. character ( len = 1024 ) :: datadumpdir_T !! Runtime temperature dependent data dump repository. character ( len = 1024 ) :: datadumpdir_T_chempot !! Runtime temperature and chemical potential dependent data dump repository. character ( len = 1024 ) :: g2dir !! Directory for e-ph vertex. character ( len = 1024 ) :: Vdir !! Directory for ph-ph vertex. character ( len = 1024 ) :: Wdir !! Directory for ph-ph transition rates. character ( len = 1024 ) :: Xdir !! Directory for e-ph transition rates. character ( len = 1024 ) :: Ydir !! Directory for ph-e transition rates. logical :: read_gq2 !! Choose if earlier e-ph (IBZ q) vertices are to be used. logical :: read_gk2 !! Choose if earlier e-ph (IBZ k) vertices are to be used. logical :: read_V !! Choose if earlier ph-ph (IBZ q) vertices are to be used. logical :: read_W !! Choose if earlier ph-ph (IBZ q) transition probabilities are to be used. logical :: tetrahedra !! Choose if the tetrahedron method for 3d delta function evaluation will be used. logical :: phe !! Choose if ph-e interaction will be included. logical :: phiso !! Use phonon-isotope scattering? logical :: phsubs !! Use phonon-substitution scattering? logical :: onlyphbte !! Choose if only phonon BTE will be solved. logical :: onlyebte !! Choose if electron BTE will be solved. logical :: elchimp !! Use electron-charged impurity scattering? logical :: drag !! Choose if the drag effect will be included. integer ( k8 ) :: maxiter !! Maximum number of iterations in the BTE solver. real ( dp ) :: conv_thres !! BTE iteration convergence criterion. logical :: plot_along_path !! Plot Wannierized quantities along high symmetry wave vectors? integer ( k8 ) :: runlevel !! Control for the type of calculation. real ( dp ) :: ph_en_min , ph_en_max !! Bounds of equidistant phonon energy mesh. integer ( k8 ) :: ph_en_num !! Number of equidistant phonon energy mesh points. real ( dp ) :: el_en_min , el_en_max !! Bounds of equidistant phonon energy mesh. integer ( k8 ) :: el_en_num !! Number of equidistant phonon energy mesh points. contains procedure :: initialize => read_input_and_setup , create_chempot_dirs end type numerics contains subroutine read_input_and_setup ( n , crys ) !! Read input file for information related to the numerics. !! !! n Numerics object !! crys Crytal object class ( numerics ), intent ( out ) :: n type ( crystal ), intent ( in ) :: crys !Local variables integer ( k8 ) :: mesh_ref , qmesh ( 3 ), maxiter , runlevel , el_en_num , ph_en_num real ( dp ) :: fsthick , conv_thres , ph_en_min , ph_en_max , el_en_min , el_en_max character ( len = 1024 ) :: datadumpdir , tag logical :: read_gq2 , read_gk2 , read_V , read_W , tetrahedra , phe , phiso , phsubs , & onlyphbte , onlyebte , elchimp , drag , plot_along_path namelist / numerics / qmesh , mesh_ref , fsthick , datadumpdir , read_gq2 , read_gk2 , & read_V , read_W , tetrahedra , phe , phiso , phsubs , onlyphbte , onlyebte , maxiter , & conv_thres , drag , elchimp , plot_along_path , runlevel , ph_en_min , ph_en_max , & ph_en_num , el_en_min , el_en_max , el_en_num call subtitle ( \"Reading numerics information...\" ) !Open input file open ( 1 , file = 'input.nml' , status = 'old' ) !Read numerics information qmesh = ( / 1 , 1 , 1 / ) mesh_ref = 1 fsthick = 0.0_dp datadumpdir = './' read_gq2 = . false . read_gk2 = . false . read_V = . false . read_W = . false . tetrahedra = . false . phe = . false . phiso = . false . phsubs = . false . onlyphbte = . false . onlyebte = . false . elchimp = . false . drag = . true . plot_along_path = . false . maxiter = 50 conv_thres = 1e-4_dp runlevel = 1 ph_en_min = 0.0_dp ph_en_max = 1.0_dp ph_en_num = 100 el_en_min = - 1 0.0_dp el_en_max = 1 0.0_dp el_en_num = 100 read ( 1 , nml = numerics ) if ( any ( qmesh <= 0 ) . or . mesh_ref < 1 . or . fsthick < 0 ) then call exit_with_message ( 'Bad input(s) in numerics.' ) end if if ( crys % twod . and . tetrahedra ) then call exit_with_message ( 'The tetrahedra method only works for 3d. Exiting.' ) end if if ( crys % epsilon0 == 0.0 . and . elchimp ) then call exit_with_message (& 'Need to provide non-zero epsilon0 for e-ch. imp. interaction. Exiting.' ) end if n % qmesh = qmesh n % mesh_ref = mesh_ref n % fsthick = fsthick n % datadumpdir = trim ( datadumpdir ) n % read_gq2 = read_gq2 n % read_gk2 = read_gk2 n % read_V = read_V n % read_W = read_W n % tetrahedra = tetrahedra n % phe = phe n % phiso = phiso n % phsubs = phsubs n % onlyphbte = onlyphbte n % onlyebte = onlyebte n % elchimp = elchimp n % maxiter = maxiter n % conv_thres = conv_thres n % drag = drag n % plot_along_path = plot_along_path n % runlevel = runlevel if ( runlevel == 2 ) then n % ph_en_min = ph_en_min n % ph_en_max = ph_en_max n % ph_en_num = ph_en_num n % el_en_min = el_en_min n % el_en_max = el_en_max n % el_en_num = el_en_num end if if ( crys % twod . and . n % qmesh ( 3 ) /= 1 ) then call exit_with_message ( 'For 2d systems, qmesh(3) must be equal to 1.' ) end if !Set BTE solution type if ( n % onlyphbte ) then n % onlyebte = . false . n % drag = . false . end if if ( n % onlyebte ) then n % onlyphbte = . false . n % phiso = . false . n % phsubs = . false . n % drag = . false . n % phe = . false . end if if ( n % drag ) then n % onlyebte = . false . n % onlyphbte = . false . n % phe = . true . end if !Create data dump directory if ( this_image () == 1 ) call system ( 'mkdir -p ' // trim ( adjustl ( n % datadumpdir ))) !Create matrix elements data directories n % g2dir = trim ( adjustl ( n % datadumpdir )) // 'g2' if ( this_image () == 1 ) call system ( 'mkdir -p ' // trim ( adjustl ( n % g2dir ))) n % Vdir = trim ( adjustl ( n % datadumpdir )) // 'V2' if ( this_image () == 1 ) call system ( 'mkdir -p ' // trim ( adjustl ( n % Vdir ))) !Create T dependent subdirectory write ( tag , \"(E9.3)\" ) crys % T n % datadumpdir_T = trim ( adjustl ( n % datadumpdir )) // 'T' // trim ( adjustl ( tag )) if ( this_image () == 1 ) call system ( 'mkdir -p ' // trim ( adjustl ( n % datadumpdir_T ))) !Create T-dependent ph-ph transition probability directory n % Wdir = trim ( adjustl ( n % datadumpdir_T )) // '/W' if ( this_image () == 1 ) call system ( 'mkdir -p ' // trim ( adjustl ( n % Wdir ))) !Close input file close ( 1 ) !Set current work directory. call getcwd ( n % cwd ) n % cwd = trim ( n % cwd ) !Print out information. if ( this_image () == 1 ) then write ( * , \"(A, (3I5,x))\" ) \"q-mesh = \" , n % qmesh if ( crys % twod ) then write ( * , \"(A, (3I5,x))\" ) \"k-mesh = \" , n % mesh_ref * n % qmesh ( 1 ), n % mesh_ref * n % qmesh ( 2 ), 1 else write ( * , \"(A, (3I5,x))\" ) \"k-mesh = \" , n % mesh_ref * n % qmesh ( 1 ), n % mesh_ref * n % qmesh ( 2 ), & n % mesh_ref * n % qmesh ( 3 ) end if write ( * , \"(A, 1E16.8, A)\" ) \"Fermi window thickness (each side of reference energy) = \" , n % fsthick , \" eV\" write ( * , \"(A, A)\" ) \"Working directory = \" , trim ( n % cwd ) write ( * , \"(A, A)\" ) \"Data dump directory = \" , trim ( n % datadumpdir ) write ( * , \"(A, A)\" ) \"T-dependent data dump directory = \" , trim ( n % datadumpdir_T ) write ( * , \"(A, A)\" ) \"e-ph directory = \" , trim ( n % g2dir ) write ( * , \"(A, A)\" ) \"ph-ph directory = \" , trim ( n % Vdir ) write ( * , \"(A, L)\" ) \"Reuse e-ph matrix elements: \" , n % read_gk2 write ( * , \"(A, L)\" ) \"Reuse ph-e matrix elements: \" , n % read_gq2 write ( * , \"(A, L)\" ) \"Reuse ph-ph matrix elements: \" , n % read_V write ( * , \"(A, L)\" ) \"Reuse ph-ph transition probabilities: \" , n % read_W write ( * , \"(A, L)\" ) \"Use tetrahedron method: \" , n % tetrahedra write ( * , \"(A, L)\" ) \"Include ph-e interaction: \" , n % phe write ( * , \"(A, L)\" ) \"Include ph-isotope interaction: \" , n % phiso write ( * , \"(A, L)\" ) \"Include ph-substitution interaction: \" , n % phsubs write ( * , \"(A, L)\" ) \"Include electron-charged impurity interaction: \" , n % elchimp if ( n % onlyphbte ) write ( * , \"(A, L)\" ) \"Calculate only phonon BTE: \" , n % onlyphbte if ( n % onlyebte ) write ( * , \"(A, L)\" ) \"Calculate only electron BTE: \" , n % onlyebte write ( * , \"(A, L)\" ) \"Include drag: \" , n % drag write ( * , \"(A, L)\" ) \"Plot quantities along path: \" , n % plot_along_path write ( * , \"(A, I5)\" ) \"Maximum number of BTE iterations = \" , n % maxiter write ( * , \"(A, 1E16.8)\" ) \"BTE convergence threshold = \" , n % conv_thres end if sync all end subroutine read_input_and_setup subroutine create_chempot_dirs ( n , chempot ) !! Subroutine to create data dump directory tagged by the chemical potential !! and subdirectories within. class ( numerics ), intent ( inout ) :: n real ( dp ), intent ( in ) :: chempot !Local variables character ( len = 1024 ) :: tag !Create chemical potential dependent data dump directory write ( tag , \"(E14.8)\" ) chempot n % datadumpdir_T_chempot = trim ( adjustl ( n % datadumpdir_T )) // '/mu' // trim ( adjustl ( tag )) !Create e-ph and ph-e transition probability data directories n % Xdir = trim ( adjustl ( n % datadumpdir_T_chempot )) // '/X' n % Ydir = trim ( adjustl ( n % datadumpdir_T_chempot )) // '/Y' if ( this_image () == 1 ) then call system ( 'mkdir -p ' // trim ( adjustl ( n % datadumpdir_T_chempot ))) call system ( 'mkdir -p ' // trim ( adjustl ( n % Xdir ))) call system ( 'mkdir -p ' // trim ( adjustl ( n % Ydir ))) end if sync all end subroutine create_chempot_dirs end module numerics_module","tags":"","loc":"sourcefile/numerics.f90.html"},{"title":"spglib_wrapper.f90 – elphbolt","text":"This file depends on sourcefile~~spglib_wrapper.f90~~EfferentGraph sourcefile~spglib_wrapper.f90 spglib_wrapper.f90 sourcefile~params.f90 params.f90 sourcefile~spglib_wrapper.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~spglib_wrapper.f90~~AfferentGraph sourcefile~spglib_wrapper.f90 spglib_wrapper.f90 sourcefile~symmetry.f90 symmetry.f90 sourcefile~symmetry.f90->sourcefile~spglib_wrapper.f90 sourcefile~electron.f90 electron.f90 sourcefile~electron.f90->sourcefile~symmetry.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~bz_sums.f90->sourcefile~symmetry.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 sourcefile~bte.f90 bte.f90 sourcefile~bte.f90->sourcefile~symmetry.f90 sourcefile~bte.f90->sourcefile~electron.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~bte.f90->sourcefile~phonon.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~symmetry.f90 sourcefile~elphbolt.f90->sourcefile~electron.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 sourcefile~elphbolt.f90->sourcefile~phonon.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~phonon.f90->sourcefile~symmetry.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules spglib_wrapper Source Code spglib_wrapper.f90 Source Code !From ShengBTE symmetry.f90 !  ShengBTE, a solver for the Boltzmann Transport Equation for phonons !  Copyright (C) 2012-2017 Wu Li <wu.li.phys2011@gmail.com> !  Copyright (C) 2012-2017 Jesús Carrete Montaña <jcarrete@gmail.com> !  Copyright (C) 2012-2017 Nebil Ayape Katcho <nebil.ayapekatcho@cea.fr> !  Copyright (C) 2012-2017 Natalio Mingo Bisquert <natalio.mingo@cea.fr> ! !  This program is free software: you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation, either version 3 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program.  If not, see <http://www.gnu.org/licenses/>. ! Thin, specialized wrapper around spglib, a library by Atsushi Togo. ! Small change in data type declaration -- Nakib H. Protik module spglib_wrapper !! Wrapper for spglib from ShengBTE. use params , only : dp , k8 use iso_c_binding implicit none public ! Tolerance parameter passed to spglib. real ( kind = C_DOUBLE ), parameter :: symprec = 1 d - 5 ! Explicit interfaces to spglib. interface function spg_get_symmetry ( rotations , translations , nops , lattice ,& positions , types , natoms , symprec ) bind ( C , name = \"spg_get_symmetry\" ) use iso_c_binding integer ( kind = C_INT ), value :: nops integer ( kind = C_INT ), value :: natoms integer ( kind = C_INT ) :: spg_get_symmetry integer ( kind = C_INT ), dimension ( 3 , 3 , nops ) :: rotations real ( kind = C_DOUBLE ), dimension ( 3 , nops ) :: translations real ( kind = C_DOUBLE ), dimension ( 3 , 3 ) :: lattice real ( kind = C_DOUBLE ), dimension ( 3 , natoms ) :: positions integer ( kind = C_INT ), dimension ( natoms ) :: types real ( kind = C_DOUBLE ), value :: symprec end function spg_get_symmetry function spg_get_international ( symbol , lattice ,& positions , types , natoms , symprec ) bind ( C , name = \"spg_get_international\" ) use iso_c_binding integer ( kind = C_INT ), value :: natoms integer ( kind = C_INT ) :: spg_get_international character ( kind = C_CHAR ), dimension ( 11 ) :: symbol real ( kind = C_DOUBLE ), dimension ( 3 , 3 ) :: lattice real ( kind = C_DOUBLE ), dimension ( 3 , natoms ) :: positions integer ( kind = C_INT ), dimension ( natoms ) :: types real ( kind = C_DOUBLE ), value :: symprec end function spg_get_international function spg_get_multiplicity ( lattice ,& positions , types , natoms , symprec ) bind ( C , name = \"spg_get_multiplicity\" ) use iso_c_binding integer ( kind = C_INT ), value :: natoms integer ( kind = C_INT ) :: spg_get_multiplicity real ( kind = C_DOUBLE ), dimension ( 3 , 3 ) :: lattice real ( kind = C_DOUBLE ), dimension ( 3 , natoms ) :: positions integer ( kind = C_INT ), dimension ( natoms ) :: types real ( kind = C_DOUBLE ), value :: symprec end function spg_get_multiplicity end interface contains function get_num_operations ( lattice , natoms , types , positions ) !! Return the number of symmetry operations. Useful for allocating !! memory for get_operations(). real ( dp ), dimension ( 3 , 3 ), intent ( in ) :: lattice integer ( k8 ), intent ( in ) :: natoms integer ( k8 ), dimension ( natoms ), intent ( in ) :: types real ( dp ), dimension ( 3 , natoms ), intent ( in ) :: positions integer ( k8 ) :: get_num_operations ! Notice the explicit C-compatible types used through this module. real ( kind = C_DOUBLE ), dimension ( 3 , 3 ) :: clattice integer ( kind = C_INT ) :: cnatoms integer ( kind = C_INT ), dimension ( natoms ) :: ctypes real ( kind = C_DOUBLE ), dimension ( 3 , natoms ) :: cpositions integer ( kind = C_INT ) :: num ! This kind of transposition is needed for interoperability with ! C. clattice = transpose ( lattice ) cnatoms = natoms ctypes = types cpositions = positions num = spg_get_multiplicity ( clattice , cpositions , ctypes ,& cnatoms , symprec ) get_num_operations = num end function get_num_operations subroutine get_operations ( lattice , natoms , types , positions , nops ,& rotations , translations , international ) !! Return the matrix and vector representations of the symmetry !! operations of the system. real ( dp ), dimension ( 3 , 3 ), intent ( in ) :: lattice integer ( k8 ), intent ( in ) :: natoms integer ( k8 ), dimension ( natoms ), intent ( in ) :: types real ( dp ), dimension ( 3 , natoms ), intent ( in ) :: positions integer ( k8 ), intent ( inout ) :: nops integer ( k8 ), dimension ( 3 , 3 , nops ), intent ( out ) :: rotations real ( dp ), dimension ( 3 , nops ), intent ( out ) :: translations character ( len = 10 ), intent ( out ) :: international integer ( kind = C_INT ) :: i integer ( kind = C_INT ) :: newnops real ( kind = C_DOUBLE ), dimension ( 3 , 3 ) :: clattice integer ( kind = C_INT ) :: cnatoms integer ( kind = C_INT ), dimension ( natoms ) :: ctypes real ( kind = C_DOUBLE ), dimension ( 3 , natoms ) :: cpositions integer ( kind = C_INT ) :: cnops integer ( kind = C_INT ), dimension ( 3 , 3 , nops ) :: crotations real ( kind = C_DOUBLE ), dimension ( 3 , nops ) :: ctranslations character ( len = 11 , kind = C_CHAR ) :: intertmp clattice = transpose ( lattice ) cnatoms = natoms ctypes = types cpositions = positions cnops = nops intertmp = '           ' !Empty spaces ! If nops changes value, something went wrong. Checking ! this condition is up to the user. newnops = spg_get_symmetry ( crotations , ctranslations , cnops ,& clattice , cpositions , ctypes , cnatoms , symprec ) i = spg_get_international ( intertmp , clattice , cpositions ,& ctypes , cnatoms , symprec ) international = intertmp ( 1 : 10 ) nops = newnops ! Transform from C to Fortran order. do i = 1 , nops rotations (:,:, i ) = transpose ( crotations (:,:, i )) end do translations = ctranslations end subroutine get_operations subroutine get_cartesian_operations ( lattice , nops , rotations , translations ,& crotations , ctranslations ) !! Return the Cartesian components of the rotations and translations !! returned by get_operations(). real ( dp ), dimension ( 3 , 3 ), intent ( in ) :: lattice integer ( k8 ), intent ( in ) :: nops integer ( k8 ), dimension ( 3 , 3 , nops ), intent ( in ) :: rotations real ( dp ), dimension ( 3 , nops ), intent ( in ) :: translations real ( dp ), dimension ( 3 , 3 , nops ), intent ( out ) :: crotations real ( dp ), dimension ( 3 , nops ), intent ( out ) :: ctranslations integer ( k8 ) :: i , info integer ( k8 ), dimension ( 3 ) :: P real ( dp ), dimension ( 3 , 3 ) :: tmp1 , tmp2 ctranslations = matmul ( lattice , translations ) do i = 1 , nops tmp1 = transpose ( lattice ) tmp2 = transpose ( matmul ( lattice , rotations (:,:, i ))) ! Rotations transform as tensors: both the lattice-vector matrix ! and its inverse are needed. Explicit inversions are avoided. call dgesv ( 3 , 3 , tmp1 , 3 , P , tmp2 , 3 , info ) crotations (:,:, i ) = transpose ( tmp2 ) end do end subroutine get_cartesian_operations end module spglib_wrapper","tags":"","loc":"sourcefile/spglib_wrapper.f90.html"},{"title":"crystal.f90 – elphbolt","text":"This file depends on sourcefile~~crystal.f90~~EfferentGraph sourcefile~crystal.f90 crystal.f90 sourcefile~misc.f90 misc.f90 sourcefile~crystal.f90->sourcefile~misc.f90 sourcefile~params.f90 params.f90 sourcefile~crystal.f90->sourcefile~params.f90 sourcefile~misc.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~crystal.f90~~AfferentGraph sourcefile~crystal.f90 crystal.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~interactions.f90->sourcefile~crystal.f90 sourcefile~numerics.f90 numerics.f90 sourcefile~interactions.f90->sourcefile~numerics.f90 sourcefile~electron.f90 electron.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~wannier.f90 wannier.f90 sourcefile~interactions.f90->sourcefile~wannier.f90 sourcefile~phonon.f90 phonon.f90 sourcefile~interactions.f90->sourcefile~phonon.f90 sourcefile~numerics.f90->sourcefile~crystal.f90 sourcefile~electron.f90->sourcefile~crystal.f90 sourcefile~electron.f90->sourcefile~numerics.f90 sourcefile~electron.f90->sourcefile~wannier.f90 sourcefile~symmetry.f90 symmetry.f90 sourcefile~electron.f90->sourcefile~symmetry.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~bz_sums.f90->sourcefile~crystal.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 sourcefile~bz_sums.f90->sourcefile~symmetry.f90 sourcefile~bz_sums.f90->sourcefile~phonon.f90 sourcefile~bte.f90 bte.f90 sourcefile~bte.f90->sourcefile~crystal.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~bte.f90->sourcefile~numerics.f90 sourcefile~bte.f90->sourcefile~electron.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~bte.f90->sourcefile~symmetry.f90 sourcefile~bte.f90->sourcefile~phonon.f90 sourcefile~wannier.f90->sourcefile~crystal.f90 sourcefile~wannier.f90->sourcefile~numerics.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~crystal.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90->sourcefile~numerics.f90 sourcefile~elphbolt.f90->sourcefile~electron.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 sourcefile~elphbolt.f90->sourcefile~wannier.f90 sourcefile~elphbolt.f90->sourcefile~symmetry.f90 sourcefile~elphbolt.f90->sourcefile~phonon.f90 sourcefile~symmetry.f90->sourcefile~crystal.f90 sourcefile~phonon.f90->sourcefile~crystal.f90 sourcefile~phonon.f90->sourcefile~numerics.f90 sourcefile~phonon.f90->sourcefile~wannier.f90 sourcefile~phonon.f90->sourcefile~symmetry.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules crystal_module Source Code crystal.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module crystal_module !! Module containing type and procedures related to the crystal structure. use params , only : dp , k8 , twopi use misc , only : exit_with_message , print_message , cross_product , demux_vector , & subtitle , trace implicit none private public crystal , calculate_wavevectors_full type crystal !! Data and procedures related to the crystal structure. integer ( k8 ) :: numelements !! Number of types of basis atoms. integer ( k8 ) :: numatoms !! Number of basis atoms. character ( len = 100 ) :: name !! Name of material. character ( len = 3 ), allocatable :: elements (:) !! Elements in the basis. integer ( k8 ), allocatable :: atomtypes (:) !! Integer tagging unique elements in the basis. real ( dp ), allocatable :: masses (:) !! Masses of the basis atoms. logical :: polar !! Is the system polar? real ( dp ) :: epsilon ( 3 , 3 ) !! Dielectric tensor. real ( dp ), allocatable :: born (:,:,:) !! Born effective charge. real ( dp ) :: epsilon0 !! Static dielectric constant. logical :: read_epsiloninf !! Read high-frequency dielectric constant? real ( dp ) :: epsiloninf !! High frequency dielectric constant. real ( dp ) :: qTF !! Thomas-Fermi screening wave vector. real ( dp ), allocatable :: basis (:,:) !! Basis vectors (crystal coordinates). real ( dp ), allocatable :: basis_cart (:,:) !! Basis vectors (Cartesian coordinates). real ( dp ) :: lattvecs ( 3 , 3 ) !! Lattice vectors (nm). real ( dp ) :: volume !! Volume of primitive cell (nm&#94;3). real ( dp ) :: reclattvecs ( 3 , 3 ) !! Reciprocal lattice vectors. real ( dp ) :: volume_bz !! Brillouin zone volume (nm&#94;-3). real ( dp ) :: T !! Crystal temperature (K). logical :: autoisotopes !! Use isotopic mix for masses? real ( dp ), allocatable :: gfactors (:) !! g-factors. real ( dp ), allocatable :: subs_masses (:) !! Masses of the substitutional atoms real ( dp ), allocatable :: subs_conc (:) !! Concentration of the substitutional atoms in cm&#94;-3 real ( dp ), allocatable :: subs_gfactors (:) !! g-factors for the substitutional defects. logical :: twod !! Is the system 2d? real ( dp ) :: dim !! Dimension of the system real ( dp ) :: thickness !! Thickness of the system contains procedure :: initialize => read_input_and_setup_crystal end type crystal contains subroutine read_input_and_setup_crystal ( c ) !! Read input file and initialize crystal data. class ( crystal ), intent ( out ) :: c !Local variables integer ( k8 ) :: i , j , k , numelements , numatoms integer ( k8 ), allocatable :: atomtypes (:), num_atomtypes (:) real ( dp ), allocatable :: masses (:), born (:,:,:), basis (:,:), & basis_cart (:,:), subs_perc (:), subs_masses (:), subs_conc (:) real ( dp ) :: epsilon ( 3 , 3 ), lattvecs ( 3 , 3 ), T , & epsilon0 , epsiloninf , subs_mavg character ( len = 3 ), allocatable :: elements (:) character ( len = 100 ) :: name logical :: polar , autoisotopes , read_epsiloninf , twod namelist / allocations / numelements , numatoms namelist / crystal_info / name , elements , atomtypes , basis , lattvecs , & polar , born , epsilon , read_epsiloninf , epsilon0 , epsiloninf , & masses , T , autoisotopes , twod , subs_masses , subs_conc call subtitle ( \"Setting up crystal...\" ) !Open input file open ( 1 , file = 'input.nml' , status = 'old' ) !Set values from input: !Read allocations numelements = 0 numatoms = 0 read ( 1 , nml = allocations ) if ( numelements < 1 . or . numatoms < 1 . or . numatoms < numelements ) then call exit_with_message ( 'Bad input(s) in allocations.' ) end if c % numelements = numelements c % numatoms = numatoms !Allocate variables allocate ( elements ( numelements ), atomtypes ( numatoms ), born ( 3 , 3 , numatoms ), & basis ( 3 , numatoms ), masses ( numelements ), basis_cart ( 3 , numatoms ), & subs_masses ( numelements ), subs_conc ( numelements ), subs_perc ( numelements ), & num_atomtypes ( numelements )) allocate ( c % elements ( c % numelements ), c % atomtypes ( c % numatoms ), c % born ( 3 , 3 , c % numatoms ), & c % masses ( c % numatoms ), c % gfactors ( c % numelements ), c % basis ( 3 , c % numatoms ), & c % basis_cart ( 3 , c % numatoms ), c % subs_masses ( c % numelements ), c % subs_conc ( c % numelements ), & c % subs_gfactors ( c % numelements )) !Read crystal_info name = trim ( adjustl ( 'Crystal' )) elements = 'X' atomtypes = 0 masses = - 1.0_dp autoisotopes = . true . lattvecs = 0.0_dp basis = 0.0_dp polar = . false . read_epsiloninf = . false . epsilon = 0.0_dp epsilon0 = 0.0_dp epsiloninf = 0.0_dp born = 0.0_dp T = - 1.0_dp twod = . false . subs_masses = 0.0_dp subs_conc = 0.0_dp read ( 1 , nml = crystal_info ) if ( any ( atomtypes < 1 ) . or . T < 0.0_dp ) then call exit_with_message ( 'Bad input(s) in crystal_info.' ) end if if (. not . autoisotopes . and . any ( masses < 0 )) then call exit_with_message ( 'Bad input(s) in crystal_info.' ) end if !Close input file close ( 1 ) c % name = name c % elements = elements c % atomtypes = atomtypes c % born = born c % epsilon = epsilon c % basis = basis c % polar = polar c % read_epsiloninf = read_epsiloninf c % epsilon0 = epsilon0 c % lattvecs = lattvecs c % T = T c % autoisotopes = autoisotopes c % masses = masses c % gfactors = 0.0_dp c % twod = twod c % subs_masses = subs_masses c % subs_conc = subs_conc if ( c % twod ) then if ( lattvecs ( 1 , 3 ) /= 0 . or . lattvecs ( 2 , 3 ) /= 0 . or . lattvecs ( 3 , 3 ) == 0 ) then call exit_with_message ( 'For 2d systems, cross plane lattice vector must be & &of the for (0 0 h).' ) end if c % thickness = lattvecs ( 3 , 3 ) c % dim = 2.0_dp else c % dim = 3.0_dp end if !Set high-frequency dielectric constant if ( c % read_epsiloninf ) then c % epsiloninf = epsiloninf else c % epsiloninf = trace ( c % epsilon ) / 3.0_dp end if !If required, calculate isotopic average masses and g-factors if ( autoisotopes ) then call calculate_mavg_and_g ( c % elements , c % masses , c % gfactors ) end if !Calculate atomic basis in Cartesian coordinates c % basis_cart (:,:) = matmul ( c % lattvecs , c % basis ) !Calculate reciprocal lattice vectors and real and reciprocal cell volumes do i = 1 , 3 j = mod ( i , 3 ) + 1 k = mod ( j , 3 ) + 1 c % reclattvecs (:, i ) = & cross_product ( c % lattvecs (:, j ), c % lattvecs (:, k )) end do c % volume = abs ( dot_product ( c % lattvecs (:, 1 ), c % reclattvecs (:, 1 ))) c % volume_bz = twopi / c % volume c % reclattvecs (:,:) = c % volume_bz * c % reclattvecs (:,:) !Calculate the number of atoms of each type num_atomtypes (:) = 0_k8 do i = 1 , c % numelements do j = 1 , c % numatoms if ( c % atomtypes ( j ) == i ) num_atomtypes ( i ) = num_atomtypes ( i ) + 1 end do end do !Convert number concentration of substitutions to percentage !of replaced host atoms. if ( twod ) then subs_perc = c % subs_conc * ( 1.0e-14_dp * c % volume / c % thickness ) / num_atomtypes * 10 0.0_dp else subs_perc = c % subs_conc * ( 1.0e-21_dp * c % volume ) / num_atomtypes * 10 0.0_dp end if !Calculate the mass variance parameters for the substitutions do i = 1 , c % numelements !Impurity and host mixed mass subs_mavg = ( subs_perc ( i ) * c % subs_masses ( i ) + & ( 10 0.0_dp - subs_perc ( i )) * c % masses ( i )) / 10 0.0_dp !g-factor c % subs_gfactors ( i ) = subs_perc ( i ) * ( 1.0_dp - c % subs_masses ( i ) / subs_mavg ) ** 2 + & ( 10 0.0_dp - subs_perc ( i )) * ( 1.0_dp - c % masses ( i ) / subs_mavg ) ** 2 end do c % subs_gfactors = c % subs_gfactors / 10 0.0_dp !Print out crystal and reciprocal lattice information. if ( this_image () == 1 ) then write ( * , \"(A, A)\" ) 'Material: ' , c % name if ( c % autoisotopes ) write ( * , \"(A)\" ) 'Isotopic average of masses will be used.' do i = 1 , c % numelements write ( * , \"(A, A, 1E16.8, A)\" ) trim ( c % elements ( i )), \" mass = \" , c % masses ( i ), \" u\" end do if ( any ( c % subs_conc /= 0.0_dp )) then do i = 1 , c % numelements write ( * , \"(A, A, 1E16.8, A)\" ) & trim ( c % elements ( i )), \" substitution mass = \" , c % subs_masses ( i ), \" u\" end do do i = 1 , c % numelements write ( * , \"(A, A, 1E16.8, A)\" ) & trim ( c % elements ( i )), \" substitution amount = \" , subs_perc ( i ), \" %\" end do end if write ( * , \"(A)\" ) 'Lattice vectors [nm]:' write ( * , \"(3(1E16.8,x))\" ) c % lattvecs (:, 1 ) write ( * , \"(3(1E16.8,x))\" ) c % lattvecs (:, 2 ) write ( * , \"(3(1E16.8,x))\" ) c % lattvecs (:, 3 ) write ( * , \"(A,(1E16.8,x),A)\" ) 'Primitive cell volume =' , c % volume , 'nm&#94;3' write ( * , \"(A)\" ) 'Reciprocal lattice vectors [1/nm]:' write ( * , \"(3(1E16.8,x))\" ) c % reclattvecs (:, 1 ) write ( * , \"(3(1E16.8,x))\" ) c % reclattvecs (:, 2 ) write ( * , \"(3(1E16.8,x))\" ) c % reclattvecs (:, 3 ) write ( * , \"(A,(1E16.8,x),A)\" ) 'Brillouin zone volume =' , c % volume_bz , '1/nm&#94;3' if ( c % twod ) write ( * , \"(A)\" ) 'System is 2d.' if ( c % polar ) then write ( * , \"(A)\" ) 'System is polar.' write ( * , \"(A)\" ) 'Dielectric tensor:' do i = 1 , 3 write ( * , \"(3(1E16.8,x))\" ) c % epsilon (:, i ) end do write ( * , \"(A)\" ) 'Born effective charges:' do i = 1 , c % numatoms write ( * , \"(A)\" ) trim ( c % elements ( c % atomtypes ( i ))) do j = 1 , 3 write ( * , \"(3(1E16.8,x))\" ) c % born (:, j , i ) end do end do write ( * , \"(A,1E16.8)\" ) 'Static dielectric (used for screening e-ch. imp. interactions) = ' , c % epsilon0 write ( * , \"(A,1E16.8)\" ) 'High-frequency dielectric = ' , c % epsiloninf end if write ( * , \"(A, F7.2, A)\" ) 'Crystal temperature = ' , c % T , ' K' end if end subroutine read_input_and_setup_crystal subroutine calculate_wavevectors_full ( mesh , wavevecs , blocks , indexlist ) !! Calculate wave vectors (crystal coords.) of the full Brillouin zone (FBZ) !! !! mesh is the array of number of points along the reciprocal lattice vectors !! wavevecs is the list of all the wave vectors integer ( k8 ), intent ( in ) :: mesh ( 3 ) logical , intent ( in ) :: blocks integer ( k8 ), optional , intent ( in ) :: indexlist (:) real ( dp ), allocatable , intent ( out ) :: wavevecs (:,:) integer ( k8 ) :: nwavevecs , ijk ( 3 ), i , imux if ( blocks . and . . not . present ( indexlist )) & call exit_with_message ( \"If blocks is true then indexlist must be present\" ) if ( blocks ) then nwavevecs = size ( indexlist ) else nwavevecs = product ( mesh ) end if allocate ( wavevecs ( nwavevecs , 3 )) do i = 1 , nwavevecs !run over total number of vectors if ( blocks ) then imux = indexlist ( i ) else imux = i end if call demux_vector ( imux , ijk , mesh , 0_k8 ) !get 0-based (i,j,k) indices wavevecs ( i ,:) = dble ( ijk ) / mesh !wave vectors in crystal coordinates end do end subroutine calculate_wavevectors_full subroutine calculate_mavg_and_g ( elements , m , g ) !! Compute the average mass of each element and its g-factor (Pearson !! deviation coefficient of the masses). !! !! This subroutine is adapted from ShengBTE. character ( len = 3 ), intent ( in ) :: elements (:) real ( dp ), intent ( out ) :: m (:), g (:) !Local variables integer ( k8 ) :: i , niso , nelems , e character ( len = 3 ) :: isotope_element ( 287 ) real ( dp ) :: isotope_mass ( 287 ) real ( dp ) :: isotope_abundance ( 287 ) nelems = size ( elements ) niso = 287 ! Fill in isotope data. isotope_element ( 1 ) = \"Ag\" isotope_mass ( 1 ) = 10 6.905095_dp isotope_abundance ( 1 ) = 5 1.84_dp isotope_element ( 2 ) = \"Ag\" isotope_mass ( 2 ) = 10 8.904754_dp isotope_abundance ( 2 ) = 4 8.16_dp isotope_element ( 3 ) = \"Al\" isotope_mass ( 3 ) = 2 6.981541_dp isotope_abundance ( 3 ) = 10 0.0_dp isotope_element ( 4 ) = \"Ar\" isotope_mass ( 4 ) = 3 5.967546_dp isotope_abundance ( 4 ) = 0.34_dp isotope_element ( 5 ) = \"Ar\" isotope_mass ( 5 ) = 3 7.962732_dp isotope_abundance ( 5 ) = 0.063_dp isotope_element ( 6 ) = \"Ar\" isotope_mass ( 6 ) = 3 9.962383_dp isotope_abundance ( 6 ) = 9 9.6_dp isotope_element ( 7 ) = \"As\" isotope_mass ( 7 ) = 7 4.921596_dp isotope_abundance ( 7 ) = 10 0.0_dp isotope_element ( 8 ) = \"Au\" isotope_mass ( 8 ) = 19 6.96656_dp isotope_abundance ( 8 ) = 10 0.0_dp isotope_element ( 9 ) = \"B\" isotope_mass ( 9 ) = 1 0.012938_dp isotope_abundance ( 9 ) = 1 9.8_dp isotope_element ( 10 ) = \"B\" isotope_mass ( 10 ) = 1 1.009305_dp isotope_abundance ( 10 ) = 8 0.2_dp isotope_element ( 11 ) = \"Ba\" isotope_mass ( 11 ) = 12 9.906277_dp isotope_abundance ( 11 ) = 0.11_dp isotope_element ( 12 ) = \"Ba\" isotope_mass ( 12 ) = 13 1.905042_dp isotope_abundance ( 12 ) = 0.1_dp isotope_element ( 13 ) = \"Ba\" isotope_mass ( 13 ) = 13 3.90449_dp isotope_abundance ( 13 ) = 2.42_dp isotope_element ( 14 ) = \"Ba\" isotope_mass ( 14 ) = 13 4.905668_dp isotope_abundance ( 14 ) = 6.59_dp isotope_element ( 15 ) = \"Ba\" isotope_mass ( 15 ) = 13 5.904556_dp isotope_abundance ( 15 ) = 7.85_dp isotope_element ( 16 ) = \"Ba\" isotope_mass ( 16 ) = 13 6.905816_dp isotope_abundance ( 16 ) = 1 1.23_dp isotope_element ( 17 ) = \"Ba\" isotope_mass ( 17 ) = 13 7.905236_dp isotope_abundance ( 17 ) = 7 1.7_dp isotope_element ( 18 ) = \"Be\" isotope_mass ( 18 ) = 9.012183_dp isotope_abundance ( 18 ) = 10 0.0_dp isotope_element ( 19 ) = \"Bi\" isotope_mass ( 19 ) = 20 8.980388_dp isotope_abundance ( 19 ) = 10 0.0_dp isotope_element ( 20 ) = \"Br\" isotope_mass ( 20 ) = 7 8.918336_dp isotope_abundance ( 20 ) = 5 0.69_dp isotope_element ( 21 ) = \"Br\" isotope_mass ( 21 ) = 8 0.91629_dp isotope_abundance ( 21 ) = 4 9.31_dp isotope_element ( 22 ) = \"C\" isotope_mass ( 22 ) = 1 2.0_dp isotope_abundance ( 22 ) = 9 8.9_dp isotope_element ( 23 ) = \"C\" isotope_mass ( 23 ) = 1 3.003355_dp isotope_abundance ( 23 ) = 1.1_dp isotope_element ( 24 ) = \"Ca\" isotope_mass ( 24 ) = 3 9.962591_dp isotope_abundance ( 24 ) = 9 6.95_dp isotope_element ( 25 ) = \"Ca\" isotope_mass ( 25 ) = 4 1.958622_dp isotope_abundance ( 25 ) = 0.65_dp isotope_element ( 26 ) = \"Ca\" isotope_mass ( 26 ) = 4 2.95877_dp isotope_abundance ( 26 ) = 0.14_dp isotope_element ( 27 ) = \"Ca\" isotope_mass ( 27 ) = 4 3.955485_dp isotope_abundance ( 27 ) = 2.086_dp isotope_element ( 28 ) = \"Ca\" isotope_mass ( 28 ) = 4 5.953689_dp isotope_abundance ( 28 ) = 0.004_dp isotope_element ( 29 ) = \"Ca\" isotope_mass ( 29 ) = 4 7.952532_dp isotope_abundance ( 29 ) = 0.19_dp isotope_element ( 30 ) = \"Cd\" isotope_mass ( 30 ) = 10 5.906461_dp isotope_abundance ( 30 ) = 1.25_dp isotope_element ( 31 ) = \"Cd\" isotope_mass ( 31 ) = 10 7.904186_dp isotope_abundance ( 31 ) = 0.89_dp isotope_element ( 32 ) = \"Cd\" isotope_mass ( 32 ) = 10 9.903007_dp isotope_abundance ( 32 ) = 1 2.49_dp isotope_element ( 33 ) = \"Cd\" isotope_mass ( 33 ) = 11 0.904182_dp isotope_abundance ( 33 ) = 1 2.8_dp isotope_element ( 34 ) = \"Cd\" isotope_mass ( 34 ) = 11 1.902761_dp isotope_abundance ( 34 ) = 2 4.13_dp isotope_element ( 35 ) = \"Cd\" isotope_mass ( 35 ) = 11 2.904401_dp isotope_abundance ( 35 ) = 1 2.22_dp isotope_element ( 36 ) = \"Cd\" isotope_mass ( 36 ) = 11 3.903361_dp isotope_abundance ( 36 ) = 2 8.73_dp isotope_element ( 37 ) = \"Cd\" isotope_mass ( 37 ) = 11 5.904758_dp isotope_abundance ( 37 ) = 7.49_dp isotope_element ( 38 ) = \"Ce\" isotope_mass ( 38 ) = 13 5.90714_dp isotope_abundance ( 38 ) = 0.19_dp isotope_element ( 39 ) = \"Ce\" isotope_mass ( 39 ) = 13 7.905996_dp isotope_abundance ( 39 ) = 0.25_dp isotope_element ( 40 ) = \"Ce\" isotope_mass ( 40 ) = 13 9.905442_dp isotope_abundance ( 40 ) = 8 8.48_dp isotope_element ( 41 ) = \"Ce\" isotope_mass ( 41 ) = 14 1.909249_dp isotope_abundance ( 41 ) = 1 1.08_dp isotope_element ( 42 ) = \"Cl\" isotope_mass ( 42 ) = 3 4.968853_dp isotope_abundance ( 42 ) = 7 5.77_dp isotope_element ( 43 ) = \"Cl\" isotope_mass ( 43 ) = 3 6.965903_dp isotope_abundance ( 43 ) = 2 4.23_dp isotope_element ( 44 ) = \"Co\" isotope_mass ( 44 ) = 5 8.933198_dp isotope_abundance ( 44 ) = 10 0.0_dp isotope_element ( 45 ) = \"Cr\" isotope_mass ( 45 ) = 4 9.946046_dp isotope_abundance ( 45 ) = 4.35_dp isotope_element ( 46 ) = \"Cr\" isotope_mass ( 46 ) = 5 1.94051_dp isotope_abundance ( 46 ) = 8 3.79_dp isotope_element ( 47 ) = \"Cr\" isotope_mass ( 47 ) = 5 2.940651_dp isotope_abundance ( 47 ) = 9.5_dp isotope_element ( 48 ) = \"Cr\" isotope_mass ( 48 ) = 5 3.938882_dp isotope_abundance ( 48 ) = 2.36_dp isotope_element ( 49 ) = \"Cs\" isotope_mass ( 49 ) = 13 2.905433_dp isotope_abundance ( 49 ) = 10 0.0_dp isotope_element ( 50 ) = \"Cu\" isotope_mass ( 50 ) = 6 2.929599_dp isotope_abundance ( 50 ) = 6 9.17_dp isotope_element ( 51 ) = \"Cu\" isotope_mass ( 51 ) = 6 4.927792_dp isotope_abundance ( 51 ) = 3 0.83_dp isotope_element ( 52 ) = \"Dy\" isotope_mass ( 52 ) = 15 5.924287_dp isotope_abundance ( 52 ) = 0.06_dp isotope_element ( 53 ) = \"Dy\" isotope_mass ( 53 ) = 15 7.924412_dp isotope_abundance ( 53 ) = 0.1_dp isotope_element ( 54 ) = \"Dy\" isotope_mass ( 54 ) = 15 9.925203_dp isotope_abundance ( 54 ) = 2.34_dp isotope_element ( 55 ) = \"Dy\" isotope_mass ( 55 ) = 16 0.926939_dp isotope_abundance ( 55 ) = 1 8.9_dp isotope_element ( 56 ) = \"Dy\" isotope_mass ( 56 ) = 16 1.926805_dp isotope_abundance ( 56 ) = 2 5.5_dp isotope_element ( 57 ) = \"Dy\" isotope_mass ( 57 ) = 16 2.928737_dp isotope_abundance ( 57 ) = 2 4.9_dp isotope_element ( 58 ) = \"Dy\" isotope_mass ( 58 ) = 16 3.929183_dp isotope_abundance ( 58 ) = 2 8.2_dp isotope_element ( 59 ) = \"Er\" isotope_mass ( 59 ) = 16 1.928787_dp isotope_abundance ( 59 ) = 0.14_dp isotope_element ( 60 ) = \"Er\" isotope_mass ( 60 ) = 16 3.929211_dp isotope_abundance ( 60 ) = 1.61_dp isotope_element ( 61 ) = \"Er\" isotope_mass ( 61 ) = 16 5.930305_dp isotope_abundance ( 61 ) = 3 3.6_dp isotope_element ( 62 ) = \"Er\" isotope_mass ( 62 ) = 16 6.932061_dp isotope_abundance ( 62 ) = 2 2.95_dp isotope_element ( 63 ) = \"Er\" isotope_mass ( 63 ) = 16 7.932383_dp isotope_abundance ( 63 ) = 2 6.8_dp isotope_element ( 64 ) = \"Er\" isotope_mass ( 64 ) = 16 9.935476_dp isotope_abundance ( 64 ) = 1 4.9_dp isotope_element ( 65 ) = \"Eu\" isotope_mass ( 65 ) = 15 0.91986_dp isotope_abundance ( 65 ) = 4 7.8_dp isotope_element ( 66 ) = \"Eu\" isotope_mass ( 66 ) = 15 2.921243_dp isotope_abundance ( 66 ) = 5 2.2_dp isotope_element ( 67 ) = \"F\" isotope_mass ( 67 ) = 1 8.998403_dp isotope_abundance ( 67 ) = 10 0.0_dp isotope_element ( 68 ) = \"Fe\" isotope_mass ( 68 ) = 5 3.939612_dp isotope_abundance ( 68 ) = 5.8_dp isotope_element ( 69 ) = \"Fe\" isotope_mass ( 69 ) = 5 5.934939_dp isotope_abundance ( 69 ) = 9 1.72_dp isotope_element ( 70 ) = \"Fe\" isotope_mass ( 70 ) = 5 6.935396_dp isotope_abundance ( 70 ) = 2.2_dp isotope_element ( 71 ) = \"Fe\" isotope_mass ( 71 ) = 5 7.933278_dp isotope_abundance ( 71 ) = 0.28_dp isotope_element ( 72 ) = \"Ga\" isotope_mass ( 72 ) = 6 8.925581_dp isotope_abundance ( 72 ) = 6 0.1_dp isotope_element ( 73 ) = \"Ga\" isotope_mass ( 73 ) = 7 0.924701_dp isotope_abundance ( 73 ) = 3 9.9_dp isotope_element ( 74 ) = \"Gd\" isotope_mass ( 74 ) = 15 1.919803_dp isotope_abundance ( 74 ) = 0.2_dp isotope_element ( 75 ) = \"Gd\" isotope_mass ( 75 ) = 15 3.920876_dp isotope_abundance ( 75 ) = 2.18_dp isotope_element ( 76 ) = \"Gd\" isotope_mass ( 76 ) = 15 4.822629_dp isotope_abundance ( 76 ) = 1 4.8_dp isotope_element ( 77 ) = \"Gd\" isotope_mass ( 77 ) = 15 5.92213_dp isotope_abundance ( 77 ) = 2 0.47_dp isotope_element ( 78 ) = \"Gd\" isotope_mass ( 78 ) = 15 6.923967_dp isotope_abundance ( 78 ) = 1 5.65_dp isotope_element ( 79 ) = \"Gd\" isotope_mass ( 79 ) = 15 7.924111_dp isotope_abundance ( 79 ) = 2 4.84_dp isotope_element ( 80 ) = \"Gd\" isotope_mass ( 80 ) = 15 9.927061_dp isotope_abundance ( 80 ) = 2 1.86_dp isotope_element ( 81 ) = \"Ge\" isotope_mass ( 81 ) = 6 9.92425_dp isotope_abundance ( 81 ) = 2 0.5_dp isotope_element ( 82 ) = \"Ge\" isotope_mass ( 82 ) = 7 1.92208_dp isotope_abundance ( 82 ) = 2 7.4_dp isotope_element ( 83 ) = \"Ge\" isotope_mass ( 83 ) = 7 2.923464_dp isotope_abundance ( 83 ) = 7.8_dp isotope_element ( 84 ) = \"Ge\" isotope_mass ( 84 ) = 7 3.921179_dp isotope_abundance ( 84 ) = 3 6.5_dp isotope_element ( 85 ) = \"Ge\" isotope_mass ( 85 ) = 7 5.921403_dp isotope_abundance ( 85 ) = 7.8_dp isotope_element ( 86 ) = \"H\" isotope_mass ( 86 ) = 1.007825_dp isotope_abundance ( 86 ) = 9 9.99_dp isotope_element ( 87 ) = \"H\" isotope_mass ( 87 ) = 2.014102_dp isotope_abundance ( 87 ) = 0.015_dp isotope_element ( 88 ) = \"He\" isotope_mass ( 88 ) = 3.016029_dp isotope_abundance ( 88 ) = 0.0001_dp isotope_element ( 89 ) = \"He\" isotope_mass ( 89 ) = 4.002603_dp isotope_abundance ( 89 ) = 10 0.0_dp isotope_element ( 90 ) = \"Hf\" isotope_mass ( 90 ) = 17 3.940065_dp isotope_abundance ( 90 ) = 0.16_dp isotope_element ( 91 ) = \"Hf\" isotope_mass ( 91 ) = 17 5.94142_dp isotope_abundance ( 91 ) = 5.2_dp isotope_element ( 92 ) = \"Hf\" isotope_mass ( 92 ) = 17 6.943233_dp isotope_abundance ( 92 ) = 1 8.6_dp isotope_element ( 93 ) = \"Hf\" isotope_mass ( 93 ) = 17 7.94371_dp isotope_abundance ( 93 ) = 2 7.1_dp isotope_element ( 94 ) = \"Hf\" isotope_mass ( 94 ) = 17 8.945827_dp isotope_abundance ( 94 ) = 1 3.74_dp isotope_element ( 95 ) = \"Hf\" isotope_mass ( 95 ) = 17 9.946561_dp isotope_abundance ( 95 ) = 3 5.2_dp isotope_element ( 96 ) = \"Hg\" isotope_mass ( 96 ) = 19 5.965812_dp isotope_abundance ( 96 ) = 0.15_dp isotope_element ( 97 ) = \"Hg\" isotope_mass ( 97 ) = 19 7.96676_dp isotope_abundance ( 97 ) = 1 0.1_dp isotope_element ( 98 ) = \"Hg\" isotope_mass ( 98 ) = 19 8.968269_dp isotope_abundance ( 98 ) = 1 7.0_dp isotope_element ( 99 ) = \"Hg\" isotope_mass ( 99 ) = 19 9.968316_dp isotope_abundance ( 99 ) = 2 3.1_dp isotope_element ( 100 ) = \"Hg\" isotope_mass ( 100 ) = 20 0.970293_dp isotope_abundance ( 100 ) = 1 3.2_dp isotope_element ( 101 ) = \"Hg\" isotope_mass ( 101 ) = 20 1.970632_dp isotope_abundance ( 101 ) = 2 9.65_dp isotope_element ( 102 ) = \"Hg\" isotope_mass ( 102 ) = 20 3.973481_dp isotope_abundance ( 102 ) = 6.8_dp isotope_element ( 103 ) = \"Ho\" isotope_mass ( 103 ) = 16 4.930332_dp isotope_abundance ( 103 ) = 10 0.0_dp isotope_element ( 104 ) = \"I\" isotope_mass ( 104 ) = 12 6.904477_dp isotope_abundance ( 104 ) = 10 0.0_dp isotope_element ( 105 ) = \"In\" isotope_mass ( 105 ) = 11 2.904056_dp isotope_abundance ( 105 ) = 4.3_dp isotope_element ( 106 ) = \"In\" isotope_mass ( 106 ) = 11 4.903875_dp isotope_abundance ( 106 ) = 9 5.7_dp isotope_element ( 107 ) = \"Ir\" isotope_mass ( 107 ) = 19 0.960603_dp isotope_abundance ( 107 ) = 3 7.3_dp isotope_element ( 108 ) = \"Ir\" isotope_mass ( 108 ) = 19 2.962942_dp isotope_abundance ( 108 ) = 6 2.7_dp isotope_element ( 109 ) = \"K\" isotope_mass ( 109 ) = 3 8.963708_dp isotope_abundance ( 109 ) = 9 3.2_dp isotope_element ( 110 ) = \"K\" isotope_mass ( 110 ) = 3 9.963999_dp isotope_abundance ( 110 ) = 0.012_dp isotope_element ( 111 ) = \"K\" isotope_mass ( 111 ) = 4 0.961825_dp isotope_abundance ( 111 ) = 6.73_dp isotope_element ( 112 ) = \"Kr\" isotope_mass ( 112 ) = 7 7.920397_dp isotope_abundance ( 112 ) = 0.35_dp isotope_element ( 113 ) = \"Kr\" isotope_mass ( 113 ) = 7 9.916375_dp isotope_abundance ( 113 ) = 2.25_dp isotope_element ( 114 ) = \"Kr\" isotope_mass ( 114 ) = 8 1.913483_dp isotope_abundance ( 114 ) = 1 1.6_dp isotope_element ( 115 ) = \"Kr\" isotope_mass ( 115 ) = 8 2.914134_dp isotope_abundance ( 115 ) = 1 1.5_dp isotope_element ( 116 ) = \"Kr\" isotope_mass ( 116 ) = 8 3.911506_dp isotope_abundance ( 116 ) = 5 7.0_dp isotope_element ( 117 ) = \"Kr\" isotope_mass ( 117 ) = 8 5.910614_dp isotope_abundance ( 117 ) = 1 7.3_dp isotope_element ( 118 ) = \"La\" isotope_mass ( 118 ) = 13 7.907114_dp isotope_abundance ( 118 ) = 0.09_dp isotope_element ( 119 ) = \"La\" isotope_mass ( 119 ) = 13 8.906355_dp isotope_abundance ( 119 ) = 9 9.91_dp isotope_element ( 120 ) = \"Li\" isotope_mass ( 120 ) = 6.015123_dp isotope_abundance ( 120 ) = 7.42_dp isotope_element ( 121 ) = \"Li\" isotope_mass ( 121 ) = 7.016005_dp isotope_abundance ( 121 ) = 9 2.58_dp isotope_element ( 122 ) = \"Lu\" isotope_mass ( 122 ) = 17 4.940785_dp isotope_abundance ( 122 ) = 9 7.4_dp isotope_element ( 123 ) = \"Lu\" isotope_mass ( 123 ) = 17 5.942694_dp isotope_abundance ( 123 ) = 2.6_dp isotope_element ( 124 ) = \"Mg\" isotope_mass ( 124 ) = 2 3.985045_dp isotope_abundance ( 124 ) = 7 8.9_dp isotope_element ( 125 ) = \"Mg\" isotope_mass ( 125 ) = 2 4.985839_dp isotope_abundance ( 125 ) = 1 0.0_dp isotope_element ( 126 ) = \"Mg\" isotope_mass ( 126 ) = 2 5.982595_dp isotope_abundance ( 126 ) = 1 1.1_dp isotope_element ( 127 ) = \"Mn\" isotope_mass ( 127 ) = 5 4.938046_dp isotope_abundance ( 127 ) = 10 0.0_dp isotope_element ( 128 ) = \"Mo\" isotope_mass ( 128 ) = 9 1.906809_dp isotope_abundance ( 128 ) = 1 4.84_dp isotope_element ( 129 ) = \"Mo\" isotope_mass ( 129 ) = 9 3.905086_dp isotope_abundance ( 129 ) = 9.25_dp isotope_element ( 130 ) = \"Mo\" isotope_mass ( 130 ) = 9 4.905838_dp isotope_abundance ( 130 ) = 1 5.92_dp isotope_element ( 131 ) = \"Mo\" isotope_mass ( 131 ) = 9 5.904676_dp isotope_abundance ( 131 ) = 1 6.68_dp isotope_element ( 132 ) = \"Mo\" isotope_mass ( 132 ) = 9 6.906018_dp isotope_abundance ( 132 ) = 9.55_dp isotope_element ( 133 ) = \"Mo\" isotope_mass ( 133 ) = 9 7.905405_dp isotope_abundance ( 133 ) = 2 4.13_dp isotope_element ( 134 ) = \"Mo\" isotope_mass ( 134 ) = 9 9.907473_dp isotope_abundance ( 134 ) = 9.63_dp isotope_element ( 135 ) = \"N\" isotope_mass ( 135 ) = 1 4.003074_dp isotope_abundance ( 135 ) = 9 9.63_dp isotope_element ( 136 ) = \"N\" isotope_mass ( 136 ) = 1 5.000109_dp isotope_abundance ( 136 ) = 0.37_dp isotope_element ( 137 ) = \"Na\" isotope_mass ( 137 ) = 2 2.98977_dp isotope_abundance ( 137 ) = 10 0.0_dp isotope_element ( 138 ) = \"Nb\" isotope_mass ( 138 ) = 9 2.906378_dp isotope_abundance ( 138 ) = 10 0.0_dp isotope_element ( 139 ) = \"Nd\" isotope_mass ( 139 ) = 14 1.907731_dp isotope_abundance ( 139 ) = 2 7.13_dp isotope_element ( 140 ) = \"Nd\" isotope_mass ( 140 ) = 14 2.909823_dp isotope_abundance ( 140 ) = 1 2.18_dp isotope_element ( 141 ) = \"Nd\" isotope_mass ( 141 ) = 14 3.910096_dp isotope_abundance ( 141 ) = 2 3.8_dp isotope_element ( 142 ) = \"Nd\" isotope_mass ( 142 ) = 14 4.912582_dp isotope_abundance ( 142 ) = 8.3_dp isotope_element ( 143 ) = \"Nd\" isotope_mass ( 143 ) = 14 5.913126_dp isotope_abundance ( 143 ) = 1 7.19_dp isotope_element ( 144 ) = \"Nd\" isotope_mass ( 144 ) = 14 7.916901_dp isotope_abundance ( 144 ) = 5.76_dp isotope_element ( 145 ) = \"Nd\" isotope_mass ( 145 ) = 14 9.9209_dp isotope_abundance ( 145 ) = 5.64_dp isotope_element ( 146 ) = \"Ne\" isotope_mass ( 146 ) = 1 9.992439_dp isotope_abundance ( 146 ) = 9 0.6_dp isotope_element ( 147 ) = \"Ne\" isotope_mass ( 147 ) = 2 0.993845_dp isotope_abundance ( 147 ) = 0.26_dp isotope_element ( 148 ) = \"Ne\" isotope_mass ( 148 ) = 2 1.991384_dp isotope_abundance ( 148 ) = 9.2_dp isotope_element ( 149 ) = \"Ni\" isotope_mass ( 149 ) = 5 7.935347_dp isotope_abundance ( 149 ) = 6 8.27_dp isotope_element ( 150 ) = \"Ni\" isotope_mass ( 150 ) = 5 9.930789_dp isotope_abundance ( 150 ) = 2 6.1_dp isotope_element ( 151 ) = \"Ni\" isotope_mass ( 151 ) = 6 0.931059_dp isotope_abundance ( 151 ) = 1.13_dp isotope_element ( 152 ) = \"Ni\" isotope_mass ( 152 ) = 6 1.928346_dp isotope_abundance ( 152 ) = 3.59_dp isotope_element ( 153 ) = \"Ni\" isotope_mass ( 153 ) = 6 3.927968_dp isotope_abundance ( 153 ) = 0.91_dp isotope_element ( 154 ) = \"O\" isotope_mass ( 154 ) = 1 5.994915_dp isotope_abundance ( 154 ) = 9 9.76_dp isotope_element ( 155 ) = \"O\" isotope_mass ( 155 ) = 1 6.999131_dp isotope_abundance ( 155 ) = 0.038_dp isotope_element ( 156 ) = \"O\" isotope_mass ( 156 ) = 1 7.999159_dp isotope_abundance ( 156 ) = 0.2_dp isotope_element ( 157 ) = \"Os\" isotope_mass ( 157 ) = 18 3.952514_dp isotope_abundance ( 157 ) = 0.02_dp isotope_element ( 158 ) = \"Os\" isotope_mass ( 158 ) = 18 5.953852_dp isotope_abundance ( 158 ) = 1.58_dp isotope_element ( 159 ) = \"Os\" isotope_mass ( 159 ) = 18 6.955762_dp isotope_abundance ( 159 ) = 1.6_dp isotope_element ( 160 ) = \"Os\" isotope_mass ( 160 ) = 18 7.95585_dp isotope_abundance ( 160 ) = 1 3.3_dp isotope_element ( 161 ) = \"Os\" isotope_mass ( 161 ) = 18 8.958156_dp isotope_abundance ( 161 ) = 1 6.1_dp isotope_element ( 162 ) = \"Os\" isotope_mass ( 162 ) = 18 9.958455_dp isotope_abundance ( 162 ) = 2 6.4_dp isotope_element ( 163 ) = \"Os\" isotope_mass ( 163 ) = 19 1.961487_dp isotope_abundance ( 163 ) = 4 1.0_dp isotope_element ( 164 ) = \"P\" isotope_mass ( 164 ) = 3 0.973763_dp isotope_abundance ( 164 ) = 10 0.0_dp isotope_element ( 165 ) = \"Pb\" isotope_mass ( 165 ) = 20 3.973037_dp isotope_abundance ( 165 ) = 1.4_dp isotope_element ( 166 ) = \"Pb\" isotope_mass ( 166 ) = 20 5.974455_dp isotope_abundance ( 166 ) = 2 4.1_dp isotope_element ( 167 ) = \"Pb\" isotope_mass ( 167 ) = 20 6.975885_dp isotope_abundance ( 167 ) = 2 2.1_dp isotope_element ( 168 ) = \"Pb\" isotope_mass ( 168 ) = 20 7.976641_dp isotope_abundance ( 168 ) = 5 2.4_dp isotope_element ( 169 ) = \"Pd\" isotope_mass ( 169 ) = 10 1.905609_dp isotope_abundance ( 169 ) = 1.02_dp isotope_element ( 170 ) = \"Pd\" isotope_mass ( 170 ) = 10 3.904026_dp isotope_abundance ( 170 ) = 1 1.14_dp isotope_element ( 171 ) = \"Pd\" isotope_mass ( 171 ) = 10 4.905075_dp isotope_abundance ( 171 ) = 2 2.33_dp isotope_element ( 172 ) = \"Pd\" isotope_mass ( 172 ) = 10 5.903475_dp isotope_abundance ( 172 ) = 2 7.33_dp isotope_element ( 173 ) = \"Pd\" isotope_mass ( 173 ) = 10 7.903894_dp isotope_abundance ( 173 ) = 2 6.46_dp isotope_element ( 174 ) = \"Pd\" isotope_mass ( 174 ) = 10 9.905169_dp isotope_abundance ( 174 ) = 1 1.72_dp isotope_element ( 175 ) = \"Pr\" isotope_mass ( 175 ) = 14 0.907657_dp isotope_abundance ( 175 ) = 10 0.0_dp isotope_element ( 176 ) = \"Pt\" isotope_mass ( 176 ) = 18 9.959937_dp isotope_abundance ( 176 ) = 0.01_dp isotope_element ( 177 ) = \"Pt\" isotope_mass ( 177 ) = 19 1.961049_dp isotope_abundance ( 177 ) = 0.79_dp isotope_element ( 178 ) = \"Pt\" isotope_mass ( 178 ) = 19 3.962679_dp isotope_abundance ( 178 ) = 3 2.9_dp isotope_element ( 179 ) = \"Pt\" isotope_mass ( 179 ) = 19 4.964785_dp isotope_abundance ( 179 ) = 3 3.8_dp isotope_element ( 180 ) = \"Pt\" isotope_mass ( 180 ) = 19 5.964947_dp isotope_abundance ( 180 ) = 2 5.3_dp isotope_element ( 181 ) = \"Pt\" isotope_mass ( 181 ) = 19 7.967879_dp isotope_abundance ( 181 ) = 7.2_dp isotope_element ( 182 ) = \"Rb\" isotope_mass ( 182 ) = 8 4.9118_dp isotope_abundance ( 182 ) = 7 2.17_dp isotope_element ( 183 ) = \"Rb\" isotope_mass ( 183 ) = 8 6.909184_dp isotope_abundance ( 183 ) = 2 7.84_dp isotope_element ( 184 ) = \"Re\" isotope_mass ( 184 ) = 18 4.952977_dp isotope_abundance ( 184 ) = 3 7.4_dp isotope_element ( 185 ) = \"Re\" isotope_mass ( 185 ) = 18 6.955765_dp isotope_abundance ( 185 ) = 6 2.6_dp isotope_element ( 186 ) = \"Rh\" isotope_mass ( 186 ) = 10 2.905503_dp isotope_abundance ( 186 ) = 10 0.0_dp isotope_element ( 187 ) = \"Ru\" isotope_mass ( 187 ) = 9 5.907596_dp isotope_abundance ( 187 ) = 5.52_dp isotope_element ( 188 ) = \"Ru\" isotope_mass ( 188 ) = 9 7.905287_dp isotope_abundance ( 188 ) = 1.88_dp isotope_element ( 189 ) = \"Ru\" isotope_mass ( 189 ) = 9 8.905937_dp isotope_abundance ( 189 ) = 1 2.7_dp isotope_element ( 190 ) = \"Ru\" isotope_mass ( 190 ) = 9 9.904218_dp isotope_abundance ( 190 ) = 1 2.6_dp isotope_element ( 191 ) = \"Ru\" isotope_mass ( 191 ) = 10 0.905581_dp isotope_abundance ( 191 ) = 1 7.0_dp isotope_element ( 192 ) = \"Ru\" isotope_mass ( 192 ) = 10 1.904348_dp isotope_abundance ( 192 ) = 3 1.6_dp isotope_element ( 193 ) = \"Ru\" isotope_mass ( 193 ) = 10 3.905422_dp isotope_abundance ( 193 ) = 1 8.7_dp isotope_element ( 194 ) = \"S\" isotope_mass ( 194 ) = 3 1.972072_dp isotope_abundance ( 194 ) = 9 5.02_dp isotope_element ( 195 ) = \"S\" isotope_mass ( 195 ) = 3 2.971459_dp isotope_abundance ( 195 ) = 0.75_dp isotope_element ( 196 ) = \"S\" isotope_mass ( 196 ) = 3 3.967868_dp isotope_abundance ( 196 ) = 4.21_dp isotope_element ( 197 ) = \"S\" isotope_mass ( 197 ) = 3 5.967079_dp isotope_abundance ( 197 ) = 0.02_dp isotope_element ( 198 ) = \"Sb\" isotope_mass ( 198 ) = 12 0.903824_dp isotope_abundance ( 198 ) = 5 7.3_dp isotope_element ( 199 ) = \"Sb\" isotope_mass ( 199 ) = 12 2.904222_dp isotope_abundance ( 199 ) = 4 2.7_dp isotope_element ( 200 ) = \"Sc\" isotope_mass ( 200 ) = 4 4.955914_dp isotope_abundance ( 200 ) = 10 0.0_dp isotope_element ( 201 ) = \"Se\" isotope_mass ( 201 ) = 7 3.922477_dp isotope_abundance ( 201 ) = 0.9_dp isotope_element ( 202 ) = \"Se\" isotope_mass ( 202 ) = 7 5.919207_dp isotope_abundance ( 202 ) = 9.0_dp isotope_element ( 203 ) = \"Se\" isotope_mass ( 203 ) = 7 6.919908_dp isotope_abundance ( 203 ) = 7.6_dp isotope_element ( 204 ) = \"Se\" isotope_mass ( 204 ) = 7 7.917304_dp isotope_abundance ( 204 ) = 2 3.5_dp isotope_element ( 205 ) = \"Se\" isotope_mass ( 205 ) = 7 9.916521_dp isotope_abundance ( 205 ) = 4 9.6_dp isotope_element ( 206 ) = \"Se\" isotope_mass ( 206 ) = 8 1.916709_dp isotope_abundance ( 206 ) = 9.4_dp isotope_element ( 207 ) = \"Si\" isotope_mass ( 207 ) = 2 7.976928_dp isotope_abundance ( 207 ) = 9 2.23_dp isotope_element ( 208 ) = \"Si\" isotope_mass ( 208 ) = 2 8.976496_dp isotope_abundance ( 208 ) = 4.67_dp isotope_element ( 209 ) = \"Si\" isotope_mass ( 209 ) = 2 9.973772_dp isotope_abundance ( 209 ) = 3.1_dp isotope_element ( 210 ) = \"Sm\" isotope_mass ( 210 ) = 14 3.912009_dp isotope_abundance ( 210 ) = 3.1_dp isotope_element ( 211 ) = \"Sm\" isotope_mass ( 211 ) = 14 6.914907_dp isotope_abundance ( 211 ) = 1 5.0_dp isotope_element ( 212 ) = \"Sm\" isotope_mass ( 212 ) = 14 7.914832_dp isotope_abundance ( 212 ) = 1 1.3_dp isotope_element ( 213 ) = \"Sm\" isotope_mass ( 213 ) = 14 8.917193_dp isotope_abundance ( 213 ) = 1 3.8_dp isotope_element ( 214 ) = \"Sm\" isotope_mass ( 214 ) = 14 9.917285_dp isotope_abundance ( 214 ) = 7.4_dp isotope_element ( 215 ) = \"Sm\" isotope_mass ( 215 ) = 15 1.919741_dp isotope_abundance ( 215 ) = 2 6.7_dp isotope_element ( 216 ) = \"Sm\" isotope_mass ( 216 ) = 15 3.922218_dp isotope_abundance ( 216 ) = 2 2.7_dp isotope_element ( 217 ) = \"Sn\" isotope_mass ( 217 ) = 11 1.904826_dp isotope_abundance ( 217 ) = 0.97_dp isotope_element ( 218 ) = \"Sn\" isotope_mass ( 218 ) = 11 3.902784_dp isotope_abundance ( 218 ) = 0.65_dp isotope_element ( 219 ) = \"Sn\" isotope_mass ( 219 ) = 11 4.903348_dp isotope_abundance ( 219 ) = 0.36_dp isotope_element ( 220 ) = \"Sn\" isotope_mass ( 220 ) = 11 5.901744_dp isotope_abundance ( 220 ) = 1 4.7_dp isotope_element ( 221 ) = \"Sn\" isotope_mass ( 221 ) = 11 6.902954_dp isotope_abundance ( 221 ) = 7.7_dp isotope_element ( 222 ) = \"Sn\" isotope_mass ( 222 ) = 11 7.901607_dp isotope_abundance ( 222 ) = 2 4.3_dp isotope_element ( 223 ) = \"Sn\" isotope_mass ( 223 ) = 11 8.90331_dp isotope_abundance ( 223 ) = 8.6_dp isotope_element ( 224 ) = \"Sn\" isotope_mass ( 224 ) = 11 9.902199_dp isotope_abundance ( 224 ) = 3 2.4_dp isotope_element ( 225 ) = \"Sn\" isotope_mass ( 225 ) = 12 1.90344_dp isotope_abundance ( 225 ) = 4.6_dp isotope_element ( 226 ) = \"Sn\" isotope_mass ( 226 ) = 12 3.905271_dp isotope_abundance ( 226 ) = 5.6_dp isotope_element ( 227 ) = \"Sr\" isotope_mass ( 227 ) = 8 3.913428_dp isotope_abundance ( 227 ) = 0.56_dp isotope_element ( 228 ) = \"Sr\" isotope_mass ( 228 ) = 8 5.909273_dp isotope_abundance ( 228 ) = 9.86_dp isotope_element ( 229 ) = \"Sr\" isotope_mass ( 229 ) = 8 6.908902_dp isotope_abundance ( 229 ) = 7.0_dp isotope_element ( 230 ) = \"Sr\" isotope_mass ( 230 ) = 8 7.905625_dp isotope_abundance ( 230 ) = 8 2.58_dp isotope_element ( 231 ) = \"Ta\" isotope_mass ( 231 ) = 17 9.947489_dp isotope_abundance ( 231 ) = 0.012_dp isotope_element ( 232 ) = \"Ta\" isotope_mass ( 232 ) = 18 0.948014_dp isotope_abundance ( 232 ) = 9 9.99_dp isotope_element ( 233 ) = \"Tb\" isotope_mass ( 233 ) = 15 8.92535_dp isotope_abundance ( 233 ) = 10 0.0_dp isotope_element ( 234 ) = \"Te\" isotope_mass ( 234 ) = 11 9.904021_dp isotope_abundance ( 234 ) = 0.096_dp isotope_element ( 235 ) = \"Te\" isotope_mass ( 235 ) = 12 1.903055_dp isotope_abundance ( 235 ) = 2.6_dp isotope_element ( 236 ) = \"Te\" isotope_mass ( 236 ) = 12 2.904278_dp isotope_abundance ( 236 ) = 0.91_dp isotope_element ( 237 ) = \"Te\" isotope_mass ( 237 ) = 12 3.902825_dp isotope_abundance ( 237 ) = 4.82_dp isotope_element ( 238 ) = \"Te\" isotope_mass ( 238 ) = 12 4.904435_dp isotope_abundance ( 238 ) = 7.14_dp isotope_element ( 239 ) = \"Te\" isotope_mass ( 239 ) = 12 5.90331_dp isotope_abundance ( 239 ) = 1 8.95_dp isotope_element ( 240 ) = \"Te\" isotope_mass ( 240 ) = 12 7.904464_dp isotope_abundance ( 240 ) = 3 1.69_dp isotope_element ( 241 ) = \"Te\" isotope_mass ( 241 ) = 12 9.906229_dp isotope_abundance ( 241 ) = 3 3.8_dp isotope_element ( 242 ) = \"Th\" isotope_mass ( 242 ) = 23 2.038054_dp isotope_abundance ( 242 ) = 10 0.0_dp isotope_element ( 243 ) = \"Ti\" isotope_mass ( 243 ) = 4 5.952633_dp isotope_abundance ( 243 ) = 8.0_dp isotope_element ( 244 ) = \"Ti\" isotope_mass ( 244 ) = 4 6.951765_dp isotope_abundance ( 244 ) = 7.3_dp isotope_element ( 245 ) = \"Ti\" isotope_mass ( 245 ) = 4 7.947947_dp isotope_abundance ( 245 ) = 7 3.8_dp isotope_element ( 246 ) = \"Ti\" isotope_mass ( 246 ) = 4 8.947871_dp isotope_abundance ( 246 ) = 5.5_dp isotope_element ( 247 ) = \"Ti\" isotope_mass ( 247 ) = 4 9.944786_dp isotope_abundance ( 247 ) = 5.4_dp isotope_element ( 248 ) = \"Tl\" isotope_mass ( 248 ) = 20 2.972336_dp isotope_abundance ( 248 ) = 2 9.52_dp isotope_element ( 249 ) = \"Tl\" isotope_mass ( 249 ) = 20 4.97441_dp isotope_abundance ( 249 ) = 7 0.48_dp isotope_element ( 250 ) = \"Tm\" isotope_mass ( 250 ) = 16 8.934225_dp isotope_abundance ( 250 ) = 10 0.0_dp isotope_element ( 251 ) = \"U\" isotope_mass ( 251 ) = 23 4.040947_dp isotope_abundance ( 251 ) = 0.006_dp isotope_element ( 252 ) = \"U\" isotope_mass ( 252 ) = 23 5.043925_dp isotope_abundance ( 252 ) = 0.72_dp isotope_element ( 253 ) = \"U\" isotope_mass ( 253 ) = 23 8.050786_dp isotope_abundance ( 253 ) = 9 9.27_dp isotope_element ( 254 ) = \"V\" isotope_mass ( 254 ) = 4 9.947161_dp isotope_abundance ( 254 ) = 0.25_dp isotope_element ( 255 ) = \"V\" isotope_mass ( 255 ) = 5 0.943963_dp isotope_abundance ( 255 ) = 9 9.75_dp isotope_element ( 256 ) = \"W\" isotope_mass ( 256 ) = 17 9.946727_dp isotope_abundance ( 256 ) = 0.13_dp isotope_element ( 257 ) = \"W\" isotope_mass ( 257 ) = 18 1.948225_dp isotope_abundance ( 257 ) = 2 6.3_dp isotope_element ( 258 ) = \"W\" isotope_mass ( 258 ) = 18 2.950245_dp isotope_abundance ( 258 ) = 1 4.3_dp isotope_element ( 259 ) = \"W\" isotope_mass ( 259 ) = 18 3.950953_dp isotope_abundance ( 259 ) = 3 0.67_dp isotope_element ( 260 ) = \"W\" isotope_mass ( 260 ) = 18 5.954377_dp isotope_abundance ( 260 ) = 2 8.6_dp isotope_element ( 261 ) = \"Xe\" isotope_mass ( 261 ) = 12 3.905894_dp isotope_abundance ( 261 ) = 0.1_dp isotope_element ( 262 ) = \"Xe\" isotope_mass ( 262 ) = 12 5.904281_dp isotope_abundance ( 262 ) = 0.09_dp isotope_element ( 263 ) = \"Xe\" isotope_mass ( 263 ) = 12 7.903531_dp isotope_abundance ( 263 ) = 1.91_dp isotope_element ( 264 ) = \"Xe\" isotope_mass ( 264 ) = 12 8.90478_dp isotope_abundance ( 264 ) = 2 6.4_dp isotope_element ( 265 ) = \"Xe\" isotope_mass ( 265 ) = 12 9.90351_dp isotope_abundance ( 265 ) = 4.1_dp isotope_element ( 266 ) = \"Xe\" isotope_mass ( 266 ) = 13 0.905076_dp isotope_abundance ( 266 ) = 2 1.2_dp isotope_element ( 267 ) = \"Xe\" isotope_mass ( 267 ) = 13 1.904148_dp isotope_abundance ( 267 ) = 2 6.9_dp isotope_element ( 268 ) = \"Xe\" isotope_mass ( 268 ) = 13 3.905395_dp isotope_abundance ( 268 ) = 1 0.4_dp isotope_element ( 269 ) = \"Xe\" isotope_mass ( 269 ) = 13 5.907219_dp isotope_abundance ( 269 ) = 8.9_dp isotope_element ( 270 ) = \"Y\" isotope_mass ( 270 ) = 8 8.905856_dp isotope_abundance ( 270 ) = 10 0.0_dp isotope_element ( 271 ) = \"Yb\" isotope_mass ( 271 ) = 16 7.933908_dp isotope_abundance ( 271 ) = 0.13_dp isotope_element ( 272 ) = \"Yb\" isotope_mass ( 272 ) = 16 9.934774_dp isotope_abundance ( 272 ) = 3.05_dp isotope_element ( 273 ) = \"Yb\" isotope_mass ( 273 ) = 17 0.936338_dp isotope_abundance ( 273 ) = 1 4.3_dp isotope_element ( 274 ) = \"Yb\" isotope_mass ( 274 ) = 17 1.936393_dp isotope_abundance ( 274 ) = 2 1.9_dp isotope_element ( 275 ) = \"Yb\" isotope_mass ( 275 ) = 17 2.938222_dp isotope_abundance ( 275 ) = 1 6.12_dp isotope_element ( 276 ) = \"Yb\" isotope_mass ( 276 ) = 17 3.938873_dp isotope_abundance ( 276 ) = 3 1.8_dp isotope_element ( 277 ) = \"Yb\" isotope_mass ( 277 ) = 17 5.942576_dp isotope_abundance ( 277 ) = 1 2.7_dp isotope_element ( 278 ) = \"Zn\" isotope_mass ( 278 ) = 6 3.929145_dp isotope_abundance ( 278 ) = 4 8.6_dp isotope_element ( 279 ) = \"Zn\" isotope_mass ( 279 ) = 6 5.926035_dp isotope_abundance ( 279 ) = 2 7.9_dp isotope_element ( 280 ) = \"Zn\" isotope_mass ( 280 ) = 6 6.927129_dp isotope_abundance ( 280 ) = 4.1_dp isotope_element ( 281 ) = \"Zn\" isotope_mass ( 281 ) = 6 7.924846_dp isotope_abundance ( 281 ) = 1 8.8_dp isotope_element ( 282 ) = \"Zn\" isotope_mass ( 282 ) = 6 9.925325_dp isotope_abundance ( 282 ) = 0.6_dp isotope_element ( 283 ) = \"Zr\" isotope_mass ( 283 ) = 8 9.904708_dp isotope_abundance ( 283 ) = 5 1.45_dp isotope_element ( 284 ) = \"Zr\" isotope_mass ( 284 ) = 9 0.905644_dp isotope_abundance ( 284 ) = 1 1.27_dp isotope_element ( 285 ) = \"Zr\" isotope_mass ( 285 ) = 9 1.905039_dp isotope_abundance ( 285 ) = 1 7.17_dp isotope_element ( 286 ) = \"Zr\" isotope_mass ( 286 ) = 9 3.906319_dp isotope_abundance ( 286 ) = 1 7.33_dp isotope_element ( 287 ) = \"Zr\" isotope_mass ( 287 ) = 9 5.908272_dp isotope_abundance ( 287 ) = 2.78_dp do e = 1 , nelems m ( e ) = 0.0_dp do i = 1 , niso if ( isotope_element ( i ) . eq . elements ( e )) then m ( e ) = m ( e ) + isotope_mass ( i ) * isotope_abundance ( i ) end if end do m ( e ) = m ( e ) / 10 0.0_dp g ( e ) = 0.0_dp do i = 1 , niso if ( isotope_element ( i ) . eq . elements ( e )) then g ( e ) = g ( e ) + isotope_abundance ( i ) * & ( 1.0_dp - isotope_mass ( i ) / m ( e )) ** 2 end if end do g ( e ) = g ( e ) / 10 0.0_dp end do end subroutine calculate_mavg_and_g end module crystal_module","tags":"","loc":"sourcefile/crystal.f90.html"},{"title":"electron.f90 – elphbolt","text":"This file depends on sourcefile~~electron.f90~~EfferentGraph sourcefile~electron.f90 electron.f90 sourcefile~misc.f90 misc.f90 sourcefile~electron.f90->sourcefile~misc.f90 sourcefile~numerics.f90 numerics.f90 sourcefile~electron.f90->sourcefile~numerics.f90 sourcefile~wannier.f90 wannier.f90 sourcefile~electron.f90->sourcefile~wannier.f90 sourcefile~params.f90 params.f90 sourcefile~electron.f90->sourcefile~params.f90 sourcefile~crystal.f90 crystal.f90 sourcefile~electron.f90->sourcefile~crystal.f90 sourcefile~symmetry.f90 symmetry.f90 sourcefile~electron.f90->sourcefile~symmetry.f90 sourcefile~delta.f90 delta.f90 sourcefile~electron.f90->sourcefile~delta.f90 sourcefile~misc.f90->sourcefile~params.f90 sourcefile~numerics.f90->sourcefile~misc.f90 sourcefile~numerics.f90->sourcefile~params.f90 sourcefile~numerics.f90->sourcefile~crystal.f90 sourcefile~wannier.f90->sourcefile~misc.f90 sourcefile~wannier.f90->sourcefile~numerics.f90 sourcefile~wannier.f90->sourcefile~params.f90 sourcefile~wannier.f90->sourcefile~crystal.f90 sourcefile~crystal.f90->sourcefile~misc.f90 sourcefile~crystal.f90->sourcefile~params.f90 sourcefile~symmetry.f90->sourcefile~misc.f90 sourcefile~symmetry.f90->sourcefile~params.f90 sourcefile~symmetry.f90->sourcefile~crystal.f90 sourcefile~spglib_wrapper.f90 spglib_wrapper.f90 sourcefile~symmetry.f90->sourcefile~spglib_wrapper.f90 sourcefile~delta.f90->sourcefile~misc.f90 sourcefile~delta.f90->sourcefile~params.f90 sourcefile~spglib_wrapper.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~electron.f90~~AfferentGraph sourcefile~electron.f90 electron.f90 sourcefile~interactions.f90 interactions.f90 sourcefile~interactions.f90->sourcefile~electron.f90 sourcefile~bte.f90 bte.f90 sourcefile~bte.f90->sourcefile~electron.f90 sourcefile~bte.f90->sourcefile~interactions.f90 sourcefile~bz_sums.f90 bz_sums.f90 sourcefile~bte.f90->sourcefile~bz_sums.f90 sourcefile~elphbolt.f90 elphbolt.f90 sourcefile~elphbolt.f90->sourcefile~electron.f90 sourcefile~elphbolt.f90->sourcefile~interactions.f90 sourcefile~elphbolt.f90->sourcefile~bte.f90 sourcefile~elphbolt.f90->sourcefile~bz_sums.f90 sourcefile~bz_sums.f90->sourcefile~electron.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules electron_module Source Code electron.f90 Source Code ! Copyright (C) 2020- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module electron_module !! Module containing types and procedures related to the electronic properties. use params , only : dp , k8 use misc , only : exit_with_message , print_message , demux_state , sort , & binsearch , subtitle , Fermi , write2file_rank2_real , write2file_rank3_real use numerics_module , only : numerics use wannier_module , only : epw_wannier use crystal_module , only : crystal , calculate_wavevectors_full use symmetry_module , only : symmetry , find_irred_wedge , create_fbz2ibz_map use delta , only : form_tetrahedra_3d , fill_tetrahedra_3d , form_triangles , & fill_triangles implicit none private public electron type electron !! Data and procedures related to the electronic properties. character ( len = 2 ) :: prefix = 'el' !! Prefix idenitfying particle type. integer ( k8 ) :: spindeg !! Spin degeneracy. integer ( k8 ) :: numbands !! Total number of electronic Wannier bands. integer ( k8 ) :: numtransbands !! Total number of transport active bands. integer ( k8 ) :: indlowband !! Lowest transport band index. integer ( k8 ) :: indhighband !! Highest transport band index. integer ( k8 ) :: indlowconduction !! Lowest conduction band index. integer ( k8 ) :: indhighvalence !! Highest valence band index. integer ( k8 ), allocatable :: bandlist (:) !! List of transport active band indices. integer ( k8 ) :: mesh_ref !! Electron mesh refinement factor compared to the phonon mesh. integer ( k8 ) :: mesh_ref_array ( 3 ) !! The same as above, but in array form. This is useful for 3d vs 2d cases. integer ( k8 ) :: kmesh ( 3 ) !! Electron wave vector mesh. integer ( k8 ) :: nk !! Number of fine electron wave vectors in the full Brillouin zone (FBZ). integer ( k8 ) :: nk_irred !! Number of fine electron wave vectors in the irreducible wedge of Brillouin zone (IBZ). integer ( k8 ) :: nstates_inwindow !! Number of electron wave vectors within transport window. integer ( k8 ) :: nstates_irred_inwindow !! Number of IBZ wedge electron wave vectors within transport window. integer ( k8 ), allocatable :: IBZ_inwindow_states (:,:) !! List of irreducible wedge states within transport window. real ( dp ) :: enref !! Electron reference energy (eV). !! This is the center of the transport energy window. real ( dp ) :: fsthick !! Fermi surface thickness (eV). real ( dp ) :: chempot !! Chemical potential in (eV). real ( dp ), allocatable :: conc (:) !! Band resolved carrier concentration. real ( dp ) :: conc_el !! Total electron carrier concentration. real ( dp ) :: conc_hole !! Total hole carrier concentration. real ( dp ) :: chimp_conc_n !! Concentration of donor impurities. real ( dp ) :: chimp_conc_p !! Concentration of acceptor impurities. real ( dp ) :: Zn !! Ionization number of donor dopant. real ( dp ) :: Zp !! Ionization number of acceptor dopant. real ( dp ), allocatable :: wavevecs (:,:) !! List of all electron wave vectors (crystal coordinates). real ( dp ), allocatable :: wavevecs_irred (:,:) !! List of irreducible electron wave vectors (crystal coordinates). integer ( k8 ), allocatable :: indexlist (:) !! List of muxed indices of the FBZ wave vectors. integer ( k8 ), allocatable :: indexlist_irred (:) !! List of muxed indices of the IBZ wedge. integer ( k8 ), allocatable :: nequiv (:) !! List of the number of equivalent points for each IBZ point. integer ( k8 ), allocatable :: ibz2fbz_map (:,:,:) !! Map from an IBZ electron point to its images. !! The third axis contains the pair (symmetry index, image). integer ( k8 ), allocatable :: fbz2ibz_map (:) !! Map from an FBZ electron point to its IBZ wedge image. integer ( k8 ), allocatable :: equiv_map (:,:) !! Map of equivalent points under rotations. !! Axis 1 runs over rotations. !! Axis 2 runs over wave vectors. real ( dp ), allocatable :: symmetrizers (:,:,:) !! Symmetrizers of wave vector dependent vectors. integer ( k8 ), allocatable :: tetra (:,:) !! List of all the wave vector mesh tetrahedra vertices. !! First axis list tetraheda and the second axis list the vertices. integer ( k8 ), allocatable :: tetracount (:) !! The number of tetrahedra in which a wave vector belongs. integer ( k8 ), allocatable :: tetramap (:,:,:) !! Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real ( dp ), allocatable :: tetra_evals (:,:,:) !! Tetrahedra vertices filled with eigenvalues. integer ( k8 ), allocatable :: triang (:,:) !! List of all the wave vector mesh triangles vertices. !! First axis lists triangles and the second axis lists the vertices. integer ( k8 ), allocatable :: triangcount (:) !! The number of triangles in which a wave vector belongs. integer ( k8 ), allocatable :: triangmap (:,:,:) !! Mapping from a wave vector to the (triangle, vertex) where it belongs. real ( dp ), allocatable :: triang_evals (:,:,:) !! Triangles vertices filled with eigenvalues. real ( dp ), allocatable :: ens (:,:) !! List of electron energies on FBZ. real ( dp ), allocatable :: ens_irred (:,:) !! List of electron energies on IBZ. real ( dp ), allocatable :: vels (:,:,:) !! List of electron velocities on FBZ. real ( dp ), allocatable :: vels_irred (:,:,:) !! List of electron velocites on IBZ. complex ( dp ), allocatable :: evecs (:,:,:) !! List of all electron eigenvectors. complex ( dp ), allocatable :: evecs_irred (:,:,:) !! List of IBZ wedge electron eigenvectors. logical :: metallic !! Is the system metallic? real ( dp ), allocatable :: dos (:,:) !! Band resolved density of states. character ( len = 1 ) :: dopingtype !! Type of doping. This is needed for runlevel 0 only. integer ( k8 ) :: numconc !! Number of concentration points. This is needed for runlevel 0 only. real ( dp ), allocatable :: conclist (:) !! List of concentrations. This is needed for runlevel 0 only. integer ( k8 ) :: numT !! Number of temperature points. This is needed for runlevel 0 only. real ( dp ), allocatable :: Tlist (:) !! List of temperatures. This is needed for runlevel 0 only. contains procedure :: initialize => read_input_and_setup , deallocate_eigenvecs end type electron contains subroutine read_input_and_setup ( el , wann , crys , sym , num ) !! Read input file and setup groundstate electronic system. class ( electron ), intent ( out ) :: el type ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( numerics ), intent ( in ) :: num !Local variables real ( dp ) :: enref , Zn , Zp , chempot real ( dp ), allocatable :: Tlist (:), conclist (:) integer ( k8 ) :: ib , spindeg , numbands , indlowband , indhighband , & indlowconduction , indhighvalence , numT , numconc logical :: metallic character ( len = 6 ) :: concunits character ( len = 1 ) :: dopingtype namelist / electrons / enref , spindeg , numbands , & indlowband , indhighband , metallic , chempot , Zn , Zp , & indlowconduction , indhighvalence , dopingtype , numT , numconc , & Tlist , conclist call subtitle ( \"Setting up electrons...\" ) !Open input file open ( 1 , file = 'input.nml' , status = 'old' ) !Read electrons information spindeg = 2 !Default calculation is non-spin polarized numbands = 0 indlowband = 0 indhighband = 0 indlowconduction = 0 indhighvalence = 0 metallic = . false . Zn = 0.0_dp Zp = 0.0_dp chempot = - 99999 9.99999_dp !Something crazy enref = - 99999 9.99999_dp !Something crazy numT = 100 !Something crazy big numconc = 100 !Something crazy big dopingtype = 'x' allocate ( Tlist ( nuMT ), conclist ( numconc )) Tlist = - 1.0_dp !Something crazy conclist = 0.0_dp read ( 1 , nml = electrons ) if ( spindeg < 1 . or . spindeg > 2 ) then call exit_with_message ( 'spindeg can be 1 or 2.' ) end if if ( numbands < 1 ) then call exit_with_message ( 'numbands should be > 0.' ) end if if ( indlowband < 1 ) then call exit_with_message ( 'indlowband should be > 0.' ) end if if ( indhighband < 1 ) then call exit_with_message ( 'indhighband should be > 0.' ) end if if (. not . metallic ) then if ( indlowconduction < 1 . and . indhighvalence < 1 ) then call exit_with_message (& 'For non-metals, must provide lowest conduction or highest valence band.' ) end if end if if ( num % runlevel == 0 ) then if ( numT <= 0 . or . numconc <= 0 ) then call exit_with_message ( 'numT or numconc should be > 0.' ) end if if ( numT > 100 . or . numconc > 100 ) then call exit_with_message ( 'numT or numconc > 1000 is not supported.' ) end if if ( any ( Tlist ( 1 : numT ) <= 0.0_dp )) then call exit_with_message ( 'Unphysical Tlist provided.' ) end if if ( dopingtype /= 'n' . and . dopingtype /= 'p' ) then print * , dopingtype , len ( dopingtype ) call exit_with_message ( \"dopingtype must be 'n' or 'p'.\" ) end if end if el % spindeg = spindeg el % numbands = numbands el % indlowband = indlowband el % indhighband = indhighband el % numtransbands = el % indhighband - el % indlowband + 1 allocate ( el % bandlist ( el % numtransbands )) do ib = 1 , el % numtransbands el % bandlist ( ib ) = indlowband + ib - 1 end do el % metallic = metallic el % indlowconduction = indlowconduction el % indhighvalence = indhighvalence el % enref = enref el % chempot = chempot el % Zn = Zn el % Zp = Zp if ( el % metallic ) then el % Zn = 0 el % Zp = 0 end if if ( num % runlevel == 0 ) then el % numT = numT el % numconc = numconc allocate ( el % Tlist ( el % numT ), el % conclist ( el % numconc )) el % Tlist (:) = Tlist ( 1 : numT ) el % conclist (:) = conclist ( 1 : numconc ) el % dopingtype = dopingtype end if !Close input file close ( 1 ) !Set some electronic properties from the numerics object el % mesh_ref = num % mesh_ref el % mesh_ref_array = ( / num % mesh_ref , num % mesh_ref , num % mesh_ref / ) if ( crys % twod ) then el % kmesh ( 3 ) = 1_k8 el % mesh_ref_array ( 3 ) = 1_k8 end if el % kmesh = el % mesh_ref_array * num % qmesh el % fsthick = num % fsthick !Print out information. if ( this_image () == 1 ) then write ( * , \"(A, I1)\" ) \"Spin degeneracy = \" , el % spindeg write ( * , \"(A, I5)\" ) \"Number of Wannier electronic bands = \" , el % numbands write ( * , \"(A, I5)\" ) \"Number of transport active electronic bands = \" , el % numtransbands write ( * , \"(A, I5, I5)\" ) \"Lowest and highest transport active electronic bands = \" , & el % bandlist ( 1 ), el % bandlist ( el % numtransbands ) write ( * , \"(A, 1E16.8, A)\" ) \"Reference electron energy = \" , el % enref , ' eV' write ( * , \"(A, L)\" ) \"System is metallic: \" , el % metallic if ( indlowconduction > 0 ) then write ( * , \"(A, I5)\" ) \"Lowest conduction band index = \" , el % indlowconduction end if if ( indhighvalence > 0 ) then write ( * , \"(A, I5)\" ) \"Highest valence band index = \" , el % indhighvalence end if end if !Calculate electrons call calculate_electrons ( el , wann , crys , sym , num ) !Set total number of charged impurities if (. not . el % metallic ) then el % chimp_conc_n = 0.0_dp el % chimp_conc_p = 0.0_dp if ( el % Zn > 0 ) el % chimp_conc_n = el % chimp_conc_n + el % conc_el / el % Zn if ( el % Zp > 0 ) el % chimp_conc_p = el % chimp_conc_p + el % conc_hole / el % Zp end if !Print out information. call print_message ( \"Electron calculations summary:\" ) call print_message ( \"------------------------------\" ) if ( this_image () == 1 ) then if ( crys % twod ) then concunits = ' cm&#94;-2' else concunits = ' cm&#94;-3' end if write ( * , \"(A, 1E16.8, A)\" ) \"Chemical potential = \" , el % chempot , ' eV' if (. not . el % metallic ) then write ( * , \"(A, 1E16.8)\" ) 'Band resolved carrier concentration (+/- = hole/electron):' do ib = el % indlowband , el % indhighband write ( * , \"(A, I5, A, 1E16.8, A)\" ) ' Band: ' , ib , ', concentration: ' , & el % conc ( ib ), concunits end do write ( * , \"(A, 1E16.8, A)\" ) \"Absolute total electron concentration = \" , el % conc_el , concunits write ( * , \"(A, 1E16.8, A)\" ) \"Absolute total hole concentration = \" , el % conc_hole , concunits write ( * , \"(A, 1E16.8)\" ) \"Ionization of donor impurity = \" , el % Zn write ( * , \"(A, 1E16.8)\" ) \"Ionization of acceptor impurity = \" , el % Zp write ( * , \"(A, 1E16.8, A)\" ) \"Donor impurity concentration = \" , el % chimp_conc_n , concunits write ( * , \"(A, 1E16.8, A)\" ) \"Acceptor impurity concentration = \" , el % chimp_conc_p , concunits end if end if end subroutine read_input_and_setup subroutine calculate_electrons ( el , wann , crys , sym , num ) !! Calculate electron energy window restricted wave vector meshes !! and the electronic properties on them class ( electron ), intent ( inout ) :: el type ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( numerics ), intent ( in ) :: num !Some utitlity variables integer ( k8 ) :: i , l , s , il , ii , jj , kk , ib , count , istate , aux real ( dp ), allocatable :: el_ens_tmp (:, :), el_vels_tmp (:, :, :) !Switch for mesh utilites with or without energy restriction logical :: blocks !I/O related character ( len = 1024 ) :: filename , numcols call print_message ( \"Energy unrestricted calculation:\" ) call print_message ( \"--------------------------------\" ) !Set initial FBZ total number of wave vectors el % nk = product ( el % kmesh ) !The electronic mesh setup proceeds in multiple steps: ! 1. Calculate full electron wave vector mesh call print_message ( \"Calculating FBZ...\" ) blocks = . false . call calculate_wavevectors_full ( el % kmesh , el % wavevecs , blocks ) ! 2. Calculate the IBZ call print_message ( \"Calculating IBZ and IBZ -> FBZ mappings...\" ) call find_irred_wedge ( el % kmesh , el % nk_irred , el % wavevecs_irred , & el % indexlist_irred , el % nequiv , sym % nsymm_rot , sym % qrotations , & el % ibz2fbz_map , el % equiv_map , blocks ) ! 3. Calculate IBZ quantities call print_message ( \"Calculating IBZ energies...\" ) allocate ( el % ens_irred ( el % nk_irred , wann % numwannbands ), & el % vels_irred ( el % nk_irred , wann % numwannbands , 3 ), & el % evecs_irred ( el % nk_irred , wann % numwannbands , wann % numwannbands )) call wann % el_wann_epw ( crys , el % nk_irred , el % wavevecs_irred , el % ens_irred , & el % vels_irred , el % evecs_irred ) ! 4. Map out FBZ quantities from IBZ ones call print_message ( \"Mapping out FBZ energies...\" ) allocate ( el % indexlist ( el % nk ), el % ens ( el % nk , wann % numwannbands ), el % vels ( el % nk , wann % numwannbands , 3 )) do i = 1 , el % nk_irred !an irreducible point do l = 1 , el % nequiv ( i ) !number of equivalent points of i il = el % ibz2fbz_map ( l , i , 2 ) ! (i, l) -> il s = el % ibz2fbz_map ( l , i , 1 ) ! mapping rotation !index list el % indexlist ( il ) = il !energy el % ens ( il ,:) = el % ens_irred ( i ,:) !velocity do ib = 1 , el % numtransbands !wann%numwannbands !here use real space (Cartesian) rotations el % vels ( il , ib , :) = matmul ( sym % crotations (:, :, s ), el % vels_irred ( i , ib , :)) end do end do end do if (. not . el % metallic ) then if ( num % runlevel == 0 ) then !Calculate chemical potentials for !the given temperatures and concentrations if ( crys % twod ) then call calculate_chempot ( el , crys % volume , el % dopingtype , el % Tlist , el % conclist , & crys % thickness ) else call calculate_chempot ( el , crys % volume , el % dopingtype , el % Tlist , el % conclist ) end if call exit_with_message ( \"Chemical potentials calculated. Runlevel 0 finished. Exiting.\" ) else !Calculate carrier concentration for non-metals call print_message ( \"Calculating carrier concentrations...\" ) if ( crys % twod ) then call calculate_carrier_conc ( el , crys % T , crys % volume , crys % thickness ) else call calculate_carrier_conc ( el , crys % T , crys % volume ) end if end if end if call print_message ( \"Transport energy window restricted calculation:\" ) call print_message ( \"-----------------------------------------------\" ) ! 5. Find energy window restricted FBZ blocks. !    After this step, el%nk, el%indexlist will refer !    to the energy restricted mesh. call print_message ( \"Calculating Fermi window restricted FBZ blocks...\" ) call apply_energy_window ( el % nk , el % indexlist , el % ens , el % enref , el % fsthick ) ! 6. Sort index list and related quanties of FBZ blocks call print_message ( \"Sorting FBZ blocks index list...\" ) call sort ( el % indexlist ) ! 7. Get FBZ blocks wave vectors, energies, velocities and eigenvectors. !    After this step, el%wavevecs, el%ens, el%vels, and el%evecs !    will refer to the energy restricted mesh. call print_message ( \"Calcutating FBZ blocks quantities...\" ) !wave vectors deallocate ( el % wavevecs ) blocks = . true . call calculate_wavevectors_full ( el % kmesh , el % wavevecs , blocks , el % indexlist ) !wave vectors !Print electron FBZ mesh call write2file_rank2_real ( \"el.wavevecs_fbz\" , el % wavevecs ) !energies and velocities call fbz_blocks_quantities ( el % indexlist , el % ens , el % vels ) !Get FBZ blocks eigenvectors from direct calculations since we are !not getting these from IBZ quantities via symmetry rotations allocate ( el % evecs ( el % nk , wann % numwannbands , wann % numwannbands )) allocate ( el_ens_tmp ( el % nk , wann % numwannbands ), el_vels_tmp ( el % nk , wann % numwannbands , 3 )) call wann % el_wann_epw ( crys , el % nk , el % wavevecs , el_ens_tmp , el_vels_tmp , el % evecs ) deallocate ( el_ens_tmp , el_vels_tmp ) !free up memory ! 8. Find IBZ of energy window restricted blocks !    After this step, el%nk_irred, el%indexlist_irred, !    el%wavevecs_irred, el%nequiv, and el%ibz2fbz_map !    will refer to the energy restricted mesh call print_message ( \"Calculating IBZ blocks...\" ) deallocate ( el % wavevecs_irred , el % indexlist_irred , el % nequiv , & el % ibz2fbz_map , el % equiv_map ) blocks = . true . call find_irred_wedge ( el % kmesh , el % nk_irred , el % wavevecs_irred , & el % indexlist_irred , el % nequiv , sym % nsymm_rot , sym % qrotations , & el % ibz2fbz_map , el % equiv_map , blocks , el % indexlist ) !Print electron IBZ mesh call write2file_rank2_real ( \"el.wavevecs_ibz\" , el % wavevecs_irred ) !Create symmetrizers of wave vector dependent vectors ShengBTE style allocate ( el % symmetrizers ( 3 , 3 , el % nk )) el % symmetrizers = 0.0_dp do i = 1 , el % nk ii = el % indexlist ( i ) kk = 0 do jj = 1 , sym % nsymm if ( el % equiv_map ( jj , i ) == ii ) then el % symmetrizers (:, :, i ) = el % symmetrizers (:, :, i ) + & sym % crotations_orig (:, :, jj ) kk = kk + 1 end if end do if ( kk > 1 ) then el % symmetrizers (:, :, i ) = el % symmetrizers (:, :, i ) / kk end if end do ! 9. Get IBZ blocks energies, velocities, and eigen vectors. call print_message ( \"Calcutating IBZ blocks quantities...\" ) deallocate ( el % ens_irred , el % vels_irred , el % evecs_irred ) allocate ( el % ens_irred ( el % nk_irred , wann % numwannbands ), & el % vels_irred ( el % nk_irred , wann % numwannbands , 3 ), & el % evecs_irred ( el % nk_irred , wann % numwannbands , wann % numwannbands )) call wann % el_wann_epw ( crys , el % nk_irred , el % wavevecs_irred , el % ens_irred , & el % vels_irred , el % evecs_irred ) ! 10. Calculate the number of FBZ blocks electronic states !     available for scattering el % nstates_inwindow = 0 do i = 1 , el % nk !over FBZ blocks do ib = 1 , wann % numwannbands !bands if ( abs ( el % ens ( i , ib ) - el % enref ) <= el % fsthick ) & el % nstates_inwindow = el % nstates_inwindow + 1 end do end do if ( this_image () == 1 ) write ( * , \"(A, I10)\" ) & \" Number of energy restricted FBZ blocks states = \" , el % nstates_inwindow ! 11. Create FBZ blocks to IBZ blocks map call print_message ( \"Calculating FBZ -> IBZ mappings...\" ) !call create_fbz2ibz_map call create_fbz2ibz_map ( el % fbz2ibz_map , el % nk , el % nk_irred , el % indexlist , el % nequiv , el % ibz2fbz_map ) do i = 1 , el % nk_irred !IBZ do l = 1 , el % nequiv ( i ) !number of equivalent points of i il = el % ibz2fbz_map ( l , i , 2 ) ! (i, l) -> il s = el % ibz2fbz_map ( l , i , 1 ) ! symmetry call binsearch ( el % indexlist , il , aux ) !energy el % ens ( aux ,:) = el % ens_irred ( i ,:) !velocity do ib = 1 , wann % numwannbands !here use real space (Cartesian) rotations el % vels ( aux , ib , :) = matmul ( sym % crotations (:, :, s ), el % vels_irred ( i , ib , :)) end do el % vels ( aux ,:,:) = transpose (& matmul ( el % symmetrizers (:,:, aux ), transpose ( el % vels ( aux ,:,:)))) end do end do ! 12. Calculate the number of IBZ electronic states available for scattering el % nstates_irred_inwindow = 0 do istate = 1 , el % nk_irred * wann % numwannbands !Demux state index into band (ib) and wave vector (i) indices call demux_state ( istate , wann % numwannbands , ib , i ) if ( abs ( el % ens_irred ( i , ib ) - el % enref ) <= el % fsthick ) then el % nstates_irred_inwindow = el % nstates_irred_inwindow + 1 end if end do if ( this_image () == 1 ) write ( * , \"(A, I10)\" ) \" Number of energy restricted IBZ blocks states = \" , & el % nstates_irred_inwindow !Calculate list of IBZ in-window states = (wave vector index, band index) allocate ( el % IBZ_inwindow_states ( el % nstates_irred_inwindow , 2 )) count = 0 do istate = 1 , el % nk_irred * wann % numwannbands !Demux state index into band (ib) and wave vector (i) indices call demux_state ( istate , wann % numwannbands , ib , i ) if ( abs ( el % ens_irred ( i , ib ) - el % enref ) <= el % fsthick ) then count = count + 1 el % IBZ_inwindow_states ( count ,:) = ( / i , ib / ) end if end do !Write IBZ in-window states as text data to file if ( this_image () == 1 ) then call chdir ( num % cwd ) filename = 'el.inwindow_states_ibz' write ( numcols , \"(I0)\" ) 2 open ( 1 , file = trim ( filename ), status = 'replace' ) write ( 1 , * ) \"#k-vec index     band index\" do i = 1 , el % nstates_irred_inwindow write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"I10)\" ) el % IBZ_inwindow_states ( i ,:) end do close ( 1 ) end if !Deallocating this here since this is not used later in the program deallocate ( el % IBZ_inwindow_states ) !Print out irreducible electron energies and velocities call write2file_rank2_real ( \"el.ens_ibz\" , el % ens_irred ) call write2file_rank3_real ( \"el.vels_ibz\" , el % vels_irred ) !Calculate electron tetrahedra if ( num % tetrahedra ) then call print_message ( \"Calculating electron mesh tetrahedra...\" ) call form_tetrahedra_3d ( el % nk , el % kmesh , el % tetra , el % tetracount , & el % tetramap , . true ., el % indexlist ) call fill_tetrahedra_3d ( el % tetra , el % ens , el % tetra_evals ) else call print_message ( \"Calculating electron mesh triangles...\" ) call form_triangles ( el % nk , el % kmesh , el % triang , el % triangcount , & el % triangmap , . true ., el % indexlist ) call fill_triangles ( el % triang , el % ens , el % triang_evals ) end if end subroutine calculate_electrons subroutine apply_energy_window ( nk , indexlist , energies , enref , fsthick ) !! Subroutine to find the Fermi window restricted blocks of BZ. !! This could be used for FBZ and IBZ. !! !! nk is the number of mesh points - will be updated to !! the number of mesh points in energy restricted blocks !! !! indexlist is the list of wave vector indices - will be updated !! to the list of indices in the blocks integer ( k8 ), intent ( inout ) :: nk integer ( k8 ), allocatable , intent ( inout ) :: indexlist (:) real ( dp ), intent ( in ) :: energies (:,:), enref , fsthick integer ( k8 ) :: ik , count , numbands , inwindow ( nk ) real ( dp ), allocatable :: aux (:) numbands = size ( energies ( 1 ,:)) allocate ( aux ( numbands )) count = 0 do ik = 1 , nk aux = energies ( ik , :) !Check if any band energy is within the Fermi window if ( any ( abs ( aux (:) - enref ) <= fsthick )) then count = count + 1 inwindow ( count ) = ik !save index of in-window points end if end do if ( count == 0 ) call exit_with_message ( \"No states found within Fermi window.\" ) !Update index list deallocate ( indexlist ) allocate ( indexlist ( count )) indexlist ( 1 : count ) = inwindow ( 1 : count ) !Update number of irreducible points nk = count end subroutine apply_energy_window subroutine fbz_blocks_quantities ( indexlist , energies , velocities ) !! Subroutine to find FBZ quanties the lie within the Fermi window. integer ( k8 ), intent ( in ) :: indexlist (:) real ( dp ), allocatable , intent ( inout ) :: energies (:,:), velocities (:,:,:) integer ( k8 ) :: i , nk , numbands real ( dp ), allocatable :: energies_tmp (:,:), velocities_tmp (:,:,:) nk = size ( indexlist ) numbands = size ( energies ( 1 ,:)) allocate ( energies_tmp ( nk , numbands ), velocities_tmp ( nk , numbands , 3 )) do i = 1 , nk energies_tmp ( i ,:) = energies ( indexlist ( i ),:) velocities_tmp ( i ,:,:) = velocities ( indexlist ( i ),:,:) end do deallocate ( energies , velocities ) allocate ( energies ( nk , numbands ), velocities ( nk , numbands , 3 )) energies ( 1 : nk , :) = energies_tmp ( 1 : nk , :) velocities ( 1 : nk , :, :) = velocities_tmp ( 1 : nk , :, :) end subroutine fbz_blocks_quantities subroutine calculate_carrier_conc ( el , T , vol , h ) !! Subroutine to calculate the band resolved carrier concentration !! for a given chemical potential and temperature. class ( electron ), intent ( inout ) :: el real ( dp ), intent ( in ) :: T , vol real ( dp ), intent ( in ), optional :: h !Local variables real ( dp ) :: const integer ( k8 ) :: ib , ik !Allocate conc allocate ( el % conc ( el % numbands )) el % conc = 0.0_dp el % conc_el = 0.0_dp el % conc_hole = 0.0_dp !Normalization and units factor const = el % spindeg / dble ( product ( el % kmesh )) / vol / ( 1.0e-21_dp ) do ik = 1 , el % nk !Electron concentration !By convention, the electron carrier concentration will have a negative sign. if ( el % indlowconduction > 0 ) then !Calculation includes conduction bands do ib = el % indlowconduction , el % indhighband !Conduction bands manifold el % conc ( ib ) = el % conc ( ib ) - Fermi ( el % ens ( ik , ib ), el % chempot , T ) end do !Total electron concentration el % conc_el = abs ( sum ( el % conc ( el % indlowconduction : el % indhighband ))) end if !Hole concentration !By convention, the electron carrier concentration will have a positive sign. if ( el % indhighvalence > 0 ) then !Calculation includes valence bands do ib = el % indlowband , el % indhighvalence !Valence bands manifold el % conc ( ib ) = el % conc ( ib ) + ( 1.0_dp - Fermi ( el % ens ( ik , ib ), el % chempot , T )) end do !Total hole concentration el % conc_hole = sum ( el % conc ( el % indlowband : el % indhighvalence )) end if end do el % conc = el % conc * const !cm&#94;-3 el % conc_el = el % conc_el * const !cm&#94;-3 el % conc_hole = el % conc_hole * const !cm&#94;-3 !If h is present that means the system is 2d if ( present ( h )) then el % conc = el % conc * h * 1.0e-7_dp !cm&#94;-2 el % conc_el = el % conc_el * h * 1.0e-7_dp !cm&#94;-2 el % conc_hole = el % conc_hole * h * 1.0e-7_dp !cm&#94;-2 end if end subroutine calculate_carrier_conc subroutine calculate_chempot ( el , vol , dopingtype , Tlist , conclist , h ) !! Subroutine to calculate the chemical potential for a !! given carrier concentration. class ( electron ), intent ( in ) :: el real ( dp ), intent ( in ) :: vol , Tlist (:), conclist (:) character ( len = 1 ), intent ( in ) :: dopingtype real ( dp ), intent ( in ), optional :: h !Local variables integer ( k8 ) :: ib , ik , it , ngrid , maxiter , itemp , iconc , & high , low , numtemp , numconc real ( dp ) :: a , b , aux , const , mu , thresh real ( dp ), allocatable :: chempot (:,:) call print_message ( \"Calculating chemical potential...\" ) !Number of temperature points numtemp = size ( Tlist ) !Number of cocentration points numconc = size ( conclist ) !Allocate chemical potential array allocate ( chempot ( numtemp , numconc )) chempot = - 9 9.99_dp !Total number of points in full mesh ngrid = product ( el % kmesh ) !Normalization and units factor const = el % spindeg / dble ( ngrid ) / vol / ( 1.0e-21_dp ) if ( present ( h )) then !2d system const = const * h * 1.0e-7_dp end if !Maximum number of iterations maxiter = 1000 !Convergence threshold thresh = 1.0e-12_dp !Check doping type if ( dopingtype == 'n' ) then low = el % indlowconduction high = el % indhighband else low = el % indlowband high = el % indhighvalence end if !Loop over temperatures do itemp = 1 , numtemp if ( this_image () == 1 ) then write ( * , \"(A, F7.2, A)\" ) 'Crystal temperature = ' , Tlist ( itemp ), ' K:' if ( present ( h )) then !2d system write ( * , \"(A)\" ) 'Carrier conc. [cm&#94;-2]    Chemical potential [eV]' else write ( * , \"(A)\" ) 'Carrier conc. [cm&#94;-3]    Chemical potential [eV]' end if end if !Loop over concentrations do iconc = 1 , numconc if ( dopingtype == 'n' ) then a = el % enref - 1 0.0_dp !guess lower bound b = el % enref + 1 0.0_dp !guess upper bound else a = el % enref + 1 0.0_dp !guess lower bound b = el % enref - 1 0.0_dp !guess upper bound end if do it = 1 , maxiter mu = 0.5_dp * ( a + b ) aux = 0.0_dp do ib = low , high do ik = 1 , el % nk if ( dopingtype == 'n' ) then aux = aux + Fermi ( el % ens ( ik , ib ), mu , Tlist ( itemp )) else aux = aux + 1.0_dp - Fermi ( el % ens ( ik , ib ), mu , Tlist ( itemp )) end if end do end do aux = aux * const !cm&#94;-3 for 3d, cm&#94;-2 for 2d if ( abs ( aux - conclist ( iconc )) / conclist ( iconc ) < thresh ) then exit else if ( aux < conclist ( iconc )) then a = mu else b = mu end if end do chempot ( itemp , iconc ) = mu if ( abs ( aux - conclist ( iconc )) / conclist ( iconc ) > thresh ) then call exit_with_message (& \"Could not converge to correct chemical potential. Exiting.\" ) end if if ( this_image () == 1 ) then write ( * , \"(1E16.8, A, 1E16.8)\" ) conclist ( iconc ), '         ' , chempot ( itemp , iconc ) end if end do end do end subroutine calculate_chempot subroutine deallocate_eigenvecs ( el ) !! Deallocate the electron eigenvectors class ( electron ), intent ( inout ) :: el deallocate ( el % evecs , el % evecs_irred ) end subroutine deallocate_eigenvecs end module electron_module","tags":"","loc":"sourcefile/electron.f90.html"},{"title":"bte – elphbolt ","text":"type, public :: bte Data and procedures related to the BTE. Contents Variables ph_rta_rates_iso_ibz ph_rta_rates_subs_ibz ph_rta_rates_ibz ph_field_term_T ph_response_T ph_field_term_E ph_response_E el_rta_rates_echimp_ibz el_rta_rates_ibz el_field_term_T el_response_T el_field_term_E el_response_E Type-Bound Procedures post_process solve_bte Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: ph_rta_rates_iso_ibz (:,:) Phonon RTA scattering rates on the IBZ due to isotope scattering. real(kind=dp), public, allocatable :: ph_rta_rates_subs_ibz (:,:) Phonon RTA scattering rates on the IBZ due to substitution scattering. real(kind=dp), public, allocatable :: ph_rta_rates_ibz (:,:) Phonon RTA scattering rates on the IBZ. real(kind=dp), public, allocatable :: ph_field_term_T (:,:,:) Phonon field coupling term for gradT field on the FBZ. real(kind=dp), public, allocatable :: ph_response_T (:,:,:) Phonon response function for gradT field on the FBZ. real(kind=dp), public, allocatable :: ph_field_term_E (:,:,:) Phonon field coupling term for E field on the FBZ. real(kind=dp), public, allocatable :: ph_response_E (:,:,:) Phonon response function for E field on the FBZ. real(kind=dp), public, allocatable :: el_rta_rates_echimp_ibz (:,:) Electron RTA scattering rates on the IBZ due to charged impurity scattering. real(kind=dp), public, allocatable :: el_rta_rates_ibz (:,:) Electron RTA scattering rates on the IBZ. real(kind=dp), public, allocatable :: el_field_term_T (:,:,:) Electron field coupling term for gradT field on the FBZ. real(kind=dp), public, allocatable :: el_response_T (:,:,:) Electron response function for gradT field on the FBZ. real(kind=dp), public, allocatable :: el_field_term_E (:,:,:) Electron field coupling term for E field on the FBZ. real(kind=dp), public, allocatable :: el_response_E (:,:,:) Electron response function for E field on the FBZ. Type-Bound Procedures procedure, public :: post_process private subroutine post_process(bt, num, crys, sym, ph, el) Subroutine to post-process results of the BTEs. Arguments Type Intent Optional Attributes Name class( bte ), intent(inout) :: bt type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( symmetry ), intent(in) :: sym type( phonon ), intent(in) :: ph type( electron ), intent(in), optional :: el procedure, public :: solve_bte private subroutine solve_bte(bt, num, crys, sym, ph, el) Subroutine to solve the BTE Read more… Arguments Type Intent Optional Attributes Name class( bte ), intent(inout) :: bt type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( symmetry ), intent(in) :: sym type( phonon ), intent(in) :: ph type( electron ), intent(in), optional :: el","tags":"","loc":"type/bte.html"},{"title":"phonon – elphbolt ","text":"type, public :: phonon Data and procedures related to phonons. Contents Variables prefix numbranches nq nq_irred qmesh wavevecs wavevecs_irred indexlist_irred nequiv ibz2fbz_map equiv_map symmetrizers tetra tetracount tetramap tetra_evals triang triangcount triangmap triang_evals ens vels evecs scell ifc2 ifc3 numtriplets R_j R_k Index_i Index_j Index_k dos rws cell_r cell_g mm rr Type-Bound Procedures deallocate_phonon_quantities initialize Components Type Visibility Attributes Name Initial character(len=2), public :: prefix = 'ph' Prefix idenitfying particle type. integer(kind=k8), public :: numbranches Total number of phonon branches. integer(kind=k8), public :: nq Number of phonon wave vectors in the full Brillouin zone (FBZ). integer(kind=k8), public :: nq_irred Number of phonon wave vectors in the irreducible wedge of Brillouin zone (IBZ). integer(kind=k8), public :: qmesh (3) Phonon wave vector mesh. real(kind=dp), public, allocatable :: wavevecs (:,:) List of all phonon wave vectors (crystal coordinates). real(kind=dp), public, allocatable :: wavevecs_irred (:,:) List of irreducible phonon wave vectors (crystal coordinates). integer(kind=k8), public, allocatable :: indexlist_irred (:) List of muxed indices of the IBZ wedge. integer(kind=k8), public, allocatable :: nequiv (:) List of the number of equivalent points for each IBZ point. integer(kind=k8), public, allocatable :: ibz2fbz_map (:,:,:) Map from an IBZ phonon point to its images.\n The third axis contains the pair (symmetry index, image). integer(kind=k8), public, allocatable :: equiv_map (:,:) Map of equivalent points under rotations.\n Axis 1 runs over rotations.\n Axis 2 runs over wave vectors (full Brillouin zone). real(kind=dp), public, allocatable :: symmetrizers (:,:,:) Symmetrizers of wave vector dependent vectors. integer(kind=k8), public, allocatable :: tetra (:,:) List of all the wave vector mesh tetrahedra vertices.\n First axis lists tetraheda and the second axis lists the vertices. integer(kind=k8), public, allocatable :: tetracount (:) The number of tetrahedra in which a wave vector belongs. integer(kind=k8), public, allocatable :: tetramap (:,:,:) Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real(kind=dp), public, allocatable :: tetra_evals (:,:,:) Tetrahedra vertices filled with eigenvalues. integer(kind=k8), public, allocatable :: triang (:,:) List of all the wave vector mesh triangles vertices.\n First axis lists triangles and the second axis lists the vertices. integer(kind=k8), public, allocatable :: triangcount (:) The number of triangles in which a wave vector belongs. integer(kind=k8), public, allocatable :: triangmap (:,:,:) Mapping from a wave vector to the (triangle, vertex) where it belongs. real(kind=dp), public, allocatable :: triang_evals (:,:,:) Triangles vertices filled with eigenvalues. real(kind=dp), public, allocatable :: ens (:,:) List of phonon energies on FBZ. real(kind=dp), public, allocatable :: vels (:,:,:) List of phonon velocities on IBZ. complex(kind=dp), public, allocatable :: evecs (:,:,:) List of all phonon eigenvectors on IBZ. integer(kind=k8), public :: scell (3) q-mesh used in DFPT or, equivalently, supercell used in finite displencement\n method for calculating the 2nd order force constants. real(kind=dp), public, allocatable :: ifc2 (:,:,:,:,:,:,:) Second order force constants (ifc2) tensor. real(kind=dp), public, allocatable :: ifc3 (:,:,:,:) Third order force constants (ifc3) tensor. integer(kind=k8), public :: numtriplets Number of triplets in the ifc3 file. real(kind=dp), public, allocatable :: R_j (:,:) Position of the 2nd and 3rd atoms in supercell for an ifc3 triplet. real(kind=dp), public, allocatable :: R_k (:,:) Position of the 2nd and 3rd atoms in supercell for an ifc3 triplet. integer(kind=k8), public, allocatable :: Index_i (:) Label of primitive cell atoms in the ifc3 triplet. integer(kind=k8), public, allocatable :: Index_j (:) Label of primitive cell atoms in the ifc3 triplet. integer(kind=k8), public, allocatable :: Index_k (:) Label of primitive cell atoms in the ifc3 triplet. real(kind=dp), public, allocatable :: dos (:,:) Branch resolved density of states. real(kind=dp), public :: rws (124,0:3) real(kind=dp), public :: cell_r (1:3,0:3) real(kind=dp), public :: cell_g (1:3,0:3) real(kind=dp), public, allocatable :: mm (:,:) real(kind=dp), public, allocatable :: rr (:,:,:) Type-Bound Procedures procedure, public :: deallocate_phonon_quantities private subroutine deallocate_phonon_quantities(ph) Deallocate the electron eigenvectors Arguments Type Intent Optional Attributes Name class( phonon ), intent(inout) :: ph procedure, public :: initialize private subroutine initialize(ph, crys, sym, num) Initialize the phonon data type, calculate ground state phonon properties,\n and read 3rd order force constants data. Arguments Type Intent Optional Attributes Name class( phonon ), intent(out) :: ph type( crystal ), intent(in) :: crys type( symmetry ), intent(in) :: sym type( numerics ), intent(in) :: num","tags":"","loc":"type/phonon.html"},{"title":"epw_wannier – elphbolt ","text":"type, public :: epw_wannier Data and procedures related to Wannierization. Contents Variables numwannbands numbranches nwsk coarse_qmesh nwsq nwsg rcells_k rcells_q rcells_g elwsdeg phwsdeg gwsdeg Hwann Dphwann gwann Type-Bound Procedures plot_along_path deallocate_wannier g2_epw gReq_epw gkRp_epw ph_wann_epw el_wann_epw read Components Type Visibility Attributes Name Initial integer(kind=k8), public :: numwannbands Number of Wannier bands. integer(kind=k8), public :: numbranches Number of phonon branches. integer(kind=k8), public :: nwsk Number of real space cells for electrons. integer(kind=k8), public :: coarse_qmesh (3) Coarse phonon wave vector mesh in Wannier calculation. integer(kind=k8), public :: nwsq Number of real space cells for phonons. integer(kind=k8), public :: nwsg Number of real space cells for electron-phonon vertex. integer(kind=k8), public, allocatable :: rcells_k (:,:) Real space cell locations for electrons. integer(kind=k8), public, allocatable :: rcells_q (:,:) Real space cell locations for phonons. integer(kind=k8), public, allocatable :: rcells_g (:,:) Real space cell locations for electron-phonon vertex. integer(kind=k8), public, allocatable :: elwsdeg (:) Real space cell multiplicity for electrons. integer(kind=k8), public, allocatable :: phwsdeg (:) Real space cell multiplicity for phonons. integer(kind=k8), public, allocatable :: gwsdeg (:) Real space cell multiplicity for electron-phonon vertex. complex(kind=dp), public, allocatable :: Hwann (:,:,:) Hamiltonian in Wannier representation. complex(kind=dp), public, allocatable :: Dphwann (:,:,:) Dynamical matrix in Wannier representation. complex(kind=dp), public, allocatable :: gwann (:,:,:,:,:) e-ph vertex in Wannier representation. Type-Bound Procedures procedure, public :: plot_along_path private subroutine plot_along_path(wann, crys, num) Subroutine to plot bands, dispersions, e-ph matrix elements\n using the Wannier interpolation method with EPW inputs. Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys type( numerics ), intent(in) :: num procedure, public :: deallocate_wannier private subroutine deallocate_wannier(wann, num) Deallocates some Wannier quantities Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(inout) :: wann type( numerics ), intent(in) :: num procedure, public :: g2_epw private function g2_epw(wann, crys, kvec, qvec, el_evec_k, el_evec_kp, ph_evec_q, ph_en, gmixed, wannspace) Function to calculate |g|&#94;2.\n This works with EPW real space data\n kvec: electron wave vector in crystal coords\n qvec: phonon wave vector in crystal coords\n el_evec_k(kp): initial(final) electron eigenvector in bands m(n) \n ph_evec_q: phonon eigenvector branchs \n ph_en: phonon energy in mode (s,qvec)\n gmixed: e-ph matrix element in mixed Wannier-Bloch representation\n wannspace: the species that is in Wannier representation Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys real(kind=dp), intent(in) :: kvec (3) real(kind=dp), intent(in) :: qvec (3) complex(kind=dp), intent(in) :: el_evec_k (wann%numwannbands) complex(kind=dp), intent(in) :: el_evec_kp (wann%numwannbands) complex(kind=dp), intent(in) :: ph_evec_q (wann%numbranches) real(kind=dp), intent(in) :: ph_en complex(kind=dp), intent(in) :: gmixed (:,:,:,:) character(len=2) :: wannspace Return Value real(kind=dp) procedure, public :: gReq_epw private subroutine gReq_epw(wann, num, iq, qvec) Calculate the Bloch-Wannier mixed rep. e-ph matrix elements g(Re,q),\n where q is an IBZ phonon wave vector and Re is a phonon unit cell.\n Note: this step DOES NOT perform the rotation over the Wannier bands space. Read more… Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: wann type( numerics ), intent(in) :: num integer(kind=k8), intent(in) :: iq real(kind=dp), intent(in) :: qvec (3) procedure, public :: gkRp_epw private subroutine gkRp_epw(wann, num, ik, kvec) Calculate the Bloch-Wannier mixed rep. e-ph matrix elements g(k,Rp),\n where k is an IBZ electron wave vector and Rp is a phonon unit cell.\n Note: this step DOES NOT perform the rotation over the Wannier bands space. Read more… Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: wann type( numerics ), intent(in) :: num integer(kind=k8), intent(in) :: ik real(kind=dp), intent(in) :: kvec (3) procedure, public :: ph_wann_epw private subroutine ph_wann_epw(wann, crys, nq, qvecs, energies, evecs) Wannier interpolate phonons on list of arb. q-vec Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys integer(kind=k8), intent(in) :: nq real(kind=dp), intent(in) :: qvecs (nq,3) real(kind=dp), intent(out) :: energies (nq,wann%numbranches) complex(kind=dp), intent(out), optional :: evecs (nq,wann%numbranches,wann%numbranches) procedure, public :: el_wann_epw private subroutine el_wann_epw(wann, crys, nk, kvecs, energies, velocities, evecs) Wannier interpolate electrons on list of arb. k-vecs Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys integer(kind=k8), intent(in) :: nk real(kind=dp), intent(in) :: kvecs (nk,3) real(kind=dp), intent(out) :: energies (nk,wann%numwannbands) real(kind=dp), intent(out), optional :: velocities (nk,wann%numwannbands,3) complex(kind=dp), intent(out), optional :: evecs (nk,wann%numwannbands,wann%numwannbands) procedure, public :: read => read_EPW_Wannier private subroutine read_EPW_Wannier(wann, num) Read Wannier representation of the hamiltonian, dynamical matrix, and the\n e-ph matrix elements from file epwdata.fmt. Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(out) :: wann type( numerics ), intent(in) :: num","tags":"","loc":"type/epw_wannier.html"},{"title":"symmetry – elphbolt ","text":"type, public :: symmetry Data and procedure related to symmetries. Contents Variables nsymm nsymm_rot rotations_orig crotations_orig qrotations_orig rotations crotations qrotations international Type-Bound Procedures calculate_symmetries Components Type Visibility Attributes Name Initial integer(kind=k8), public :: nsymm Number of spacegroup symmetries. integer(kind=k8), public :: nsymm_rot Number of rotations. integer(kind=k8), public, allocatable :: rotations_orig (:,:,:) Rotations without time-reversal, real space, crystal coordinates. real(kind=dp), public, allocatable :: crotations_orig (:,:,:) Rotations without time-reversal, real space, Cartesian coordinates. real(kind=dp), public, allocatable :: qrotations_orig (:,:,:) Rotations without time-reversal, reciprocal space, crystal coordinates. integer(kind=k8), public, allocatable :: rotations (:,:,:) Rotations with time-reversal, real space, crystal coordinates. real(kind=dp), public, allocatable :: crotations (:,:,:) Rotations with time-reversal, real space, Cartesian coordinates. real(kind=dp), public, allocatable :: qrotations (:,:,:) Rotations with time-reversal, reciprocal space, crystal coordinates. character(len=10), public :: international Spacegroup in Hermann–Mauguin (or international) notation. Type-Bound Procedures procedure, public :: calculate_symmetries private subroutine calculate_symmetries(sym, crys, mesh) Subroutine to generate the symmetry related data for a given crystal. Read more… Arguments Type Intent Optional Attributes Name class( symmetry ), intent(out) :: sym type( crystal ), intent(in) :: crys integer(kind=k8), intent(in) :: mesh (3)","tags":"","loc":"type/symmetry.html"},{"title":"numerics – elphbolt ","text":"type, public :: numerics Data and procedures related to the numerics. Contents Variables qmesh mesh_ref fsthick cwd datadumpdir datadumpdir_T datadumpdir_T_chempot g2dir Vdir Wdir Xdir Ydir read_gq2 read_gk2 read_V read_W tetrahedra phe phiso phsubs onlyphbte onlyebte elchimp drag maxiter conv_thres plot_along_path runlevel ph_en_min ph_en_max ph_en_num el_en_min el_en_max el_en_num Type-Bound Procedures create_chempot_dirs initialize Components Type Visibility Attributes Name Initial integer(kind=k8), public :: qmesh (3) Phonon wave vector mesh. integer(kind=k8), public :: mesh_ref Electron mesh refinement factor compared to the phonon mesh. real(kind=dp), public :: fsthick Fermi surface thickness in eV. character(len=1024), public :: cwd Current working directory. character(len=1024), public :: datadumpdir Runtime data dump repository. character(len=1024), public :: datadumpdir_T Runtime temperature dependent data dump repository. character(len=1024), public :: datadumpdir_T_chempot Runtime temperature and chemical potential dependent data dump repository. character(len=1024), public :: g2dir Directory for e-ph vertex. character(len=1024), public :: Vdir Directory for ph-ph vertex. character(len=1024), public :: Wdir Directory for ph-ph transition rates. character(len=1024), public :: Xdir Directory for e-ph transition rates. character(len=1024), public :: Ydir Directory for ph-e transition rates. logical, public :: read_gq2 Choose if earlier e-ph (IBZ q) vertices are to be used. logical, public :: read_gk2 Choose if earlier e-ph (IBZ k) vertices are to be used. logical, public :: read_V Choose if earlier ph-ph (IBZ q) vertices are to be used. logical, public :: read_W Choose if earlier ph-ph (IBZ q) transition probabilities are to be used. logical, public :: tetrahedra Choose if the tetrahedron method for 3d delta function evaluation will be used. logical, public :: phe Choose if ph-e interaction will be included. logical, public :: phiso Use phonon-isotope scattering? logical, public :: phsubs Use phonon-substitution scattering? logical, public :: onlyphbte Choose if only phonon BTE will be solved. logical, public :: onlyebte Choose if electron BTE will be solved. logical, public :: elchimp Use electron-charged impurity scattering? logical, public :: drag Choose if the drag effect will be included. integer(kind=k8), public :: maxiter Maximum number of iterations in the BTE solver. real(kind=dp), public :: conv_thres BTE iteration convergence criterion. logical, public :: plot_along_path Plot Wannierized quantities along high symmetry wave vectors? integer(kind=k8), public :: runlevel Control for the type of calculation. real(kind=dp), public :: ph_en_min Bounds of equidistant phonon energy mesh. real(kind=dp), public :: ph_en_max Bounds of equidistant phonon energy mesh. integer(kind=k8), public :: ph_en_num Number of equidistant phonon energy mesh points. real(kind=dp), public :: el_en_min Bounds of equidistant phonon energy mesh. real(kind=dp), public :: el_en_max Bounds of equidistant phonon energy mesh. integer(kind=k8), public :: el_en_num Number of equidistant phonon energy mesh points. Type-Bound Procedures procedure, public :: create_chempot_dirs private subroutine create_chempot_dirs(n, chempot) Subroutine to create data dump directory tagged by the chemical potential\n and subdirectories within. Arguments Type Intent Optional Attributes Name class( numerics ), intent(inout) :: n real(kind=dp), intent(in) :: chempot procedure, public :: initialize => read_input_and_setup private subroutine read_input_and_setup(n, crys) Read input file for information related to the numerics. Read more… Arguments Type Intent Optional Attributes Name class( numerics ), intent(out) :: n type( crystal ), intent(in) :: crys","tags":"","loc":"type/numerics.html"},{"title":"crystal – elphbolt ","text":"type, public :: crystal Data and procedures related to the crystal structure. Contents Variables numelements numatoms name elements atomtypes masses polar epsilon born epsilon0 read_epsiloninf epsiloninf qTF basis basis_cart lattvecs volume reclattvecs volume_bz T autoisotopes gfactors subs_masses subs_conc subs_gfactors twod dim thickness Type-Bound Procedures initialize Components Type Visibility Attributes Name Initial integer(kind=k8), public :: numelements Number of types of basis atoms. integer(kind=k8), public :: numatoms Number of basis atoms. character(len=100), public :: name Name of material. character(len=3), public, allocatable :: elements (:) Elements in the basis. integer(kind=k8), public, allocatable :: atomtypes (:) Integer tagging unique elements in the basis. real(kind=dp), public, allocatable :: masses (:) Masses of the basis atoms. logical, public :: polar Is the system polar? real(kind=dp), public :: epsilon (3,3) Dielectric tensor. real(kind=dp), public, allocatable :: born (:,:,:) Born effective charge. real(kind=dp), public :: epsilon0 Static dielectric constant. logical, public :: read_epsiloninf Read high-frequency dielectric constant? real(kind=dp), public :: epsiloninf High frequency dielectric constant. real(kind=dp), public :: qTF Thomas-Fermi screening wave vector. real(kind=dp), public, allocatable :: basis (:,:) Basis vectors (crystal coordinates). real(kind=dp), public, allocatable :: basis_cart (:,:) Basis vectors (Cartesian coordinates). real(kind=dp), public :: lattvecs (3,3) Lattice vectors (nm). real(kind=dp), public :: volume Volume of primitive cell (nm&#94;3). real(kind=dp), public :: reclattvecs (3,3) Reciprocal lattice vectors. real(kind=dp), public :: volume_bz Brillouin zone volume (nm&#94;-3). real(kind=dp), public :: T Crystal temperature (K). logical, public :: autoisotopes Use isotopic mix for masses? real(kind=dp), public, allocatable :: gfactors (:) g-factors. real(kind=dp), public, allocatable :: subs_masses (:) Masses of the substitutional atoms real(kind=dp), public, allocatable :: subs_conc (:) Concentration of the substitutional atoms in cm&#94;-3 real(kind=dp), public, allocatable :: subs_gfactors (:) g-factors for the substitutional defects. logical, public :: twod Is the system 2d? real(kind=dp), public :: dim Dimension of the system real(kind=dp), public :: thickness Thickness of the system Type-Bound Procedures procedure, public :: initialize => read_input_and_setup_crystal private subroutine read_input_and_setup_crystal(c) Read input file and initialize crystal data. Arguments Type Intent Optional Attributes Name class( crystal ), intent(out) :: c","tags":"","loc":"type/crystal.html"},{"title":"electron – elphbolt ","text":"type, public :: electron Data and procedures related to the electronic properties. Contents Variables prefix spindeg numbands numtransbands indlowband indhighband indlowconduction indhighvalence bandlist mesh_ref mesh_ref_array kmesh nk nk_irred nstates_inwindow nstates_irred_inwindow IBZ_inwindow_states enref fsthick chempot conc conc_el conc_hole chimp_conc_n chimp_conc_p Zn Zp wavevecs wavevecs_irred indexlist indexlist_irred nequiv ibz2fbz_map fbz2ibz_map equiv_map symmetrizers tetra tetracount tetramap tetra_evals triang triangcount triangmap triang_evals ens ens_irred vels vels_irred evecs evecs_irred metallic dos dopingtype numconc conclist numT Tlist Type-Bound Procedures deallocate_eigenvecs initialize Components Type Visibility Attributes Name Initial character(len=2), public :: prefix = 'el' Prefix idenitfying particle type. integer(kind=k8), public :: spindeg Spin degeneracy. integer(kind=k8), public :: numbands Total number of electronic Wannier bands. integer(kind=k8), public :: numtransbands Total number of transport active bands. integer(kind=k8), public :: indlowband Lowest transport band index. integer(kind=k8), public :: indhighband Highest transport band index. integer(kind=k8), public :: indlowconduction Lowest conduction band index. integer(kind=k8), public :: indhighvalence Highest valence band index. integer(kind=k8), public, allocatable :: bandlist (:) List of transport active band indices. integer(kind=k8), public :: mesh_ref Electron mesh refinement factor compared to the phonon mesh. integer(kind=k8), public :: mesh_ref_array (3) The same as above, but in array form. This is useful for 3d vs 2d cases. integer(kind=k8), public :: kmesh (3) Electron wave vector mesh. integer(kind=k8), public :: nk Number of fine electron wave vectors in the full Brillouin zone (FBZ). integer(kind=k8), public :: nk_irred Number of fine electron wave vectors in the irreducible wedge of Brillouin zone (IBZ). integer(kind=k8), public :: nstates_inwindow Number of electron wave vectors within transport window. integer(kind=k8), public :: nstates_irred_inwindow Number of IBZ wedge electron wave vectors within transport window. integer(kind=k8), public, allocatable :: IBZ_inwindow_states (:,:) List of irreducible wedge states within transport window. real(kind=dp), public :: enref Electron reference energy (eV).\n This is the center of the transport energy window. real(kind=dp), public :: fsthick Fermi surface thickness (eV). real(kind=dp), public :: chempot Chemical potential in (eV). real(kind=dp), public, allocatable :: conc (:) Band resolved carrier concentration. real(kind=dp), public :: conc_el Total electron carrier concentration. real(kind=dp), public :: conc_hole Total hole carrier concentration. real(kind=dp), public :: chimp_conc_n Concentration of donor impurities. real(kind=dp), public :: chimp_conc_p Concentration of acceptor impurities. real(kind=dp), public :: Zn Ionization number of donor dopant. real(kind=dp), public :: Zp Ionization number of acceptor dopant. real(kind=dp), public, allocatable :: wavevecs (:,:) List of all electron wave vectors (crystal coordinates). real(kind=dp), public, allocatable :: wavevecs_irred (:,:) List of irreducible electron wave vectors (crystal coordinates). integer(kind=k8), public, allocatable :: indexlist (:) List of muxed indices of the FBZ wave vectors. integer(kind=k8), public, allocatable :: indexlist_irred (:) List of muxed indices of the IBZ wedge. integer(kind=k8), public, allocatable :: nequiv (:) List of the number of equivalent points for each IBZ point. integer(kind=k8), public, allocatable :: ibz2fbz_map (:,:,:) Map from an IBZ electron point to its images.\n The third axis contains the pair (symmetry index, image). integer(kind=k8), public, allocatable :: fbz2ibz_map (:) Map from an FBZ electron point to its IBZ wedge image. integer(kind=k8), public, allocatable :: equiv_map (:,:) Map of equivalent points under rotations.\n Axis 1 runs over rotations.\n Axis 2 runs over wave vectors. real(kind=dp), public, allocatable :: symmetrizers (:,:,:) Symmetrizers of wave vector dependent vectors. integer(kind=k8), public, allocatable :: tetra (:,:) List of all the wave vector mesh tetrahedra vertices.\n First axis list tetraheda and the second axis list the vertices. integer(kind=k8), public, allocatable :: tetracount (:) The number of tetrahedra in which a wave vector belongs. integer(kind=k8), public, allocatable :: tetramap (:,:,:) Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real(kind=dp), public, allocatable :: tetra_evals (:,:,:) Tetrahedra vertices filled with eigenvalues. integer(kind=k8), public, allocatable :: triang (:,:) List of all the wave vector mesh triangles vertices.\n First axis lists triangles and the second axis lists the vertices. integer(kind=k8), public, allocatable :: triangcount (:) The number of triangles in which a wave vector belongs. integer(kind=k8), public, allocatable :: triangmap (:,:,:) Mapping from a wave vector to the (triangle, vertex) where it belongs. real(kind=dp), public, allocatable :: triang_evals (:,:,:) Triangles vertices filled with eigenvalues. real(kind=dp), public, allocatable :: ens (:,:) List of electron energies on FBZ. real(kind=dp), public, allocatable :: ens_irred (:,:) List of electron energies on IBZ. real(kind=dp), public, allocatable :: vels (:,:,:) List of electron velocities on FBZ. real(kind=dp), public, allocatable :: vels_irred (:,:,:) List of electron velocites on IBZ. complex(kind=dp), public, allocatable :: evecs (:,:,:) List of all electron eigenvectors. complex(kind=dp), public, allocatable :: evecs_irred (:,:,:) List of IBZ wedge electron eigenvectors. logical, public :: metallic Is the system metallic? real(kind=dp), public, allocatable :: dos (:,:) Band resolved density of states. character(len=1), public :: dopingtype Type of doping. This is needed for runlevel 0 only. integer(kind=k8), public :: numconc Number of concentration points. This is needed for runlevel 0 only. real(kind=dp), public, allocatable :: conclist (:) List of concentrations. This is needed for runlevel 0 only. integer(kind=k8), public :: numT Number of temperature points. This is needed for runlevel 0 only. real(kind=dp), public, allocatable :: Tlist (:) List of temperatures. This is needed for runlevel 0 only. Type-Bound Procedures procedure, public :: deallocate_eigenvecs private subroutine deallocate_eigenvecs(el) Deallocate the electron eigenvectors Arguments Type Intent Optional Attributes Name class( electron ), intent(inout) :: el procedure, public :: initialize => read_input_and_setup private subroutine read_input_and_setup(el, wann, crys, sym, num) Read input file and setup groundstate electronic system. Arguments Type Intent Optional Attributes Name class( electron ), intent(out) :: el type( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys type( symmetry ), intent(in) :: sym type( numerics ), intent(in) :: num","tags":"","loc":"type/electron.html"},{"title":"delta_fn_tetra – elphbolt","text":"public pure function delta_fn_tetra(e, ik, ib, mesh, tetramap, tetracount, tetra_evals) Calculate delta function using the tetraheron method. e Sample energy\n ik Wave vector index\n ib Band index\n mesh Wave vector grid\n tetramap Wave vector to (tetrahedron, vertex) mapping\n tetracount Number of tetrahedra in which a wave vector belongs\n tetra_evals Tetrahedra populated with the eigenvalues Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: e integer(kind=k8), intent(in) :: ik integer(kind=k8), intent(in) :: ib integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(in) :: tetramap (:,:,:) integer(kind=k8), intent(in) :: tetracount (:) real(kind=dp), intent(in) :: tetra_evals (:,:,:) Return Value real(kind=dp) Called by proc~~delta_fn_tetra~~CalledByGraph proc~delta_fn_tetra delta_fn_tetra proc~calculate_echimp_interaction_ibzk calculate_echimp_interaction_ibzk proc~calculate_echimp_interaction_ibzk->proc~delta_fn_tetra proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk proc~calculate_eph_interaction_ibzk->proc~delta_fn_tetra proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~calculate_eph_interaction_ibzq->proc~delta_fn_tetra proc~calculate_spectral_transport_coeff calculate_spectral_transport_coeff proc~calculate_spectral_transport_coeff->proc~delta_fn_tetra proc~calculate_3ph_interaction calculate_3ph_interaction proc~calculate_3ph_interaction->proc~delta_fn_tetra program~elphbolt elphbolt program~elphbolt->proc~calculate_echimp_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzq program~elphbolt->proc~calculate_3ph_interaction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/delta_fn_tetra.html"},{"title":"delta_fn_triang – elphbolt","text":"public pure function delta_fn_triang(e, ik, ib, mesh, triangmap, triangcount, triang_evals) Calculate delta function using the triangle method a la\n Kurganskii et al. Phys. Stat. Sol.(b) 129, 293 (1985) e Sample energy\n ik Wave vector index\n ib Band index\n mesh Wave vector grid\n triangmap Wave vector to (triangle, vertex) mapping\n triangcount Number of triangles in which a wave vector belongs\n triang_evals Triangles populated with the eigenvalues Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: e integer(kind=k8), intent(in) :: ik integer(kind=k8), intent(in) :: ib integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(in) :: triangmap (:,:,:) integer(kind=k8), intent(in) :: triangcount (:) real(kind=dp), intent(in) :: triang_evals (:,:,:) Return Value real(kind=dp) Called by proc~~delta_fn_triang~~CalledByGraph proc~delta_fn_triang delta_fn_triang proc~calculate_echimp_interaction_ibzk calculate_echimp_interaction_ibzk proc~calculate_echimp_interaction_ibzk->proc~delta_fn_triang proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk proc~calculate_eph_interaction_ibzk->proc~delta_fn_triang proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~calculate_eph_interaction_ibzq->proc~delta_fn_triang proc~calculate_spectral_transport_coeff calculate_spectral_transport_coeff proc~calculate_spectral_transport_coeff->proc~delta_fn_triang proc~calculate_3ph_interaction calculate_3ph_interaction proc~calculate_3ph_interaction->proc~delta_fn_triang program~elphbolt elphbolt program~elphbolt->proc~calculate_echimp_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzq program~elphbolt->proc~calculate_3ph_interaction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/delta_fn_triang.html"},{"title":"form_tetrahedra_3d – elphbolt","text":"public subroutine form_tetrahedra_3d(nk, mesh, tetra, tetracount, tetramap, blocks, indexlist) Form all the tetrahedra of a 3d FBZ mesh. nk Number of points in the list of FBZ wave vectors\n mesh Wave vector grid\n tetra List of the tetrahedra vertices\n tetracount Number of tetrahedra in which a wave vector belongs\n tetramap Wave vector to (tetrahedron, vertex) mapping\n blocks Is the FBZ wave vector list full or energy restricted?\n indexlist List of muxed indices of the FBZ wave vectors Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: nk integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(out), allocatable :: tetra (:,:) integer(kind=k8), intent(out), allocatable :: tetracount (:) integer(kind=k8), intent(out), allocatable :: tetramap (:,:,:) logical, intent(in) :: blocks integer(kind=k8), intent(in), optional :: indexlist (:) Calls proc~~form_tetrahedra_3d~~CallsGraph proc~form_tetrahedra_3d form_tetrahedra_3d proc~demux_vector demux_vector proc~form_tetrahedra_3d->proc~demux_vector proc~mux_vector mux_vector proc~form_tetrahedra_3d->proc~mux_vector proc~binsearch binsearch proc~form_tetrahedra_3d->proc~binsearch proc~exit_with_message exit_with_message proc~demux_vector->proc~exit_with_message proc~mux_vector->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/form_tetrahedra_3d.html"},{"title":"fill_tetrahedra_3d – elphbolt","text":"public subroutine fill_tetrahedra_3d(tetra, evals, tetra_evals) Populate the (sorted along the vertices) eigenvalues on all the vertices of the tetrahedra tetra List of the tetrahedra vertices\n evals List of eigenvalues \n tetra_evals Tetrahedra populated with the eigenvalues Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: tetra (:,:) real(kind=dp), intent(in) :: evals (:,:) real(kind=dp), intent(out), allocatable :: tetra_evals (:,:,:) Contents None","tags":"","loc":"proc/fill_tetrahedra_3d.html"},{"title":"form_triangles – elphbolt","text":"public subroutine form_triangles(nk, mesh, triang, triangcount, triangmap, blocks, indexlist) Form all the triangles of a 3d FBZ mesh for each z component. nk Number of points in the list of FBZ wave vectors\n mesh Wave vector grid\n triang List of the triangle vertices\n triangcount Number of triangles in which a wave vector belongs\n triangmap Wave vector to (triangle, vertex) mapping\n blocks Is the FBZ wave vector list full or energy restricted?\n indexlist List of muxed indices of the FBZ wave vectors Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: nk integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(out), allocatable :: triang (:,:) integer(kind=k8), intent(out), allocatable :: triangcount (:) integer(kind=k8), intent(out), allocatable :: triangmap (:,:,:) logical, intent(in) :: blocks integer(kind=k8), intent(in), optional :: indexlist (:) Calls proc~~form_triangles~~CallsGraph proc~form_triangles form_triangles proc~demux_vector demux_vector proc~form_triangles->proc~demux_vector proc~mux_vector mux_vector proc~form_triangles->proc~mux_vector proc~binsearch binsearch proc~form_triangles->proc~binsearch proc~exit_with_message exit_with_message proc~demux_vector->proc~exit_with_message proc~mux_vector->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/form_triangles.html"},{"title":"fill_triangles – elphbolt","text":"public subroutine fill_triangles(triang, evals, triang_evals) Populate the (sorted along the vertices) eigenvalues on all the vertices of the triangles triang List of the triangle vertices\n evals List of eigenvalues \n triang_evals Triangles populated with the eigenvalues Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: triang (:,:) real(kind=dp), intent(in) :: evals (:,:) real(kind=dp), intent(out), allocatable :: triang_evals (:,:,:) Contents None","tags":"","loc":"proc/fill_triangles.html"},{"title":"phonon_espresso – elphbolt","text":"public subroutine phonon_espresso(ph, crys, nk, kpoints, omegas, eigenvect, velocities) Subroutine to calculate phonons from the 2nd order force constants. Arguments Type Intent Optional Attributes Name type( phonon ), intent(in) :: ph type( crystal ), intent(in) :: crys integer(kind=k8), intent(in) :: nk real(kind=dp), intent(in) :: kpoints (nk,3) real(kind=dp), intent(out) :: omegas (nk,ph%numbranches) complex(kind=8), intent(out), optional :: eigenvect (nk,ph%numbranches,ph%numbranches) real(kind=dp), intent(out), optional :: velocities (nk,ph%numbranches,3) Calls proc~~phonon_espresso~~CallsGraph proc~phonon_espresso phonon_espresso proc~expi expi proc~phonon_espresso->proc~expi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/phonon_espresso.html"},{"title":"calculate_qTF – elphbolt","text":"public subroutine calculate_qTF(crys, el) Calculate Thomas-Fermi screening wavevector in the simple electron-gas model. Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: crys type( electron ), intent(in) :: el Calls proc~~calculate_qtf~~CallsGraph proc~calculate_qtf calculate_qTF proc~print_message print_message proc~calculate_qtf->proc~print_message proc~fermi Fermi proc~calculate_qtf->proc~fermi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calculate_qtf~~CalledByGraph proc~calculate_qtf calculate_qTF program~elphbolt elphbolt program~elphbolt->proc~calculate_qtf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_qtf.html"},{"title":"calculate_transport_coeff – elphbolt","text":"public subroutine calculate_transport_coeff(species_prefix, field, T, deg, chempot, ens, vels, volume, mesh, response, sym, trans_coeff_hc, trans_coeff_cc) Subroutine to calculate transport coefficients. species_prefix Prefix of particle type\n field Type of field\n T Temperature in K\n deg Degeneracy\n chempot Chemical potential in eV\n ens FBZ energies in eV\n vels FBZ velocities in Km/s\n volume Primitive cell volume in nm&#94;3\n mesh Wave vector grid\n response FBZ response function\n sym Symmery object\n trans_coeff_hc Heat current coefficient\n trans_coeff_cc Charge current coefficient Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: species_prefix character(len=1), intent(in) :: field real(kind=dp), intent(in) :: T integer(kind=k8), intent(in) :: deg real(kind=dp), intent(in) :: chempot real(kind=dp), intent(in) :: ens (:,:) real(kind=dp), intent(in) :: vels (:,:,:) real(kind=dp), intent(in) :: volume integer(kind=k8), intent(in) :: mesh (3) real(kind=dp), intent(in) :: response (:,:,:) type( symmetry ), intent(in) :: sym real(kind=dp), intent(out) :: trans_coeff_hc (:,:,:) real(kind=dp), intent(out) :: trans_coeff_cc (:,:,:) Calls proc~~calculate_transport_coeff~~CallsGraph proc~calculate_transport_coeff calculate_transport_coeff proc~bose Bose proc~calculate_transport_coeff->proc~bose proc~fermi Fermi proc~calculate_transport_coeff->proc~fermi proc~exit_with_message exit_with_message proc~calculate_transport_coeff->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_transport_coeff.html"},{"title":"calculate_spectral_transport_coeff – elphbolt","text":"public subroutine calculate_spectral_transport_coeff(species, field, T, deg, chempot, ens, vels, volume, response, en_grid, usetetra, sym, trans_coeff_hc, trans_coeff_cc) Subroutine to calculate the spectral transport coefficients. species Object of species type\n field Type of field\n T Temperature in K\n deg Degeneracy\n chempot Chemical potential in eV\n ens FBZ energies in eV\n vels FBZ velocities in Km/s\n volume Primitive cell volume in nm&#94;3\n usetetra Use tetrahedron method?\n sym Symmery object\n trans_coeff_hc Heat current coefficient\n trans_coeff_cc Charge current coefficient Arguments Type Intent Optional Attributes Name class(*), intent(in) :: species character(len=1), intent(in) :: field real(kind=dp), intent(in) :: T integer(kind=k8), intent(in) :: deg real(kind=dp), intent(in) :: chempot real(kind=dp), intent(in) :: ens (:,:) real(kind=dp), intent(in) :: vels (:,:,:) real(kind=dp), intent(in) :: volume real(kind=dp), intent(in) :: response (:,:,:) real(kind=dp), intent(in) :: en_grid (:) logical, intent(in) :: usetetra type( symmetry ), intent(in) :: sym real(kind=dp), intent(out) :: trans_coeff_hc (:,:,:,:) real(kind=dp), intent(out) :: trans_coeff_cc (:,:,:,:) Calls proc~~calculate_spectral_transport_coeff~~CallsGraph proc~calculate_spectral_transport_coeff calculate_spectral_transport_coeff proc~bose Bose proc~calculate_spectral_transport_coeff->proc~bose proc~exit_with_message exit_with_message proc~calculate_spectral_transport_coeff->proc~exit_with_message proc~delta_fn_tetra delta_fn_tetra proc~calculate_spectral_transport_coeff->proc~delta_fn_tetra proc~fermi Fermi proc~calculate_spectral_transport_coeff->proc~fermi proc~delta_fn_triang delta_fn_triang proc~calculate_spectral_transport_coeff->proc~delta_fn_triang Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_spectral_transport_coeff.html"},{"title":"calculate_dos – elphbolt","text":"public interface calculate_dos Called by interface~~calculate_dos~~CalledByGraph interface~calculate_dos calculate_dos program~elphbolt elphbolt program~elphbolt->interface~calculate_dos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures calculate_el_dos calculate_ph_dos_iso Module Procedures private subroutine calculate_el_dos(el, usetetra) Calculate the density of states (DOS) in units of 1/energy. \n The DOS will be evaluates on the IBZ mesh energies. Read more… Arguments Type Intent Optional Attributes Name type( electron ), intent(inout) :: el logical, intent(in) :: usetetra private subroutine calculate_ph_dos_iso(ph, usetetra, gfactors, subs_gfactors, atomtypes, W_phiso, W_phsubs, phiso, phsubs) Calculate the phonon density of states (DOS) in units of 1/energy and,\n optionally, the phonon-isotope scattering rates. Read more… Arguments Type Intent Optional Attributes Name type( phonon ), intent(inout) :: ph logical, intent(in) :: usetetra real(kind=dp), intent(in) :: gfactors (:) real(kind=dp), intent(in) :: subs_gfactors (:) integer(kind=k8), intent(in) :: atomtypes (:) real(kind=dp), intent(out), allocatable :: W_phiso (:,:) real(kind=dp), intent(out), allocatable :: W_phsubs (:,:) logical, intent(in) :: phiso logical, intent(in) :: phsubs","tags":"","loc":"interface/calculate_dos.html"},{"title":"calculate_3ph_interaction – elphbolt","text":"public subroutine calculate_3ph_interaction(ph, crys, num, key) Parallel driver of the 3-ph vertex calculator for all IBZ phonon wave vectors.\n This subroutine calculates |V-(s1 |s2q2,s3q3)|&#94;2, W-(s1 |s2q2,s3q3),\n and W+(s1 |s2q2,s3q3) for each irreducible phonon and saves the results to disk. key = 'V', 'W' for vertex, transition probabilitiy calculation, respectively. Arguments Type Intent Optional Attributes Name type( phonon ), intent(in) :: ph type( crystal ), intent(in) :: crys type( numerics ), intent(in) :: num character(len=1), intent(in) :: key Calls proc~~calculate_3ph_interaction~~CallsGraph proc~calculate_3ph_interaction calculate_3ph_interaction proc~bose Bose proc~calculate_3ph_interaction->proc~bose proc~print_message print_message proc~calculate_3ph_interaction->proc~print_message proc~exit_with_message exit_with_message proc~calculate_3ph_interaction->proc~exit_with_message proc~mux_vector mux_vector proc~calculate_3ph_interaction->proc~mux_vector proc~delta_fn_tetra delta_fn_tetra proc~calculate_3ph_interaction->proc~delta_fn_tetra proc~mux_state mux_state proc~calculate_3ph_interaction->proc~mux_state proc~expi expi proc~calculate_3ph_interaction->proc~expi proc~demux_state demux_state proc~calculate_3ph_interaction->proc~demux_state proc~distribute_points distribute_points proc~calculate_3ph_interaction->proc~distribute_points proc~delta_fn_triang delta_fn_triang proc~calculate_3ph_interaction->proc~delta_fn_triang proc~mux_vector->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calculate_3ph_interaction~~CalledByGraph proc~calculate_3ph_interaction calculate_3ph_interaction program~elphbolt elphbolt program~elphbolt->proc~calculate_3ph_interaction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_3ph_interaction.html"},{"title":"calculate_gReq – elphbolt","text":"public subroutine calculate_gReq(wann, ph, num) Parallel driver of gReq_epw over IBZ phonon wave vectors. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num Calls proc~~calculate_greq~~CallsGraph proc~calculate_greq calculate_gReq proc~print_message print_message proc~calculate_greq->proc~print_message proc~distribute_points distribute_points proc~calculate_greq->proc~distribute_points Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calculate_greq~~CalledByGraph proc~calculate_greq calculate_gReq program~elphbolt elphbolt program~elphbolt->proc~calculate_greq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_greq.html"},{"title":"calculate_gkRp – elphbolt","text":"public subroutine calculate_gkRp(wann, el, num) Parallel driver of gkRp_epw over IBZ electron wave vectors. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( electron ), intent(in) :: el type( numerics ), intent(in) :: num Calls proc~~calculate_gkrp~~CallsGraph proc~calculate_gkrp calculate_gkRp proc~print_message print_message proc~calculate_gkrp->proc~print_message proc~distribute_points distribute_points proc~calculate_gkrp->proc~distribute_points Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calculate_gkrp~~CalledByGraph proc~calculate_gkrp calculate_gkRp program~elphbolt elphbolt program~elphbolt->proc~calculate_gkrp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_gkrp.html"},{"title":"calculate_eph_interaction_ibzq – elphbolt","text":"public subroutine calculate_eph_interaction_ibzq(wann, crys, el, ph, num, key) Parallel driver of g2(q,k) over IBZ phonon states. This subroutine will calculate the full Bloch rep. matrix elements for\n all the energy window restricted electron-phonon processes for a given\n irreducible initial phonon state = (branch, wave vector). \n This list will be written to disk in files tagged with the muxed state index. key = 'g', 'Y' for vertex, transition probability calculation, respectively. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num character(len=1), intent(in) :: key Calls proc~~calculate_eph_interaction_ibzq~~CallsGraph proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~bose Bose proc~calculate_eph_interaction_ibzq->proc~bose proc~print_message print_message proc~calculate_eph_interaction_ibzq->proc~print_message proc~mux_vector mux_vector proc~calculate_eph_interaction_ibzq->proc~mux_vector proc~exit_with_message exit_with_message proc~calculate_eph_interaction_ibzq->proc~exit_with_message proc~delta_fn_tetra delta_fn_tetra proc~calculate_eph_interaction_ibzq->proc~delta_fn_tetra proc~mux_state mux_state proc~calculate_eph_interaction_ibzq->proc~mux_state proc~binsearch binsearch proc~calculate_eph_interaction_ibzq->proc~binsearch proc~demux_state demux_state proc~calculate_eph_interaction_ibzq->proc~demux_state proc~fermi Fermi proc~calculate_eph_interaction_ibzq->proc~fermi proc~distribute_points distribute_points proc~calculate_eph_interaction_ibzq->proc~distribute_points proc~delta_fn_triang delta_fn_triang proc~calculate_eph_interaction_ibzq->proc~delta_fn_triang proc~mux_vector->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calculate_eph_interaction_ibzq~~CalledByGraph proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq program~elphbolt elphbolt program~elphbolt->proc~calculate_eph_interaction_ibzq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_eph_interaction_ibzq.html"},{"title":"calculate_eph_interaction_ibzk – elphbolt","text":"public subroutine calculate_eph_interaction_ibzk(wann, crys, el, ph, num, key) Parallel driver of g2(k,q) over IBZ electron states. This subroutine will calculate the full Bloch rep. matrix elements for\n all the energy window restricted electron-phonon processes for a given\n irreducible initial electron state = (band, wave vector). \n This list will be written to disk in files tagged with the muxed state index. key = 'g', 'X' for vertex, transition probability calculation, respectively. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num character(len=1), intent(in) :: key Calls proc~~calculate_eph_interaction_ibzk~~CallsGraph proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk proc~bose Bose proc~calculate_eph_interaction_ibzk->proc~bose proc~print_message print_message proc~calculate_eph_interaction_ibzk->proc~print_message proc~exit_with_message exit_with_message proc~calculate_eph_interaction_ibzk->proc~exit_with_message proc~mux_vector mux_vector proc~calculate_eph_interaction_ibzk->proc~mux_vector proc~delta_fn_tetra delta_fn_tetra proc~calculate_eph_interaction_ibzk->proc~delta_fn_tetra proc~mux_state mux_state proc~calculate_eph_interaction_ibzk->proc~mux_state proc~demux_state demux_state proc~calculate_eph_interaction_ibzk->proc~demux_state proc~fermi Fermi proc~calculate_eph_interaction_ibzk->proc~fermi proc~distribute_points distribute_points proc~calculate_eph_interaction_ibzk->proc~distribute_points proc~delta_fn_triang delta_fn_triang proc~calculate_eph_interaction_ibzk->proc~delta_fn_triang proc~mux_vector->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calculate_eph_interaction_ibzk~~CalledByGraph proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk program~elphbolt elphbolt program~elphbolt->proc~calculate_eph_interaction_ibzk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_eph_interaction_ibzk.html"},{"title":"calculate_echimp_interaction_ibzk – elphbolt","text":"public subroutine calculate_echimp_interaction_ibzk(crys, el, num) Parallel driver of |g_e-chimp(k,k')|&#94;2 over IBZ electron states. Arguments Type Intent Optional Attributes Name type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( numerics ), intent(in) :: num Calls proc~~calculate_echimp_interaction_ibzk~~CallsGraph proc~calculate_echimp_interaction_ibzk calculate_echimp_interaction_ibzk proc~print_message print_message proc~calculate_echimp_interaction_ibzk->proc~print_message proc~delta_fn_tetra delta_fn_tetra proc~calculate_echimp_interaction_ibzk->proc~delta_fn_tetra proc~mux_state mux_state proc~calculate_echimp_interaction_ibzk->proc~mux_state proc~demux_state demux_state proc~calculate_echimp_interaction_ibzk->proc~demux_state proc~delta_fn_triang delta_fn_triang proc~calculate_echimp_interaction_ibzk->proc~delta_fn_triang proc~distribute_points distribute_points proc~calculate_echimp_interaction_ibzk->proc~distribute_points Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calculate_echimp_interaction_ibzk~~CalledByGraph proc~calculate_echimp_interaction_ibzk calculate_echimp_interaction_ibzk program~elphbolt elphbolt program~elphbolt->proc~calculate_echimp_interaction_ibzk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_echimp_interaction_ibzk.html"},{"title":"calculate_ph_rta_rates – elphbolt","text":"public subroutine calculate_ph_rta_rates(rta_rates_3ph, rta_rates_phe, num, crys, ph, el) Subroutine for parallel reading of the 3-ph and ph-e transition probabilities\n from disk and calculating the relaxation time approximation (RTA)\n scattering rates for the 3-ph and ph-e channels. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), allocatable :: rta_rates_3ph (:,:) real(kind=dp), intent(out), allocatable :: rta_rates_phe (:,:) type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( phonon ), intent(in) :: ph type( electron ), intent(in), optional :: el Calls proc~~calculate_ph_rta_rates~~CallsGraph proc~calculate_ph_rta_rates calculate_ph_rta_rates proc~demux_state demux_state proc~calculate_ph_rta_rates->proc~demux_state proc~distribute_points distribute_points proc~calculate_ph_rta_rates->proc~distribute_points Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_ph_rta_rates.html"},{"title":"calculate_el_rta_rates – elphbolt","text":"public subroutine calculate_el_rta_rates(rta_rates_eph, rta_rates_echimp, num, crys, el) Subroutine for parallel reading of the e-ph transition probabilities\n from disk and calculating the relaxation time approximation (RTA)\n scattering rates for the e-ph channel. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), allocatable :: rta_rates_eph (:,:) real(kind=dp), intent(out), allocatable :: rta_rates_echimp (:,:) type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el Calls proc~~calculate_el_rta_rates~~CallsGraph proc~calculate_el_rta_rates calculate_el_rta_rates proc~demux_state demux_state proc~calculate_el_rta_rates->proc~demux_state proc~distribute_points distribute_points proc~calculate_el_rta_rates->proc~distribute_points Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_el_rta_rates.html"},{"title":"read_transition_probs_e – elphbolt","text":"public subroutine read_transition_probs_e(filepath, N, TP, istate1, istate2) Subroutine to read transition probabilities from disk for interaction processes. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath integer(kind=k8), intent(out) :: N real(kind=dp), intent(out), allocatable :: TP (:) integer(kind=k8), intent(out), optional allocatable :: istate1 (:) integer(kind=k8), intent(out), optional allocatable :: istate2 (:) Contents None","tags":"","loc":"proc/read_transition_probs_e.html"},{"title":"cross_product – elphbolt","text":"public function cross_product(A, B) Cross product of A and B. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (3) real(kind=dp), intent(in) :: B (3) Return Value real(kind=dp)\n  (3) Contents None","tags":"","loc":"proc/cross_product.html"},{"title":"expi – elphbolt","text":"public pure function expi(x) Calculate exp(i*x) = cos(x) + isin(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value complex(kind=dp) Called by proc~~expi~~CalledByGraph proc~expi expi proc~calculate_3ph_interaction calculate_3ph_interaction proc~calculate_3ph_interaction->proc~expi proc~phonon_espresso phonon_espresso proc~phonon_espresso->proc~expi program~elphbolt elphbolt program~elphbolt->proc~calculate_3ph_interaction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/expi.html"},{"title":"twonorm – elphbolt","text":"public pure function twonorm(v) 2-norm of a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/twonorm.html"},{"title":"trace – elphbolt","text":"public pure function trace(mat) Trace of square matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/trace.html"},{"title":"mux_vector – elphbolt","text":"public function mux_vector(v, mesh, base) Multiplex index of a single wave vector.\n v is the demultiplexed triplet of a wave vector.\n i is the multiplexed index of a wave vector (always 1-based).\n mesh is the number of wave vectors along the three reciprocal lattice vectors.\n base states whether v has 0- or 1-based indexing. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: v (3) integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(in) :: base Return Value integer(kind=k8) Calls proc~~mux_vector~~CallsGraph proc~mux_vector mux_vector proc~exit_with_message exit_with_message proc~mux_vector->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mux_vector~~CalledByGraph proc~mux_vector mux_vector proc~form_triangles form_triangles proc~form_triangles->proc~mux_vector proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk proc~calculate_eph_interaction_ibzk->proc~mux_vector proc~find_equiv_map find_equiv_map proc~find_equiv_map->proc~mux_vector proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~calculate_eph_interaction_ibzq->proc~mux_vector proc~calculate_3ph_interaction calculate_3ph_interaction proc~calculate_3ph_interaction->proc~mux_vector proc~form_tetrahedra_3d form_tetrahedra_3d proc~form_tetrahedra_3d->proc~mux_vector program~elphbolt elphbolt program~elphbolt->proc~calculate_eph_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzq program~elphbolt->proc~calculate_3ph_interaction proc~find_irred_wedge find_irred_wedge proc~find_irred_wedge->proc~find_equiv_map Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mux_vector.html"},{"title":"mux_state – elphbolt","text":"public pure function mux_state(nbands, iband, ik) Multiplex a (band index, wave vector index) pair into a state index nbands is the number of bands\n iband is the band index\n ik is the wave vector index Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: nbands integer(kind=k8), intent(in) :: iband integer(kind=k8), intent(in) :: ik Return Value integer(kind=k8) Called by proc~~mux_state~~CalledByGraph proc~mux_state mux_state proc~calculate_3ph_interaction calculate_3ph_interaction proc~calculate_3ph_interaction->proc~mux_state proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~calculate_eph_interaction_ibzq->proc~mux_state proc~calculate_echimp_interaction_ibzk calculate_echimp_interaction_ibzk proc~calculate_echimp_interaction_ibzk->proc~mux_state proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk proc~calculate_eph_interaction_ibzk->proc~mux_state program~elphbolt elphbolt program~elphbolt->proc~calculate_3ph_interaction program~elphbolt->proc~calculate_eph_interaction_ibzq program~elphbolt->proc~calculate_echimp_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mux_state.html"},{"title":"Bose – elphbolt","text":"public pure function Bose(e, T) e Energy in eV\n T temperature in K Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: e real(kind=dp), intent(in) :: T Return Value real(kind=dp) Called by proc~~bose~~CalledByGraph proc~bose Bose proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk proc~calculate_eph_interaction_ibzk->proc~bose proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~calculate_eph_interaction_ibzq->proc~bose proc~calculate_spectral_transport_coeff calculate_spectral_transport_coeff proc~calculate_spectral_transport_coeff->proc~bose proc~calculate_3ph_interaction calculate_3ph_interaction proc~calculate_3ph_interaction->proc~bose proc~calculate_transport_coeff calculate_transport_coeff proc~calculate_transport_coeff->proc~bose program~elphbolt elphbolt program~elphbolt->proc~calculate_eph_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzq program~elphbolt->proc~calculate_3ph_interaction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bose.html"},{"title":"Fermi – elphbolt","text":"public pure function Fermi(e, chempot, T) e Energy in eV\n chempot Chemical potential in eV\n T temperature in K Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: e real(kind=dp), intent(in) :: chempot real(kind=dp), intent(in) :: T Return Value real(kind=dp) Called by proc~~fermi~~CalledByGraph proc~fermi Fermi proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk proc~calculate_eph_interaction_ibzk->proc~fermi proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~calculate_eph_interaction_ibzq->proc~fermi proc~calculate_spectral_transport_coeff calculate_spectral_transport_coeff proc~calculate_spectral_transport_coeff->proc~fermi proc~calculate_transport_coeff calculate_transport_coeff proc~calculate_transport_coeff->proc~fermi proc~calculate_qtf calculate_qTF proc~calculate_qtf->proc~fermi program~elphbolt elphbolt program~elphbolt->proc~calculate_eph_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzq program~elphbolt->proc~calculate_qtf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fermi.html"},{"title":"linspace – elphbolt","text":"public subroutine linspace(grid, min, max, num) Create equidistant grid. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), allocatable :: grid (:) real(kind=dp), intent(in) :: min real(kind=dp), intent(in) :: max integer(kind=k8), intent(in) :: num Contents None","tags":"","loc":"proc/linspace.html"},{"title":"exit_with_message – elphbolt","text":"public subroutine exit_with_message(message) Exit with error message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Called by proc~~exit_with_message~~CalledByGraph proc~exit_with_message exit_with_message proc~demux_vector demux_vector proc~demux_vector->proc~exit_with_message proc~mux_vector mux_vector proc~mux_vector->proc~exit_with_message proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk proc~calculate_eph_interaction_ibzk->proc~exit_with_message proc~calculate_eph_interaction_ibzk->proc~mux_vector proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~calculate_eph_interaction_ibzq->proc~exit_with_message proc~calculate_eph_interaction_ibzq->proc~mux_vector proc~calculate_spectral_transport_coeff calculate_spectral_transport_coeff proc~calculate_spectral_transport_coeff->proc~exit_with_message proc~calculate_3ph_interaction calculate_3ph_interaction proc~calculate_3ph_interaction->proc~exit_with_message proc~calculate_3ph_interaction->proc~mux_vector proc~calculate_transport_coeff calculate_transport_coeff proc~calculate_transport_coeff->proc~exit_with_message proc~form_triangles form_triangles proc~form_triangles->proc~demux_vector proc~form_triangles->proc~mux_vector proc~calculate_wavevectors_full calculate_wavevectors_full proc~calculate_wavevectors_full->proc~demux_vector proc~find_equiv_map find_equiv_map proc~find_equiv_map->proc~mux_vector proc~form_tetrahedra_3d form_tetrahedra_3d proc~form_tetrahedra_3d->proc~demux_vector proc~form_tetrahedra_3d->proc~mux_vector program~elphbolt elphbolt program~elphbolt->proc~calculate_eph_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzq program~elphbolt->proc~calculate_3ph_interaction proc~find_irred_wedge find_irred_wedge proc~find_irred_wedge->proc~demux_vector proc~find_irred_wedge->proc~find_equiv_map Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/exit_with_message.html"},{"title":"print_message – elphbolt","text":"public subroutine print_message(message) Print message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Called by proc~~print_message~~CalledByGraph proc~print_message print_message proc~calculate_echimp_interaction_ibzk calculate_echimp_interaction_ibzk proc~calculate_echimp_interaction_ibzk->proc~print_message proc~calculate_gkrp calculate_gkRp proc~calculate_gkrp->proc~print_message proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk proc~calculate_eph_interaction_ibzk->proc~print_message proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~calculate_eph_interaction_ibzq->proc~print_message proc~calculate_3ph_interaction calculate_3ph_interaction proc~calculate_3ph_interaction->proc~print_message proc~calculate_qtf calculate_qTF proc~calculate_qtf->proc~print_message program~elphbolt elphbolt program~elphbolt->proc~print_message program~elphbolt->proc~calculate_echimp_interaction_ibzk program~elphbolt->proc~calculate_gkrp program~elphbolt->proc~calculate_eph_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzq program~elphbolt->proc~calculate_3ph_interaction program~elphbolt->proc~calculate_qtf proc~calculate_greq calculate_gReq program~elphbolt->proc~calculate_greq proc~calculate_greq->proc~print_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print_message.html"},{"title":"write2file_rank2_real – elphbolt","text":"public subroutine write2file_rank2_real(filename, data) Write rank-2 data to file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: data (:,:) Contents None","tags":"","loc":"proc/write2file_rank2_real.html"},{"title":"write2file_rank3_real – elphbolt","text":"public subroutine write2file_rank3_real(filename, data) Write rank-3 data to file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: data (:,:,:) Contents None","tags":"","loc":"proc/write2file_rank3_real.html"},{"title":"write2file_response – elphbolt","text":"public subroutine write2file_response(filename, data, bandlist) Write list of vectors to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: data (:,:,:) integer(kind=k8), intent(in), optional :: bandlist (:) Contents None","tags":"","loc":"proc/write2file_response.html"},{"title":"readfile_response – elphbolt","text":"public subroutine readfile_response(filename, data, bandlist) Read list of vectors to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out) :: data (:,:,:) integer(kind=k8), intent(in), optional :: bandlist (:) Contents None","tags":"","loc":"proc/readfile_response.html"},{"title":"append2file_transport_tensor – elphbolt","text":"public subroutine append2file_transport_tensor(filename, it, data, bandlist) Append 3x3 tensor to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=k8), intent(in) :: it real(kind=dp), intent(in) :: data (:,:,:) integer(kind=k8), intent(in), optional :: bandlist (:) Contents None","tags":"","loc":"proc/append2file_transport_tensor.html"},{"title":"write2file_spectral_tensor – elphbolt","text":"public subroutine write2file_spectral_tensor(filename, data, bandlist) Append 3x3 spectral transport tensor to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: data (:,:,:,:) integer(kind=k8), intent(in), optional :: bandlist (:) Contents None","tags":"","loc":"proc/write2file_spectral_tensor.html"},{"title":"int_div – elphbolt","text":"public subroutine int_div(num, denom, q, r) Quotient(q) and remainder(r) of the integer division num/denom. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: num integer(kind=k8), intent(in) :: denom integer(kind=k8), intent(out) :: q integer(kind=k8), intent(out) :: r Contents None","tags":"","loc":"proc/int_div.html"},{"title":"distribute_points – elphbolt","text":"public subroutine distribute_points(npts, chunk, istart, iend, num_active_images) Distribute points among processes Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: npts integer(kind=k8), intent(out) :: chunk integer(kind=k8), intent(out) :: istart integer(kind=k8), intent(out) :: iend integer(kind=k8), intent(out) :: num_active_images Called by proc~~distribute_points~~CalledByGraph proc~distribute_points distribute_points proc~calculate_el_rta_rates calculate_el_rta_rates proc~calculate_el_rta_rates->proc~distribute_points proc~calculate_echimp_interaction_ibzk calculate_echimp_interaction_ibzk proc~calculate_echimp_interaction_ibzk->proc~distribute_points proc~calculate_ph_rta_rates calculate_ph_rta_rates proc~calculate_ph_rta_rates->proc~distribute_points proc~calculate_gkrp calculate_gkRp proc~calculate_gkrp->proc~distribute_points proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk proc~calculate_eph_interaction_ibzk->proc~distribute_points proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~calculate_eph_interaction_ibzq->proc~distribute_points proc~find_equiv_map find_equiv_map proc~find_equiv_map->proc~distribute_points proc~calculate_3ph_interaction calculate_3ph_interaction proc~calculate_3ph_interaction->proc~distribute_points proc~find_irred_wedge find_irred_wedge proc~find_irred_wedge->proc~distribute_points proc~find_irred_wedge->proc~find_equiv_map proc~calculate_greq calculate_gReq proc~calculate_greq->proc~distribute_points program~elphbolt elphbolt program~elphbolt->proc~calculate_echimp_interaction_ibzk program~elphbolt->proc~calculate_gkrp program~elphbolt->proc~calculate_eph_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzq program~elphbolt->proc~calculate_3ph_interaction program~elphbolt->proc~calculate_greq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/distribute_points.html"},{"title":"binsearch – elphbolt","text":"public subroutine binsearch(array, e, m) Binary search in a list of integers and return index. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: array (:) integer(kind=k8), intent(in) :: e integer(kind=k8), intent(out) :: m Called by proc~~binsearch~~CalledByGraph proc~binsearch binsearch proc~form_triangles form_triangles proc~form_triangles->proc~binsearch proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~calculate_eph_interaction_ibzq->proc~binsearch proc~form_tetrahedra_3d form_tetrahedra_3d proc~form_tetrahedra_3d->proc~binsearch program~elphbolt elphbolt program~elphbolt->proc~calculate_eph_interaction_ibzq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/binsearch.html"},{"title":"demux_vector – elphbolt","text":"public subroutine demux_vector(i, v, mesh, base) Demultiplex index of a single wave vector.\n i is the multiplexed index of a wave vector (always 1-based).\n v is the demultiplexed triplet of a wave vector.\n mesh is the number of wave vectors along the three reciprocal lattice vectors.\n base chooses whether v has 0- or 1-based indexing. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: i integer(kind=k8), intent(out) :: v (3) integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(in) :: base Calls proc~~demux_vector~~CallsGraph proc~demux_vector demux_vector proc~exit_with_message exit_with_message proc~demux_vector->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~demux_vector~~CalledByGraph proc~demux_vector demux_vector proc~calculate_wavevectors_full calculate_wavevectors_full proc~calculate_wavevectors_full->proc~demux_vector proc~form_triangles form_triangles proc~form_triangles->proc~demux_vector proc~form_tetrahedra_3d form_tetrahedra_3d proc~form_tetrahedra_3d->proc~demux_vector proc~find_irred_wedge find_irred_wedge proc~find_irred_wedge->proc~demux_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/demux_vector.html"},{"title":"demux_mesh – elphbolt","text":"public subroutine demux_mesh(index_mesh, nmesh, mesh, base, indexlist) Demultiplex all wave vector indices \n (optionally, from a list of indices).\n Internally uses demux_vector. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(out) :: index_mesh (3,nmesh) integer(kind=k8), intent(in) :: nmesh integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(in) :: base integer(kind=k8), intent(in), optional :: indexlist (nmesh) Called by proc~~demux_mesh~~CalledByGraph proc~demux_mesh demux_mesh proc~find_equiv_map find_equiv_map proc~find_equiv_map->proc~demux_mesh proc~find_irred_wedge find_irred_wedge proc~find_irred_wedge->proc~find_equiv_map Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/demux_mesh.html"},{"title":"demux_state – elphbolt","text":"public subroutine demux_state(m, nbands, iband, ik) Demultiplex a state index into (band index, wave vector index) pair m is the multiplexed state index\n nbands is the number of bands\n iband is the band index\n ik is the wave vector index Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: m integer(kind=k8), intent(in) :: nbands integer(kind=k8), intent(out) :: iband integer(kind=k8), intent(out) :: ik Called by proc~~demux_state~~CalledByGraph proc~demux_state demux_state proc~calculate_el_rta_rates calculate_el_rta_rates proc~calculate_el_rta_rates->proc~demux_state proc~calculate_echimp_interaction_ibzk calculate_echimp_interaction_ibzk proc~calculate_echimp_interaction_ibzk->proc~demux_state proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk proc~calculate_eph_interaction_ibzk->proc~demux_state proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq proc~calculate_eph_interaction_ibzq->proc~demux_state proc~calculate_3ph_interaction calculate_3ph_interaction proc~calculate_3ph_interaction->proc~demux_state proc~calculate_ph_rta_rates calculate_ph_rta_rates proc~calculate_ph_rta_rates->proc~demux_state program~elphbolt elphbolt program~elphbolt->proc~calculate_echimp_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzq program~elphbolt->proc~calculate_3ph_interaction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/demux_state.html"},{"title":"interpolate – elphbolt","text":"public subroutine interpolate(coarsemesh, refinement, f, q, interpolation) Subroutine to perform BZ interpolation. coarsemesh The coarse mesh.\n refinement The mesh refinement factor.\n f The coarse mesh function to be interpolated.\n q The 0-based index vector where to evaluate f.\n interpolation The result Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: coarsemesh (3) integer(kind=k8), intent(in) :: refinement (3) real(kind=dp), intent(in) :: f (:) integer(kind=k8), intent(in) :: q (3) real(kind=dp), intent(out) :: interpolation Calls proc~~interpolate~~CallsGraph proc~interpolate interpolate dgesv dgesv proc~interpolate->dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpolate.html"},{"title":"welcome – elphbolt","text":"public subroutine welcome() Subroutine to print a pretty banner. Arguments None Called by proc~~welcome~~CalledByGraph proc~welcome welcome program~elphbolt elphbolt program~elphbolt->proc~welcome Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/welcome.html"},{"title":"subtitle – elphbolt","text":"public subroutine subtitle(text) Subroutine to print a subtitle. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Called by proc~~subtitle~~CalledByGraph proc~subtitle subtitle program~elphbolt elphbolt program~elphbolt->proc~subtitle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subtitle.html"},{"title":"sort – elphbolt","text":"public interface sort Contents Module Procedures sort_int sort_real Module Procedures private subroutine sort_int(list) Swap sort list of integers Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(inout) :: list (:) private subroutine sort_real(list) Swap sort list of reals Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: list (:)","tags":"","loc":"interface/sort.html"},{"title":"fbz2ibz – elphbolt","text":"public function fbz2ibz(iwvmux, nwv_irred, nequiv, ibz2fbz_map) Find index in IBZ blocks list for a given FBZ blocks muxed vector index Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: iwvmux integer(kind=k8), intent(in) :: nwv_irred integer(kind=k8), intent(in) :: nequiv (nwv_irred) integer(kind=k8), intent(in) :: ibz2fbz_map (:,:,:) Return Value integer(kind=k8) Called by proc~~fbz2ibz~~CalledByGraph proc~fbz2ibz fbz2ibz proc~create_fbz2ibz_map create_fbz2ibz_map proc~create_fbz2ibz_map->proc~fbz2ibz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fbz2ibz.html"},{"title":"find_equiv_map – elphbolt","text":"public subroutine find_equiv_map(nsymm_rot, equiv_map, mesh, qrotations, indexlist) Subroutine to create the map of equivalent wave vectors. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: nsymm_rot integer(kind=k8), intent(out) :: equiv_map (:,:) integer(kind=k8), intent(in) :: mesh (3) real(kind=dp), intent(in) :: qrotations (:,:,:) integer(kind=k8), intent(in), optional :: indexlist (:) Calls proc~~find_equiv_map~~CallsGraph proc~find_equiv_map find_equiv_map proc~demux_mesh demux_mesh proc~find_equiv_map->proc~demux_mesh proc~mux_vector mux_vector proc~find_equiv_map->proc~mux_vector proc~distribute_points distribute_points proc~find_equiv_map->proc~distribute_points proc~exit_with_message exit_with_message proc~mux_vector->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~find_equiv_map~~CalledByGraph proc~find_equiv_map find_equiv_map proc~find_irred_wedge find_irred_wedge proc~find_irred_wedge->proc~find_equiv_map Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_equiv_map.html"},{"title":"find_irred_wedge – elphbolt","text":"public subroutine find_irred_wedge(mesh, nwavevecs_irred, wavevecs_irred, indexlist_irred, nequivalent, nsymm_rot, qrotations, ibz2fbz_map, equivalence_map, blocks, indexlist) Find the irreducible wedge of the FBZ and other quantities.\n Wedge finding algorithm is inspired by ShengBTE. mesh is the array of number of points along the reciprocal lattice vectors\n nwavevecs_irred is the number of irreducible vectors\n wavevecs_irred are the irreducible vectors\n indexlist_irred is the list containing the muxed indices of the irreducible wave vectors\n nequivalent lists the number of equivalent points of each irreducible point\n ibz2fbz_map contains the map from an irreducible BZ (IBZ) vector to its FBZ images\n   The third axis contains the pair (symmetry index, image)\n equivalence_map is a map of the equivalent points under rotations\n blocks chooses whether the FBZ is energy restricted or not\n indexlist is the sorted list of indices of the wavevectors\n   in the energy restricted FBZ which must be present if blocks is true Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(out) :: nwavevecs_irred real(kind=dp), intent(out), allocatable :: wavevecs_irred (:,:) integer(kind=k8), intent(out), allocatable :: indexlist_irred (:) integer(kind=k8), intent(out), allocatable :: nequivalent (:) integer(kind=k8), intent(in) :: nsymm_rot real(kind=dp), intent(in) :: qrotations (:,:,:) integer(kind=k8), intent(out), allocatable :: ibz2fbz_map (:,:,:) integer(kind=k8), intent(out), allocatable :: equivalence_map (:,:) logical, intent(in) :: blocks integer(kind=k8), intent(in), optional :: indexlist (:) Calls proc~~find_irred_wedge~~CallsGraph proc~find_irred_wedge find_irred_wedge proc~demux_vector demux_vector proc~find_irred_wedge->proc~demux_vector proc~find_equiv_map find_equiv_map proc~find_irred_wedge->proc~find_equiv_map proc~distribute_points distribute_points proc~find_irred_wedge->proc~distribute_points proc~exit_with_message exit_with_message proc~demux_vector->proc~exit_with_message proc~find_equiv_map->proc~distribute_points proc~demux_mesh demux_mesh proc~find_equiv_map->proc~demux_mesh proc~mux_vector mux_vector proc~find_equiv_map->proc~mux_vector proc~mux_vector->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_irred_wedge.html"},{"title":"create_fbz2ibz_map – elphbolt","text":"public subroutine create_fbz2ibz_map(fbz2ibz_map, nwv, nwv_irred, indexlist, nequiv, ibz2fbz_map) Subroutine to create map of FBZ blocks to IBZ blocks Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(out), allocatable :: fbz2ibz_map (:) integer(kind=k8), intent(in) :: nwv integer(kind=k8), intent(in) :: nwv_irred integer(kind=k8), intent(in) :: indexlist (nwv) integer(kind=k8), intent(in) :: nequiv (nwv_irred) integer(kind=k8), intent(in) :: ibz2fbz_map (:,:,:) Calls proc~~create_fbz2ibz_map~~CallsGraph proc~create_fbz2ibz_map create_fbz2ibz_map proc~fbz2ibz fbz2ibz proc~create_fbz2ibz_map->proc~fbz2ibz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/create_fbz2ibz_map.html"},{"title":"symmetrize_3x3_tensor – elphbolt","text":"public subroutine symmetrize_3x3_tensor(tensor, crotations) Symmetrize a 3x3 tensor. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: tensor (3,3) real(kind=dp), intent(in) :: crotations (:,:,:) Contents None","tags":"","loc":"proc/symmetrize_3x3_tensor.html"},{"title":"get_num_operations – elphbolt","text":"public function get_num_operations(lattice, natoms, types, positions) Return the number of symmetry operations. Useful for allocating\n memory for get_operations(). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3,3) :: lattice integer(kind=k8), intent(in) :: natoms integer(kind=k8), intent(in), dimension(natoms) :: types real(kind=dp), intent(in), dimension(3,natoms) :: positions Return Value integer(kind=k8) Calls proc~~get_num_operations~~CallsGraph proc~get_num_operations get_num_operations interface~spg_get_multiplicity spg_get_multiplicity proc~get_num_operations->interface~spg_get_multiplicity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_num_operations.html"},{"title":"get_operations – elphbolt","text":"public subroutine get_operations(lattice, natoms, types, positions, nops, rotations, translations, international) Return the matrix and vector representations of the symmetry\n operations of the system. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3,3) :: lattice integer(kind=k8), intent(in) :: natoms integer(kind=k8), intent(in), dimension(natoms) :: types real(kind=dp), intent(in), dimension(3,natoms) :: positions integer(kind=k8), intent(inout) :: nops integer(kind=k8), intent(out), dimension(3,3,nops) :: rotations real(kind=dp), intent(out), dimension(3,nops) :: translations character(len=10), intent(out) :: international Calls proc~~get_operations~~CallsGraph proc~get_operations get_operations interface~spg_get_symmetry spg_get_symmetry proc~get_operations->interface~spg_get_symmetry interface~spg_get_international spg_get_international proc~get_operations->interface~spg_get_international Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_operations.html"},{"title":"get_cartesian_operations – elphbolt","text":"public subroutine get_cartesian_operations(lattice, nops, rotations, translations, crotations, ctranslations) Return the Cartesian components of the rotations and translations\n returned by get_operations(). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3,3) :: lattice integer(kind=k8), intent(in) :: nops integer(kind=k8), intent(in), dimension(3,3,nops) :: rotations real(kind=dp), intent(in), dimension(3,nops) :: translations real(kind=dp), intent(out), dimension(3,3,nops) :: crotations real(kind=dp), intent(out), dimension(3,nops) :: ctranslations Calls proc~~get_cartesian_operations~~CallsGraph proc~get_cartesian_operations get_cartesian_operations dgesv dgesv proc~get_cartesian_operations->dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_cartesian_operations.html"},{"title":"spg_get_symmetry – elphbolt","text":"interface Called by interface~~spg_get_symmetry~~CalledByGraph interface~spg_get_symmetry spg_get_symmetry proc~get_operations get_operations proc~get_operations->interface~spg_get_symmetry Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function spg_get_symmetry(rotations, translations, nops, lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_symmetry\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), dimension(3,3,nops) :: rotations real(kind=C_DOUBLE), dimension(3,nops) :: translations integer(kind=C_INT), value :: nops real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT)","tags":"","loc":"interface/spg_get_symmetry.html"},{"title":"spg_get_international – elphbolt","text":"interface Called by interface~~spg_get_international~~CalledByGraph interface~spg_get_international spg_get_international proc~get_operations get_operations proc~get_operations->interface~spg_get_international Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function spg_get_international(symbol, lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_international\") Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), dimension(11) :: symbol real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT)","tags":"","loc":"interface/spg_get_international.html"},{"title":"spg_get_multiplicity – elphbolt","text":"interface Called by interface~~spg_get_multiplicity~~CalledByGraph interface~spg_get_multiplicity spg_get_multiplicity proc~get_num_operations get_num_operations proc~get_num_operations->interface~spg_get_multiplicity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function spg_get_multiplicity(lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_multiplicity\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT)","tags":"","loc":"interface/spg_get_multiplicity.html"},{"title":"calculate_wavevectors_full – elphbolt","text":"public subroutine calculate_wavevectors_full(mesh, wavevecs, blocks, indexlist) Calculate wave vectors (crystal coords.) of the full Brillouin zone (FBZ) mesh is the array of number of points along the reciprocal lattice vectors\n wavevecs is the list of all the wave vectors Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: mesh (3) real(kind=dp), intent(out), allocatable :: wavevecs (:,:) logical, intent(in) :: blocks integer(kind=k8), intent(in), optional :: indexlist (:) Calls proc~~calculate_wavevectors_full~~CallsGraph proc~calculate_wavevectors_full calculate_wavevectors_full proc~demux_vector demux_vector proc~calculate_wavevectors_full->proc~demux_vector proc~exit_with_message exit_with_message proc~demux_vector->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_wavevectors_full.html"},{"title":"params – elphbolt","text":"Module containing various parameters and constants. Used by module~~params~~UsedByGraph module~params params module~phonon_module phonon_module module~phonon_module->module~params module~crystal_module crystal_module module~phonon_module->module~crystal_module module~misc misc module~phonon_module->module~misc module~numerics_module numerics_module module~phonon_module->module~numerics_module module~wannier_module wannier_module module~phonon_module->module~wannier_module module~symmetry_module symmetry_module module~phonon_module->module~symmetry_module module~delta delta module~phonon_module->module~delta module~crystal_module->module~params module~crystal_module->module~misc module~misc->module~params module~numerics_module->module~params module~numerics_module->module~crystal_module module~numerics_module->module~misc module~wannier_module->module~params module~wannier_module->module~crystal_module module~wannier_module->module~misc module~wannier_module->module~numerics_module module~interactions interactions module~interactions->module~params module~interactions->module~phonon_module module~interactions->module~crystal_module module~interactions->module~misc module~interactions->module~numerics_module module~interactions->module~wannier_module module~electron_module electron_module module~interactions->module~electron_module module~interactions->module~delta module~electron_module->module~params module~electron_module->module~crystal_module module~electron_module->module~misc module~electron_module->module~numerics_module module~electron_module->module~wannier_module module~electron_module->module~symmetry_module module~electron_module->module~delta module~bte_module bte_module module~bte_module->module~params module~bte_module->module~phonon_module module~bte_module->module~crystal_module module~bte_module->module~misc module~bte_module->module~numerics_module module~bte_module->module~interactions module~bte_module->module~electron_module module~bte_module->module~symmetry_module module~bz_sums bz_sums module~bte_module->module~bz_sums module~symmetry_module->module~params module~symmetry_module->module~crystal_module module~symmetry_module->module~misc module~spglib_wrapper spglib_wrapper module~symmetry_module->module~spglib_wrapper module~bz_sums->module~params module~bz_sums->module~phonon_module module~bz_sums->module~crystal_module module~bz_sums->module~misc module~bz_sums->module~electron_module module~bz_sums->module~symmetry_module module~bz_sums->module~delta program~elphbolt elphbolt program~elphbolt->module~params program~elphbolt->module~phonon_module program~elphbolt->module~crystal_module program~elphbolt->module~misc program~elphbolt->module~numerics_module program~elphbolt->module~wannier_module program~elphbolt->module~interactions program~elphbolt->module~electron_module program~elphbolt->module~bte_module program~elphbolt->module~symmetry_module program~elphbolt->module~bz_sums module~spglib_wrapper->module~params module~delta->module~params module~delta->module~misc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables r_int r_real p_real dp k8 qe me amu hbar hbar_eVps perm0 kB pi twopi Hartree2radTHz Hartree2eV Ryd2radTHz Ryd2eV Ryd2meV Ryd2amu bohr2nm oneI twopiI periodic_table Variables Type Visibility Attributes Name Initial integer, public, parameter :: r_int = 12 Exponent range for reals. integer, public, parameter :: r_real = 200 Exponent range for reals. integer, public, parameter :: p_real = 14 Number of digits for reals. integer, public, parameter :: dp = selected_real_kind(p_real, r_real) Custom real precision. integer, public, parameter :: k8 = selected_int_kind(r_int) Custom integer precision. real(kind=dp), public, parameter :: qe = 1.602176634e-19_dp Electron charge magnitude (C) real(kind=dp), public, parameter :: me = 9.1093837015e-31_dp Electron mass (Kg) real(kind=dp), public, parameter :: amu = 1.66053906660e-27_dp Atomic mass unit (Kg) real(kind=dp), public, parameter :: hbar = 1.05457172647e-22_dp Reduced Planck's constant (J/THz = J.ps) real(kind=dp), public, parameter :: hbar_eVps = hbar/qe Reduced Planck's constant (eV/THz = eV.ps) real(kind=dp), public, parameter :: perm0 = 8.854187817e-12_dp Permittivity of free space (F/m) real(kind=dp), public, parameter :: kB = 1.380649e-23_dp/qe Boltzmann constant (eV/K) real(kind=dp), public, parameter :: pi = 4.0_dp*atan(1.0_dp) Value of pi real(kind=dp), public, parameter :: twopi = 2.0_dp*pi Value of 2pi real(kind=dp), public, parameter :: Hartree2radTHz = 27.2116_dp*qe/hbar real(kind=dp), public, parameter :: Hartree2eV = 27.2116_dp real(kind=dp), public, parameter :: Ryd2radTHz = 0.5_dp*Hartree2radTHz real(kind=dp), public, parameter :: Ryd2eV = 0.5_dp*Hartree2eV real(kind=dp), public, parameter :: Ryd2meV = Ryd2eV*1.0e3_dp real(kind=dp), public, parameter :: Ryd2amu = 2.0_dp*me/amu real(kind=dp), public, parameter :: bohr2nm = 0.052917721092_dp complex(kind=dp), public, parameter :: oneI = (0.0_dp, 1.0_dp) complex(kind=dp), public, parameter :: twopiI = twopi*oneI character(len=3), public, parameter :: periodic_table (114) = [character(len=3)::\"H\", \"He\", \"Li\", \"Be\", \"B\", \"C\", \"N\", \"O\", \"F\", \"Ne\", \"Na\", \"Mg\", \"Al\", \"Si\", \"P\", \"S\", \"Cl\", \"Ar\", \"K\", \"Ca\", \"Sc\", \"Ti\", \"V\", \"Cr\", \"Mn\", \"Fe\", \"Co\", \"Ni\", \"Cu\", \"Zn\", \"Ga\", \"Ge\", \"As\", \"Se\", \"Br\", \"Kr\", \"Rb\", \"Sr\", \"Y\", \"Zr\", \"Nb\", \"Mo\", \"Tc\", \"Ru\", \"Rh\", \"Pd\", \"Ag\", \"Cd\", \"In\", \"Sn\", \"Sb\", \"Te\", \"I\", \"Xe\", \"Cs\", \"Ba\", \"La\", \"Ce\", \"Pr\", \"Nd\", \"Pm\", \"Sm\", \"Eu\", \"Gd\", \"Tb\", \"Dy\", \"Ho\", \"Er\", \"Tm\", \"Yb\", \"Lu\", \"Hf\", \"Ta\", \"W\", \"Re\", \"Os\", \"Ir\", \"Pt\", \"Au\", \"Hg\", \"Tl\", \"Pb\", \"Bi\", \"Po\", \"At\", \"Rn\", \"Fr\", \"Ra\", \"Ac\", \"Th\", \"Pa\", \"U\", \"Np\", \"Pu\", \"Am\", \"Cm\", \"Bk\", \"Cf\", \"Es\", \"Fm\", \"Md\", \"No\", \"Lr\", \"Rf\", \"Db\", \"Sg\", \"Bh\", \"Hs\", \"Mt\", \"Ds\", \"Rg\", \"Cn\", \"Uuq\", \"Uuh\"]","tags":"","loc":"module/params.html"},{"title":"bte_module – elphbolt","text":"Module containing type and procedures related to the solution of the\n Boltzmann transport equation (BTE). Uses params misc numerics_module crystal_module symmetry_module phonon_module electron_module interactions bz_sums module~~bte_module~~UsesGraph module~bte_module bte_module module~phonon_module phonon_module module~bte_module->module~phonon_module module~crystal_module crystal_module module~bte_module->module~crystal_module module~misc misc module~bte_module->module~misc module~numerics_module numerics_module module~bte_module->module~numerics_module module~interactions interactions module~bte_module->module~interactions module~electron_module electron_module module~bte_module->module~electron_module module~symmetry_module symmetry_module module~bte_module->module~symmetry_module module~params params module~bte_module->module~params module~bz_sums bz_sums module~bte_module->module~bz_sums module~phonon_module->module~crystal_module module~phonon_module->module~misc module~phonon_module->module~numerics_module module~phonon_module->module~symmetry_module module~phonon_module->module~params module~wannier_module wannier_module module~phonon_module->module~wannier_module module~delta delta module~phonon_module->module~delta module~crystal_module->module~misc module~crystal_module->module~params module~misc->module~params module~numerics_module->module~crystal_module module~numerics_module->module~misc module~numerics_module->module~params module~interactions->module~phonon_module module~interactions->module~crystal_module module~interactions->module~misc module~interactions->module~numerics_module module~interactions->module~electron_module module~interactions->module~params module~interactions->module~wannier_module module~interactions->module~delta module~electron_module->module~crystal_module module~electron_module->module~misc module~electron_module->module~numerics_module module~electron_module->module~symmetry_module module~electron_module->module~params module~electron_module->module~wannier_module module~electron_module->module~delta module~symmetry_module->module~crystal_module module~symmetry_module->module~misc module~symmetry_module->module~params module~spglib_wrapper spglib_wrapper module~symmetry_module->module~spglib_wrapper module~bz_sums->module~phonon_module module~bz_sums->module~crystal_module module~bz_sums->module~misc module~bz_sums->module~electron_module module~bz_sums->module~symmetry_module module~bz_sums->module~params module~bz_sums->module~delta module~wannier_module->module~crystal_module module~wannier_module->module~misc module~wannier_module->module~numerics_module module~wannier_module->module~params module~delta->module~misc module~delta->module~params module~spglib_wrapper->module~params iso_c_binding iso_c_binding module~spglib_wrapper->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~bte_module~~UsedByGraph module~bte_module bte_module program~elphbolt elphbolt program~elphbolt->module~bte_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types bte Derived Types type, public :: bte Data and procedures related to the BTE. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: ph_rta_rates_iso_ibz (:,:) Phonon RTA scattering rates on the IBZ due to isotope scattering. real(kind=dp), public, allocatable :: ph_rta_rates_subs_ibz (:,:) Phonon RTA scattering rates on the IBZ due to substitution scattering. real(kind=dp), public, allocatable :: ph_rta_rates_ibz (:,:) Phonon RTA scattering rates on the IBZ. real(kind=dp), public, allocatable :: ph_field_term_T (:,:,:) Phonon field coupling term for gradT field on the FBZ. real(kind=dp), public, allocatable :: ph_response_T (:,:,:) Phonon response function for gradT field on the FBZ. real(kind=dp), public, allocatable :: ph_field_term_E (:,:,:) Phonon field coupling term for E field on the FBZ. real(kind=dp), public, allocatable :: ph_response_E (:,:,:) Phonon response function for E field on the FBZ. real(kind=dp), public, allocatable :: el_rta_rates_echimp_ibz (:,:) Electron RTA scattering rates on the IBZ due to charged impurity scattering. real(kind=dp), public, allocatable :: el_rta_rates_ibz (:,:) Electron RTA scattering rates on the IBZ. real(kind=dp), public, allocatable :: el_field_term_T (:,:,:) Electron field coupling term for gradT field on the FBZ. real(kind=dp), public, allocatable :: el_response_T (:,:,:) Electron response function for gradT field on the FBZ. real(kind=dp), public, allocatable :: el_field_term_E (:,:,:) Electron field coupling term for E field on the FBZ. real(kind=dp), public, allocatable :: el_response_E (:,:,:) Electron response function for E field on the FBZ. Type-Bound Procedures procedure, public :: post_process procedure, public :: solve_bte","tags":"","loc":"module/bte_module.html"},{"title":"delta – elphbolt","text":"Module containing the procedures related to delta function evaulation. Uses params misc module~~delta~~UsesGraph module~delta delta module~misc misc module~delta->module~misc module~params params module~delta->module~params module~misc->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~delta~~UsedByGraph module~delta delta module~electron_module electron_module module~electron_module->module~delta module~bz_sums bz_sums module~bz_sums->module~delta module~bz_sums->module~electron_module module~phonon_module phonon_module module~bz_sums->module~phonon_module module~phonon_module->module~delta module~interactions interactions module~interactions->module~delta module~interactions->module~electron_module module~interactions->module~phonon_module module~bte_module bte_module module~bte_module->module~electron_module module~bte_module->module~bz_sums module~bte_module->module~phonon_module module~bte_module->module~interactions program~elphbolt elphbolt program~elphbolt->module~electron_module program~elphbolt->module~bz_sums program~elphbolt->module~phonon_module program~elphbolt->module~interactions program~elphbolt->module~bte_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions delta_fn_tetra delta_fn_triang Subroutines form_tetrahedra_3d fill_tetrahedra_3d form_triangles fill_triangles Functions public pure function delta_fn_tetra (e, ik, ib, mesh, tetramap, tetracount, tetra_evals) Calculate delta function using the tetraheron method. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: e integer(kind=k8), intent(in) :: ik integer(kind=k8), intent(in) :: ib integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(in) :: tetramap (:,:,:) integer(kind=k8), intent(in) :: tetracount (:) real(kind=dp), intent(in) :: tetra_evals (:,:,:) Return Value real(kind=dp) public pure function delta_fn_triang (e, ik, ib, mesh, triangmap, triangcount, triang_evals) Calculate delta function using the triangle method a la\n Kurganskii et al. Phys. Stat. Sol.(b) 129, 293 (1985) Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: e integer(kind=k8), intent(in) :: ik integer(kind=k8), intent(in) :: ib integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(in) :: triangmap (:,:,:) integer(kind=k8), intent(in) :: triangcount (:) real(kind=dp), intent(in) :: triang_evals (:,:,:) Return Value real(kind=dp) Subroutines public subroutine form_tetrahedra_3d (nk, mesh, tetra, tetracount, tetramap, blocks, indexlist) Form all the tetrahedra of a 3d FBZ mesh. Read more… Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: nk integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(out), allocatable :: tetra (:,:) integer(kind=k8), intent(out), allocatable :: tetracount (:) integer(kind=k8), intent(out), allocatable :: tetramap (:,:,:) logical, intent(in) :: blocks integer(kind=k8), intent(in), optional :: indexlist (:) public subroutine fill_tetrahedra_3d (tetra, evals, tetra_evals) Populate the (sorted along the vertices) eigenvalues on all the vertices of the tetrahedra Read more… Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: tetra (:,:) real(kind=dp), intent(in) :: evals (:,:) real(kind=dp), intent(out), allocatable :: tetra_evals (:,:,:) public subroutine form_triangles (nk, mesh, triang, triangcount, triangmap, blocks, indexlist) Form all the triangles of a 3d FBZ mesh for each z component. Read more… Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: nk integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(out), allocatable :: triang (:,:) integer(kind=k8), intent(out), allocatable :: triangcount (:) integer(kind=k8), intent(out), allocatable :: triangmap (:,:,:) logical, intent(in) :: blocks integer(kind=k8), intent(in), optional :: indexlist (:) public subroutine fill_triangles (triang, evals, triang_evals) Populate the (sorted along the vertices) eigenvalues on all the vertices of the triangles Read more… Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: triang (:,:) real(kind=dp), intent(in) :: evals (:,:) real(kind=dp), intent(out), allocatable :: triang_evals (:,:,:)","tags":"","loc":"module/delta.html"},{"title":"phonon_module – elphbolt","text":"Module containing type and procedures related to the phononic properties. Uses params misc numerics_module wannier_module crystal_module symmetry_module delta module~~phonon_module~~UsesGraph module~phonon_module phonon_module module~crystal_module crystal_module module~phonon_module->module~crystal_module module~misc misc module~phonon_module->module~misc module~numerics_module numerics_module module~phonon_module->module~numerics_module module~wannier_module wannier_module module~phonon_module->module~wannier_module module~symmetry_module symmetry_module module~phonon_module->module~symmetry_module module~params params module~phonon_module->module~params module~delta delta module~phonon_module->module~delta module~crystal_module->module~misc module~crystal_module->module~params module~misc->module~params module~numerics_module->module~crystal_module module~numerics_module->module~misc module~numerics_module->module~params module~wannier_module->module~crystal_module module~wannier_module->module~misc module~wannier_module->module~numerics_module module~wannier_module->module~params module~symmetry_module->module~crystal_module module~symmetry_module->module~misc module~symmetry_module->module~params module~spglib_wrapper spglib_wrapper module~symmetry_module->module~spglib_wrapper module~delta->module~misc module~delta->module~params module~spglib_wrapper->module~params iso_c_binding iso_c_binding module~spglib_wrapper->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~phonon_module~~UsedByGraph module~phonon_module phonon_module module~bte_module bte_module module~bte_module->module~phonon_module module~bz_sums bz_sums module~bte_module->module~bz_sums module~interactions interactions module~bte_module->module~interactions program~elphbolt elphbolt program~elphbolt->module~phonon_module program~elphbolt->module~bte_module program~elphbolt->module~bz_sums program~elphbolt->module~interactions module~bz_sums->module~phonon_module module~interactions->module~phonon_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types phonon Subroutines phonon_espresso Derived Types type, public :: phonon Data and procedures related to phonons. Components Type Visibility Attributes Name Initial character(len=2), public :: prefix = 'ph' Prefix idenitfying particle type. integer(kind=k8), public :: numbranches Total number of phonon branches. integer(kind=k8), public :: nq Number of phonon wave vectors in the full Brillouin zone (FBZ). integer(kind=k8), public :: nq_irred Number of phonon wave vectors in the irreducible wedge of Brillouin zone (IBZ). integer(kind=k8), public :: qmesh (3) Phonon wave vector mesh. real(kind=dp), public, allocatable :: wavevecs (:,:) List of all phonon wave vectors (crystal coordinates). real(kind=dp), public, allocatable :: wavevecs_irred (:,:) List of irreducible phonon wave vectors (crystal coordinates). integer(kind=k8), public, allocatable :: indexlist_irred (:) List of muxed indices of the IBZ wedge. integer(kind=k8), public, allocatable :: nequiv (:) List of the number of equivalent points for each IBZ point. integer(kind=k8), public, allocatable :: ibz2fbz_map (:,:,:) Map from an IBZ phonon point to its images.\n The third axis contains the pair (symmetry index, image). integer(kind=k8), public, allocatable :: equiv_map (:,:) Map of equivalent points under rotations.\n Axis 1 runs over rotations.\n Axis 2 runs over wave vectors (full Brillouin zone). real(kind=dp), public, allocatable :: symmetrizers (:,:,:) Symmetrizers of wave vector dependent vectors. integer(kind=k8), public, allocatable :: tetra (:,:) List of all the wave vector mesh tetrahedra vertices.\n First axis lists tetraheda and the second axis lists the vertices. integer(kind=k8), public, allocatable :: tetracount (:) The number of tetrahedra in which a wave vector belongs. integer(kind=k8), public, allocatable :: tetramap (:,:,:) Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real(kind=dp), public, allocatable :: tetra_evals (:,:,:) Tetrahedra vertices filled with eigenvalues. integer(kind=k8), public, allocatable :: triang (:,:) List of all the wave vector mesh triangles vertices.\n First axis lists triangles and the second axis lists the vertices. integer(kind=k8), public, allocatable :: triangcount (:) The number of triangles in which a wave vector belongs. integer(kind=k8), public, allocatable :: triangmap (:,:,:) Mapping from a wave vector to the (triangle, vertex) where it belongs. real(kind=dp), public, allocatable :: triang_evals (:,:,:) Triangles vertices filled with eigenvalues. real(kind=dp), public, allocatable :: ens (:,:) List of phonon energies on FBZ. real(kind=dp), public, allocatable :: vels (:,:,:) List of phonon velocities on IBZ. complex(kind=dp), public, allocatable :: evecs (:,:,:) List of all phonon eigenvectors on IBZ. integer(kind=k8), public :: scell (3) q-mesh used in DFPT or, equivalently, supercell used in finite displencement\n method for calculating the 2nd order force constants. real(kind=dp), public, allocatable :: ifc2 (:,:,:,:,:,:,:) Second order force constants (ifc2) tensor. real(kind=dp), public, allocatable :: ifc3 (:,:,:,:) Third order force constants (ifc3) tensor. integer(kind=k8), public :: numtriplets Number of triplets in the ifc3 file. real(kind=dp), public, allocatable :: R_j (:,:) Position of the 2nd and 3rd atoms in supercell for an ifc3 triplet. real(kind=dp), public, allocatable :: R_k (:,:) Position of the 2nd and 3rd atoms in supercell for an ifc3 triplet. integer(kind=k8), public, allocatable :: Index_i (:) Label of primitive cell atoms in the ifc3 triplet. integer(kind=k8), public, allocatable :: Index_j (:) Label of primitive cell atoms in the ifc3 triplet. integer(kind=k8), public, allocatable :: Index_k (:) Label of primitive cell atoms in the ifc3 triplet. real(kind=dp), public, allocatable :: dos (:,:) Branch resolved density of states. real(kind=dp), public :: rws (124,0:3) real(kind=dp), public :: cell_r (1:3,0:3) real(kind=dp), public :: cell_g (1:3,0:3) real(kind=dp), public, allocatable :: mm (:,:) real(kind=dp), public, allocatable :: rr (:,:,:) Type-Bound Procedures procedure, public :: deallocate_phonon_quantities procedure, public :: initialize Subroutines public subroutine phonon_espresso (ph, crys, nk, kpoints, omegas, eigenvect, velocities) Subroutine to calculate phonons from the 2nd order force constants. Arguments Type Intent Optional Attributes Name type( phonon ), intent(in) :: ph type( crystal ), intent(in) :: crys integer(kind=k8), intent(in) :: nk real(kind=dp), intent(in) :: kpoints (nk,3) real(kind=dp), intent(out) :: omegas (nk,ph%numbranches) complex(kind=8), intent(out), optional :: eigenvect (nk,ph%numbranches,ph%numbranches) real(kind=dp), intent(out), optional :: velocities (nk,ph%numbranches,3)","tags":"","loc":"module/phonon_module.html"},{"title":"bz_sums – elphbolt","text":"Module containing the procedures to do Brillouin zone sums. Uses params misc phonon_module electron_module crystal_module delta symmetry_module module~~bz_sums~~UsesGraph module~bz_sums bz_sums module~phonon_module phonon_module module~bz_sums->module~phonon_module module~crystal_module crystal_module module~bz_sums->module~crystal_module module~misc misc module~bz_sums->module~misc module~electron_module electron_module module~bz_sums->module~electron_module module~symmetry_module symmetry_module module~bz_sums->module~symmetry_module module~params params module~bz_sums->module~params module~delta delta module~bz_sums->module~delta module~phonon_module->module~crystal_module module~phonon_module->module~misc module~phonon_module->module~symmetry_module module~phonon_module->module~params module~phonon_module->module~delta module~numerics_module numerics_module module~phonon_module->module~numerics_module module~wannier_module wannier_module module~phonon_module->module~wannier_module module~crystal_module->module~misc module~crystal_module->module~params module~misc->module~params module~electron_module->module~crystal_module module~electron_module->module~misc module~electron_module->module~symmetry_module module~electron_module->module~params module~electron_module->module~delta module~electron_module->module~numerics_module module~electron_module->module~wannier_module module~symmetry_module->module~crystal_module module~symmetry_module->module~misc module~symmetry_module->module~params module~spglib_wrapper spglib_wrapper module~symmetry_module->module~spglib_wrapper module~delta->module~misc module~delta->module~params module~numerics_module->module~crystal_module module~numerics_module->module~misc module~numerics_module->module~params module~spglib_wrapper->module~params iso_c_binding iso_c_binding module~spglib_wrapper->iso_c_binding module~wannier_module->module~crystal_module module~wannier_module->module~misc module~wannier_module->module~params module~wannier_module->module~numerics_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~bz_sums~~UsedByGraph module~bz_sums bz_sums module~bte_module bte_module module~bte_module->module~bz_sums program~elphbolt elphbolt program~elphbolt->module~bz_sums program~elphbolt->module~bte_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces calculate_dos Subroutines calculate_qTF calculate_transport_coeff calculate_spectral_transport_coeff Interfaces public interface calculate_dos private subroutine calculate_el_dos(el, usetetra) Calculate the density of states (DOS) in units of 1/energy. \n The DOS will be evaluates on the IBZ mesh energies. Read more… Arguments Type Intent Optional Attributes Name type( electron ), intent(inout) :: el logical, intent(in) :: usetetra private subroutine calculate_ph_dos_iso(ph, usetetra, gfactors, subs_gfactors, atomtypes, W_phiso, W_phsubs, phiso, phsubs) Calculate the phonon density of states (DOS) in units of 1/energy and,\n optionally, the phonon-isotope scattering rates. Read more… Arguments Type Intent Optional Attributes Name type( phonon ), intent(inout) :: ph logical, intent(in) :: usetetra real(kind=dp), intent(in) :: gfactors (:) real(kind=dp), intent(in) :: subs_gfactors (:) integer(kind=k8), intent(in) :: atomtypes (:) real(kind=dp), intent(out), allocatable :: W_phiso (:,:) real(kind=dp), intent(out), allocatable :: W_phsubs (:,:) logical, intent(in) :: phiso logical, intent(in) :: phsubs Subroutines public subroutine calculate_qTF (crys, el) Calculate Thomas-Fermi screening wavevector in the simple electron-gas model. Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: crys type( electron ), intent(in) :: el public subroutine calculate_transport_coeff (species_prefix, field, T, deg, chempot, ens, vels, volume, mesh, response, sym, trans_coeff_hc, trans_coeff_cc) Subroutine to calculate transport coefficients. Read more… Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: species_prefix character(len=1), intent(in) :: field real(kind=dp), intent(in) :: T integer(kind=k8), intent(in) :: deg real(kind=dp), intent(in) :: chempot real(kind=dp), intent(in) :: ens (:,:) real(kind=dp), intent(in) :: vels (:,:,:) real(kind=dp), intent(in) :: volume integer(kind=k8), intent(in) :: mesh (3) real(kind=dp), intent(in) :: response (:,:,:) type( symmetry ), intent(in) :: sym real(kind=dp), intent(out) :: trans_coeff_hc (:,:,:) real(kind=dp), intent(out) :: trans_coeff_cc (:,:,:) public subroutine calculate_spectral_transport_coeff (species, field, T, deg, chempot, ens, vels, volume, response, en_grid, usetetra, sym, trans_coeff_hc, trans_coeff_cc) Subroutine to calculate the spectral transport coefficients. Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: species character(len=1), intent(in) :: field real(kind=dp), intent(in) :: T integer(kind=k8), intent(in) :: deg real(kind=dp), intent(in) :: chempot real(kind=dp), intent(in) :: ens (:,:) real(kind=dp), intent(in) :: vels (:,:,:) real(kind=dp), intent(in) :: volume real(kind=dp), intent(in) :: response (:,:,:) real(kind=dp), intent(in) :: en_grid (:) logical, intent(in) :: usetetra type( symmetry ), intent(in) :: sym real(kind=dp), intent(out) :: trans_coeff_hc (:,:,:,:) real(kind=dp), intent(out) :: trans_coeff_cc (:,:,:,:)","tags":"","loc":"module/bz_sums.html"},{"title":"wannier_module – elphbolt","text":"Module containing type and procedures related to Wannierization. Uses params misc numerics_module crystal_module module~~wannier_module~~UsesGraph module~wannier_module wannier_module module~misc misc module~wannier_module->module~misc module~numerics_module numerics_module module~wannier_module->module~numerics_module module~params params module~wannier_module->module~params module~crystal_module crystal_module module~wannier_module->module~crystal_module module~misc->module~params module~numerics_module->module~misc module~numerics_module->module~params module~numerics_module->module~crystal_module module~crystal_module->module~misc module~crystal_module->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~wannier_module~~UsedByGraph module~wannier_module wannier_module module~electron_module electron_module module~electron_module->module~wannier_module program~elphbolt elphbolt program~elphbolt->module~wannier_module program~elphbolt->module~electron_module module~phonon_module phonon_module program~elphbolt->module~phonon_module module~interactions interactions program~elphbolt->module~interactions module~bte_module bte_module program~elphbolt->module~bte_module module~bz_sums bz_sums program~elphbolt->module~bz_sums module~phonon_module->module~wannier_module module~interactions->module~wannier_module module~interactions->module~electron_module module~interactions->module~phonon_module module~bte_module->module~electron_module module~bte_module->module~phonon_module module~bte_module->module~interactions module~bte_module->module~bz_sums module~bz_sums->module~electron_module module~bz_sums->module~phonon_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types epw_wannier Derived Types type, public :: epw_wannier Data and procedures related to Wannierization. Components Type Visibility Attributes Name Initial integer(kind=k8), public :: numwannbands Number of Wannier bands. integer(kind=k8), public :: numbranches Number of phonon branches. integer(kind=k8), public :: nwsk Number of real space cells for electrons. integer(kind=k8), public :: coarse_qmesh (3) Coarse phonon wave vector mesh in Wannier calculation. integer(kind=k8), public :: nwsq Number of real space cells for phonons. integer(kind=k8), public :: nwsg Number of real space cells for electron-phonon vertex. integer(kind=k8), public, allocatable :: rcells_k (:,:) Real space cell locations for electrons. integer(kind=k8), public, allocatable :: rcells_q (:,:) Real space cell locations for phonons. integer(kind=k8), public, allocatable :: rcells_g (:,:) Real space cell locations for electron-phonon vertex. integer(kind=k8), public, allocatable :: elwsdeg (:) Real space cell multiplicity for electrons. integer(kind=k8), public, allocatable :: phwsdeg (:) Real space cell multiplicity for phonons. integer(kind=k8), public, allocatable :: gwsdeg (:) Real space cell multiplicity for electron-phonon vertex. complex(kind=dp), public, allocatable :: Hwann (:,:,:) Hamiltonian in Wannier representation. complex(kind=dp), public, allocatable :: Dphwann (:,:,:) Dynamical matrix in Wannier representation. complex(kind=dp), public, allocatable :: gwann (:,:,:,:,:) e-ph vertex in Wannier representation. Type-Bound Procedures procedure, public :: plot_along_path procedure, public :: deallocate_wannier procedure, public :: g2_epw procedure, public :: gReq_epw procedure, public :: gkRp_epw procedure, public :: ph_wann_epw procedure, public :: el_wann_epw procedure, public :: read => read_EPW_Wannier","tags":"","loc":"module/wannier_module.html"},{"title":"interactions – elphbolt","text":"Module containing the procedures related to the computation of interactions. Uses params misc wannier_module crystal_module electron_module phonon_module numerics_module delta module~~interactions~~UsesGraph module~interactions interactions module~phonon_module phonon_module module~interactions->module~phonon_module module~crystal_module crystal_module module~interactions->module~crystal_module module~misc misc module~interactions->module~misc module~numerics_module numerics_module module~interactions->module~numerics_module module~wannier_module wannier_module module~interactions->module~wannier_module module~electron_module electron_module module~interactions->module~electron_module module~params params module~interactions->module~params module~delta delta module~interactions->module~delta module~phonon_module->module~crystal_module module~phonon_module->module~misc module~phonon_module->module~numerics_module module~phonon_module->module~wannier_module module~phonon_module->module~params module~phonon_module->module~delta module~symmetry_module symmetry_module module~phonon_module->module~symmetry_module module~crystal_module->module~misc module~crystal_module->module~params module~misc->module~params module~numerics_module->module~crystal_module module~numerics_module->module~misc module~numerics_module->module~params module~wannier_module->module~crystal_module module~wannier_module->module~misc module~wannier_module->module~numerics_module module~wannier_module->module~params module~electron_module->module~crystal_module module~electron_module->module~misc module~electron_module->module~numerics_module module~electron_module->module~wannier_module module~electron_module->module~params module~electron_module->module~delta module~electron_module->module~symmetry_module module~delta->module~misc module~delta->module~params module~symmetry_module->module~crystal_module module~symmetry_module->module~misc module~symmetry_module->module~params module~spglib_wrapper spglib_wrapper module~symmetry_module->module~spglib_wrapper module~spglib_wrapper->module~params iso_c_binding iso_c_binding module~spglib_wrapper->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~interactions~~UsedByGraph module~interactions interactions module~bte_module bte_module module~bte_module->module~interactions program~elphbolt elphbolt program~elphbolt->module~interactions program~elphbolt->module~bte_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines calculate_3ph_interaction calculate_gReq calculate_gkRp calculate_eph_interaction_ibzq calculate_eph_interaction_ibzk calculate_echimp_interaction_ibzk calculate_ph_rta_rates calculate_el_rta_rates read_transition_probs_e Subroutines public subroutine calculate_3ph_interaction (ph, crys, num, key) Parallel driver of the 3-ph vertex calculator for all IBZ phonon wave vectors.\n This subroutine calculates |V-(s1 |s2q2,s3q3)|&#94;2, W-(s1 |s2q2,s3q3),\n and W+(s1 |s2q2,s3q3) for each irreducible phonon and saves the results to disk. Read more… Arguments Type Intent Optional Attributes Name type( phonon ), intent(in) :: ph type( crystal ), intent(in) :: crys type( numerics ), intent(in) :: num character(len=1), intent(in) :: key public subroutine calculate_gReq (wann, ph, num) Parallel driver of gReq_epw over IBZ phonon wave vectors. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num public subroutine calculate_gkRp (wann, el, num) Parallel driver of gkRp_epw over IBZ electron wave vectors. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( electron ), intent(in) :: el type( numerics ), intent(in) :: num public subroutine calculate_eph_interaction_ibzq (wann, crys, el, ph, num, key) Parallel driver of g2(q,k) over IBZ phonon states. Read more… Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num character(len=1), intent(in) :: key public subroutine calculate_eph_interaction_ibzk (wann, crys, el, ph, num, key) Parallel driver of g2(k,q) over IBZ electron states. Read more… Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num character(len=1), intent(in) :: key public subroutine calculate_echimp_interaction_ibzk (crys, el, num) Parallel driver of |g_e-chimp(k,k')|&#94;2 over IBZ electron states. Arguments Type Intent Optional Attributes Name type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( numerics ), intent(in) :: num public subroutine calculate_ph_rta_rates (rta_rates_3ph, rta_rates_phe, num, crys, ph, el) Subroutine for parallel reading of the 3-ph and ph-e transition probabilities\n from disk and calculating the relaxation time approximation (RTA)\n scattering rates for the 3-ph and ph-e channels. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), allocatable :: rta_rates_3ph (:,:) real(kind=dp), intent(out), allocatable :: rta_rates_phe (:,:) type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( phonon ), intent(in) :: ph type( electron ), intent(in), optional :: el public subroutine calculate_el_rta_rates (rta_rates_eph, rta_rates_echimp, num, crys, el) Subroutine for parallel reading of the e-ph transition probabilities\n from disk and calculating the relaxation time approximation (RTA)\n scattering rates for the e-ph channel. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), allocatable :: rta_rates_eph (:,:) real(kind=dp), intent(out), allocatable :: rta_rates_echimp (:,:) type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el public subroutine read_transition_probs_e (filepath, N, TP, istate1, istate2) Subroutine to read transition probabilities from disk for interaction processes. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath integer(kind=k8), intent(out) :: N real(kind=dp), intent(out), allocatable :: TP (:) integer(kind=k8), intent(out), optional allocatable :: istate1 (:) integer(kind=k8), intent(out), optional allocatable :: istate2 (:)","tags":"","loc":"module/interactions.html"},{"title":"misc – elphbolt","text":"Module containing miscellaneous math and numerics related functions and subroutines. Uses params module~~misc~~UsesGraph module~misc misc module~params params module~misc->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~misc~~UsedByGraph module~misc misc module~phonon_module phonon_module module~phonon_module->module~misc module~crystal_module crystal_module module~phonon_module->module~crystal_module module~wannier_module wannier_module module~phonon_module->module~wannier_module module~numerics_module numerics_module module~phonon_module->module~numerics_module module~symmetry_module symmetry_module module~phonon_module->module~symmetry_module module~delta delta module~phonon_module->module~delta module~crystal_module->module~misc module~wannier_module->module~misc module~wannier_module->module~crystal_module module~wannier_module->module~numerics_module module~numerics_module->module~misc module~numerics_module->module~crystal_module module~interactions interactions module~interactions->module~misc module~interactions->module~phonon_module module~interactions->module~crystal_module module~interactions->module~wannier_module module~interactions->module~numerics_module module~electron_module electron_module module~interactions->module~electron_module module~interactions->module~delta module~electron_module->module~misc module~electron_module->module~crystal_module module~electron_module->module~wannier_module module~electron_module->module~numerics_module module~electron_module->module~symmetry_module module~electron_module->module~delta module~bte_module bte_module module~bte_module->module~misc module~bte_module->module~phonon_module module~bte_module->module~crystal_module module~bte_module->module~numerics_module module~bte_module->module~interactions module~bte_module->module~electron_module module~bte_module->module~symmetry_module module~bz_sums bz_sums module~bte_module->module~bz_sums module~symmetry_module->module~misc module~symmetry_module->module~crystal_module module~bz_sums->module~misc module~bz_sums->module~phonon_module module~bz_sums->module~crystal_module module~bz_sums->module~electron_module module~bz_sums->module~symmetry_module module~bz_sums->module~delta program~elphbolt elphbolt program~elphbolt->module~misc program~elphbolt->module~phonon_module program~elphbolt->module~crystal_module program~elphbolt->module~wannier_module program~elphbolt->module~numerics_module program~elphbolt->module~interactions program~elphbolt->module~electron_module program~elphbolt->module~bte_module program~elphbolt->module~symmetry_module program~elphbolt->module~bz_sums module~delta->module~misc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces sort Functions cross_product expi twonorm trace mux_vector mux_state Bose Fermi Subroutines linspace exit_with_message print_message write2file_rank2_real write2file_rank3_real write2file_response readfile_response append2file_transport_tensor write2file_spectral_tensor int_div distribute_points binsearch demux_vector demux_mesh demux_state interpolate welcome subtitle Interfaces public interface sort private subroutine sort_int(list) Swap sort list of integers Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(inout) :: list (:) private subroutine sort_real(list) Swap sort list of reals Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: list (:) Functions public function cross_product (A, B) Cross product of A and B. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (3) real(kind=dp), intent(in) :: B (3) Return Value real(kind=dp)\n  (3) public pure function expi (x) Calculate exp(i*x) = cos(x) + isin(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value complex(kind=dp) public pure function twonorm (v) 2-norm of a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) Return Value real(kind=dp) public pure function trace (mat) Trace of square matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) Return Value real(kind=dp) public function mux_vector (v, mesh, base) Multiplex index of a single wave vector.\n v is the demultiplexed triplet of a wave vector.\n i is the multiplexed index of a wave vector (always 1-based).\n mesh is the number of wave vectors along the three reciprocal lattice vectors.\n base states whether v has 0- or 1-based indexing. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: v (3) integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(in) :: base Return Value integer(kind=k8) public pure function mux_state (nbands, iband, ik) Multiplex a (band index, wave vector index) pair into a state index Read more… Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: nbands integer(kind=k8), intent(in) :: iband integer(kind=k8), intent(in) :: ik Return Value integer(kind=k8) public pure function Bose (e, T) e Energy in eV\n T temperature in K Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: e real(kind=dp), intent(in) :: T Return Value real(kind=dp) public pure function Fermi (e, chempot, T) e Energy in eV\n chempot Chemical potential in eV\n T temperature in K Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: e real(kind=dp), intent(in) :: chempot real(kind=dp), intent(in) :: T Return Value real(kind=dp) Subroutines public subroutine linspace (grid, min, max, num) Create equidistant grid. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), allocatable :: grid (:) real(kind=dp), intent(in) :: min real(kind=dp), intent(in) :: max integer(kind=k8), intent(in) :: num public subroutine exit_with_message (message) Exit with error message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message public subroutine print_message (message) Print message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message public subroutine write2file_rank2_real (filename, data) Write rank-2 data to file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: data (:,:) public subroutine write2file_rank3_real (filename, data) Write rank-3 data to file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: data (:,:,:) public subroutine write2file_response (filename, data, bandlist) Write list of vectors to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: data (:,:,:) integer(kind=k8), intent(in), optional :: bandlist (:) public subroutine readfile_response (filename, data, bandlist) Read list of vectors to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out) :: data (:,:,:) integer(kind=k8), intent(in), optional :: bandlist (:) public subroutine append2file_transport_tensor (filename, it, data, bandlist) Append 3x3 tensor to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=k8), intent(in) :: it real(kind=dp), intent(in) :: data (:,:,:) integer(kind=k8), intent(in), optional :: bandlist (:) public subroutine write2file_spectral_tensor (filename, data, bandlist) Append 3x3 spectral transport tensor to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: data (:,:,:,:) integer(kind=k8), intent(in), optional :: bandlist (:) public subroutine int_div (num, denom, q, r) Quotient(q) and remainder(r) of the integer division num/denom. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: num integer(kind=k8), intent(in) :: denom integer(kind=k8), intent(out) :: q integer(kind=k8), intent(out) :: r public subroutine distribute_points (npts, chunk, istart, iend, num_active_images) Distribute points among processes Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: npts integer(kind=k8), intent(out) :: chunk integer(kind=k8), intent(out) :: istart integer(kind=k8), intent(out) :: iend integer(kind=k8), intent(out) :: num_active_images public subroutine binsearch (array, e, m) Binary search in a list of integers and return index. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: array (:) integer(kind=k8), intent(in) :: e integer(kind=k8), intent(out) :: m public subroutine demux_vector (i, v, mesh, base) Demultiplex index of a single wave vector.\n i is the multiplexed index of a wave vector (always 1-based).\n v is the demultiplexed triplet of a wave vector.\n mesh is the number of wave vectors along the three reciprocal lattice vectors.\n base chooses whether v has 0- or 1-based indexing. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: i integer(kind=k8), intent(out) :: v (3) integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(in) :: base public subroutine demux_mesh (index_mesh, nmesh, mesh, base, indexlist) Demultiplex all wave vector indices \n (optionally, from a list of indices).\n Internally uses demux_vector. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(out) :: index_mesh (3,nmesh) integer(kind=k8), intent(in) :: nmesh integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(in) :: base integer(kind=k8), intent(in), optional :: indexlist (nmesh) public subroutine demux_state (m, nbands, iband, ik) Demultiplex a state index into (band index, wave vector index) pair Read more… Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: m integer(kind=k8), intent(in) :: nbands integer(kind=k8), intent(out) :: iband integer(kind=k8), intent(out) :: ik public subroutine interpolate (coarsemesh, refinement, f, q, interpolation) Subroutine to perform BZ interpolation. Read more… Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: coarsemesh (3) integer(kind=k8), intent(in) :: refinement (3) real(kind=dp), intent(in) :: f (:) integer(kind=k8), intent(in) :: q (3) real(kind=dp), intent(out) :: interpolation public subroutine welcome () Subroutine to print a pretty banner. Arguments None public subroutine subtitle (text) Subroutine to print a subtitle. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text","tags":"","loc":"module/misc.html"},{"title":"symmetry_module – elphbolt","text":"Module containing type and procedures related to crystal and\n Brillouin zone symmetries. Uses params misc crystal_module spglib_wrapper module~~symmetry_module~~UsesGraph module~symmetry_module symmetry_module module~misc misc module~symmetry_module->module~misc module~spglib_wrapper spglib_wrapper module~symmetry_module->module~spglib_wrapper module~params params module~symmetry_module->module~params module~crystal_module crystal_module module~symmetry_module->module~crystal_module module~misc->module~params module~spglib_wrapper->module~params iso_c_binding iso_c_binding module~spglib_wrapper->iso_c_binding module~crystal_module->module~misc module~crystal_module->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~symmetry_module~~UsedByGraph module~symmetry_module symmetry_module module~phonon_module phonon_module module~phonon_module->module~symmetry_module module~electron_module electron_module module~electron_module->module~symmetry_module module~bte_module bte_module module~bte_module->module~symmetry_module module~bte_module->module~phonon_module module~bte_module->module~electron_module module~bz_sums bz_sums module~bte_module->module~bz_sums module~interactions interactions module~bte_module->module~interactions module~bz_sums->module~symmetry_module module~bz_sums->module~phonon_module module~bz_sums->module~electron_module program~elphbolt elphbolt program~elphbolt->module~symmetry_module program~elphbolt->module~phonon_module program~elphbolt->module~electron_module program~elphbolt->module~bte_module program~elphbolt->module~bz_sums program~elphbolt->module~interactions module~interactions->module~phonon_module module~interactions->module~electron_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types symmetry Functions fbz2ibz Subroutines find_equiv_map find_irred_wedge create_fbz2ibz_map symmetrize_3x3_tensor Derived Types type, public :: symmetry Data and procedure related to symmetries. Components Type Visibility Attributes Name Initial integer(kind=k8), public :: nsymm Number of spacegroup symmetries. integer(kind=k8), public :: nsymm_rot Number of rotations. integer(kind=k8), public, allocatable :: rotations_orig (:,:,:) Rotations without time-reversal, real space, crystal coordinates. real(kind=dp), public, allocatable :: crotations_orig (:,:,:) Rotations without time-reversal, real space, Cartesian coordinates. real(kind=dp), public, allocatable :: qrotations_orig (:,:,:) Rotations without time-reversal, reciprocal space, crystal coordinates. integer(kind=k8), public, allocatable :: rotations (:,:,:) Rotations with time-reversal, real space, crystal coordinates. real(kind=dp), public, allocatable :: crotations (:,:,:) Rotations with time-reversal, real space, Cartesian coordinates. real(kind=dp), public, allocatable :: qrotations (:,:,:) Rotations with time-reversal, reciprocal space, crystal coordinates. character(len=10), public :: international Spacegroup in Hermann–Mauguin (or international) notation. Type-Bound Procedures procedure, public :: calculate_symmetries Functions public function fbz2ibz (iwvmux, nwv_irred, nequiv, ibz2fbz_map) Find index in IBZ blocks list for a given FBZ blocks muxed vector index Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: iwvmux integer(kind=k8), intent(in) :: nwv_irred integer(kind=k8), intent(in) :: nequiv (nwv_irred) integer(kind=k8), intent(in) :: ibz2fbz_map (:,:,:) Return Value integer(kind=k8) Subroutines public subroutine find_equiv_map (nsymm_rot, equiv_map, mesh, qrotations, indexlist) Subroutine to create the map of equivalent wave vectors. Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: nsymm_rot integer(kind=k8), intent(out) :: equiv_map (:,:) integer(kind=k8), intent(in) :: mesh (3) real(kind=dp), intent(in) :: qrotations (:,:,:) integer(kind=k8), intent(in), optional :: indexlist (:) public subroutine find_irred_wedge (mesh, nwavevecs_irred, wavevecs_irred, indexlist_irred, nequivalent, nsymm_rot, qrotations, ibz2fbz_map, equivalence_map, blocks, indexlist) Find the irreducible wedge of the FBZ and other quantities.\n Wedge finding algorithm is inspired by ShengBTE. Read more… Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: mesh (3) integer(kind=k8), intent(out) :: nwavevecs_irred real(kind=dp), intent(out), allocatable :: wavevecs_irred (:,:) integer(kind=k8), intent(out), allocatable :: indexlist_irred (:) integer(kind=k8), intent(out), allocatable :: nequivalent (:) integer(kind=k8), intent(in) :: nsymm_rot real(kind=dp), intent(in) :: qrotations (:,:,:) integer(kind=k8), intent(out), allocatable :: ibz2fbz_map (:,:,:) integer(kind=k8), intent(out), allocatable :: equivalence_map (:,:) logical, intent(in) :: blocks integer(kind=k8), intent(in), optional :: indexlist (:) public subroutine create_fbz2ibz_map (fbz2ibz_map, nwv, nwv_irred, indexlist, nequiv, ibz2fbz_map) Subroutine to create map of FBZ blocks to IBZ blocks Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(out), allocatable :: fbz2ibz_map (:) integer(kind=k8), intent(in) :: nwv integer(kind=k8), intent(in) :: nwv_irred integer(kind=k8), intent(in) :: indexlist (nwv) integer(kind=k8), intent(in) :: nequiv (nwv_irred) integer(kind=k8), intent(in) :: ibz2fbz_map (:,:,:) public subroutine symmetrize_3x3_tensor (tensor, crotations) Symmetrize a 3x3 tensor. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: tensor (3,3) real(kind=dp), intent(in) :: crotations (:,:,:)","tags":"","loc":"module/symmetry_module.html"},{"title":"numerics_module – elphbolt","text":"Module containing type and procedures related to the numerics. Uses params misc crystal_module module~~numerics_module~~UsesGraph module~numerics_module numerics_module module~misc misc module~numerics_module->module~misc module~params params module~numerics_module->module~params module~crystal_module crystal_module module~numerics_module->module~crystal_module module~misc->module~params module~crystal_module->module~misc module~crystal_module->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~numerics_module~~UsedByGraph module~numerics_module numerics_module module~phonon_module phonon_module module~phonon_module->module~numerics_module module~wannier_module wannier_module module~phonon_module->module~wannier_module module~wannier_module->module~numerics_module module~interactions interactions module~interactions->module~numerics_module module~interactions->module~phonon_module module~interactions->module~wannier_module module~electron_module electron_module module~interactions->module~electron_module module~electron_module->module~numerics_module module~electron_module->module~wannier_module module~bte_module bte_module module~bte_module->module~numerics_module module~bte_module->module~phonon_module module~bte_module->module~interactions module~bte_module->module~electron_module module~bz_sums bz_sums module~bte_module->module~bz_sums program~elphbolt elphbolt program~elphbolt->module~numerics_module program~elphbolt->module~phonon_module program~elphbolt->module~wannier_module program~elphbolt->module~interactions program~elphbolt->module~electron_module program~elphbolt->module~bte_module program~elphbolt->module~bz_sums module~bz_sums->module~phonon_module module~bz_sums->module~electron_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types numerics Derived Types type, public :: numerics Data and procedures related to the numerics. Components Type Visibility Attributes Name Initial integer(kind=k8), public :: qmesh (3) Phonon wave vector mesh. integer(kind=k8), public :: mesh_ref Electron mesh refinement factor compared to the phonon mesh. real(kind=dp), public :: fsthick Fermi surface thickness in eV. character(len=1024), public :: cwd Current working directory. character(len=1024), public :: datadumpdir Runtime data dump repository. character(len=1024), public :: datadumpdir_T Runtime temperature dependent data dump repository. character(len=1024), public :: datadumpdir_T_chempot Runtime temperature and chemical potential dependent data dump repository. character(len=1024), public :: g2dir Directory for e-ph vertex. character(len=1024), public :: Vdir Directory for ph-ph vertex. character(len=1024), public :: Wdir Directory for ph-ph transition rates. character(len=1024), public :: Xdir Directory for e-ph transition rates. character(len=1024), public :: Ydir Directory for ph-e transition rates. logical, public :: read_gq2 Choose if earlier e-ph (IBZ q) vertices are to be used. logical, public :: read_gk2 Choose if earlier e-ph (IBZ k) vertices are to be used. logical, public :: read_V Choose if earlier ph-ph (IBZ q) vertices are to be used. logical, public :: read_W Choose if earlier ph-ph (IBZ q) transition probabilities are to be used. logical, public :: tetrahedra Choose if the tetrahedron method for 3d delta function evaluation will be used. logical, public :: phe Choose if ph-e interaction will be included. logical, public :: phiso Use phonon-isotope scattering? logical, public :: phsubs Use phonon-substitution scattering? logical, public :: onlyphbte Choose if only phonon BTE will be solved. logical, public :: onlyebte Choose if electron BTE will be solved. logical, public :: elchimp Use electron-charged impurity scattering? logical, public :: drag Choose if the drag effect will be included. integer(kind=k8), public :: maxiter Maximum number of iterations in the BTE solver. real(kind=dp), public :: conv_thres BTE iteration convergence criterion. logical, public :: plot_along_path Plot Wannierized quantities along high symmetry wave vectors? integer(kind=k8), public :: runlevel Control for the type of calculation. real(kind=dp), public :: ph_en_min Bounds of equidistant phonon energy mesh. real(kind=dp), public :: ph_en_max Bounds of equidistant phonon energy mesh. integer(kind=k8), public :: ph_en_num Number of equidistant phonon energy mesh points. real(kind=dp), public :: el_en_min Bounds of equidistant phonon energy mesh. real(kind=dp), public :: el_en_max Bounds of equidistant phonon energy mesh. integer(kind=k8), public :: el_en_num Number of equidistant phonon energy mesh points. Type-Bound Procedures procedure, public :: create_chempot_dirs procedure, public :: initialize => read_input_and_setup","tags":"","loc":"module/numerics_module.html"},{"title":"spglib_wrapper – elphbolt","text":"Wrapper for spglib from ShengBTE. Uses params iso_c_binding module~~spglib_wrapper~~UsesGraph module~spglib_wrapper spglib_wrapper iso_c_binding iso_c_binding module~spglib_wrapper->iso_c_binding module~params params module~spglib_wrapper->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~spglib_wrapper~~UsedByGraph module~spglib_wrapper spglib_wrapper module~symmetry_module symmetry_module module~symmetry_module->module~spglib_wrapper module~phonon_module phonon_module module~phonon_module->module~symmetry_module module~electron_module electron_module module~electron_module->module~symmetry_module module~bte_module bte_module module~bte_module->module~symmetry_module module~bte_module->module~phonon_module module~bte_module->module~electron_module module~bz_sums bz_sums module~bte_module->module~bz_sums module~interactions interactions module~bte_module->module~interactions module~bz_sums->module~symmetry_module module~bz_sums->module~phonon_module module~bz_sums->module~electron_module program~elphbolt elphbolt program~elphbolt->module~symmetry_module program~elphbolt->module~phonon_module program~elphbolt->module~electron_module program~elphbolt->module~bte_module program~elphbolt->module~bz_sums program~elphbolt->module~interactions module~interactions->module~phonon_module module~interactions->module~electron_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables symprec Interfaces spg_get_symmetry spg_get_international spg_get_multiplicity Functions get_num_operations Subroutines get_operations get_cartesian_operations Variables Type Visibility Attributes Name Initial real(kind=C_DOUBLE), public, parameter :: symprec = 1d-5 Interfaces interface public function spg_get_symmetry(rotations, translations, nops, lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_symmetry\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), dimension(3,3,nops) :: rotations real(kind=C_DOUBLE), dimension(3,nops) :: translations integer(kind=C_INT), value :: nops real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT) interface public function spg_get_international(symbol, lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_international\") Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), dimension(11) :: symbol real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT) interface public function spg_get_multiplicity(lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_multiplicity\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT) Functions public function get_num_operations (lattice, natoms, types, positions) Return the number of symmetry operations. Useful for allocating\n memory for get_operations(). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3,3) :: lattice integer(kind=k8), intent(in) :: natoms integer(kind=k8), intent(in), dimension(natoms) :: types real(kind=dp), intent(in), dimension(3,natoms) :: positions Return Value integer(kind=k8) Subroutines public subroutine get_operations (lattice, natoms, types, positions, nops, rotations, translations, international) Return the matrix and vector representations of the symmetry\n operations of the system. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3,3) :: lattice integer(kind=k8), intent(in) :: natoms integer(kind=k8), intent(in), dimension(natoms) :: types real(kind=dp), intent(in), dimension(3,natoms) :: positions integer(kind=k8), intent(inout) :: nops integer(kind=k8), intent(out), dimension(3,3,nops) :: rotations real(kind=dp), intent(out), dimension(3,nops) :: translations character(len=10), intent(out) :: international public subroutine get_cartesian_operations (lattice, nops, rotations, translations, crotations, ctranslations) Return the Cartesian components of the rotations and translations\n returned by get_operations(). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3,3) :: lattice integer(kind=k8), intent(in) :: nops integer(kind=k8), intent(in), dimension(3,3,nops) :: rotations real(kind=dp), intent(in), dimension(3,nops) :: translations real(kind=dp), intent(out), dimension(3,3,nops) :: crotations real(kind=dp), intent(out), dimension(3,nops) :: ctranslations","tags":"","loc":"module/spglib_wrapper.html"},{"title":"crystal_module – elphbolt","text":"Module containing type and procedures related to the crystal structure. Uses params misc module~~crystal_module~~UsesGraph module~crystal_module crystal_module module~misc misc module~crystal_module->module~misc module~params params module~crystal_module->module~params module~misc->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~crystal_module~~UsedByGraph module~crystal_module crystal_module module~phonon_module phonon_module module~phonon_module->module~crystal_module module~wannier_module wannier_module module~phonon_module->module~wannier_module module~numerics_module numerics_module module~phonon_module->module~numerics_module module~symmetry_module symmetry_module module~phonon_module->module~symmetry_module module~wannier_module->module~crystal_module module~wannier_module->module~numerics_module module~numerics_module->module~crystal_module module~interactions interactions module~interactions->module~crystal_module module~interactions->module~phonon_module module~interactions->module~wannier_module module~interactions->module~numerics_module module~electron_module electron_module module~interactions->module~electron_module module~electron_module->module~crystal_module module~electron_module->module~wannier_module module~electron_module->module~numerics_module module~electron_module->module~symmetry_module module~bte_module bte_module module~bte_module->module~crystal_module module~bte_module->module~phonon_module module~bte_module->module~numerics_module module~bte_module->module~interactions module~bte_module->module~electron_module module~bte_module->module~symmetry_module module~bz_sums bz_sums module~bte_module->module~bz_sums module~symmetry_module->module~crystal_module module~bz_sums->module~crystal_module module~bz_sums->module~phonon_module module~bz_sums->module~electron_module module~bz_sums->module~symmetry_module program~elphbolt elphbolt program~elphbolt->module~crystal_module program~elphbolt->module~phonon_module program~elphbolt->module~wannier_module program~elphbolt->module~numerics_module program~elphbolt->module~interactions program~elphbolt->module~electron_module program~elphbolt->module~bte_module program~elphbolt->module~symmetry_module program~elphbolt->module~bz_sums Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types crystal Subroutines calculate_wavevectors_full Derived Types type, public :: crystal Data and procedures related to the crystal structure. Components Type Visibility Attributes Name Initial integer(kind=k8), public :: numelements Number of types of basis atoms. integer(kind=k8), public :: numatoms Number of basis atoms. character(len=100), public :: name Name of material. character(len=3), public, allocatable :: elements (:) Elements in the basis. integer(kind=k8), public, allocatable :: atomtypes (:) Integer tagging unique elements in the basis. real(kind=dp), public, allocatable :: masses (:) Masses of the basis atoms. logical, public :: polar Is the system polar? real(kind=dp), public :: epsilon (3,3) Dielectric tensor. real(kind=dp), public, allocatable :: born (:,:,:) Born effective charge. real(kind=dp), public :: epsilon0 Static dielectric constant. logical, public :: read_epsiloninf Read high-frequency dielectric constant? real(kind=dp), public :: epsiloninf High frequency dielectric constant. real(kind=dp), public :: qTF Thomas-Fermi screening wave vector. real(kind=dp), public, allocatable :: basis (:,:) Basis vectors (crystal coordinates). real(kind=dp), public, allocatable :: basis_cart (:,:) Basis vectors (Cartesian coordinates). real(kind=dp), public :: lattvecs (3,3) Lattice vectors (nm). real(kind=dp), public :: volume Volume of primitive cell (nm&#94;3). real(kind=dp), public :: reclattvecs (3,3) Reciprocal lattice vectors. real(kind=dp), public :: volume_bz Brillouin zone volume (nm&#94;-3). real(kind=dp), public :: T Crystal temperature (K). logical, public :: autoisotopes Use isotopic mix for masses? real(kind=dp), public, allocatable :: gfactors (:) g-factors. real(kind=dp), public, allocatable :: subs_masses (:) Masses of the substitutional atoms real(kind=dp), public, allocatable :: subs_conc (:) Concentration of the substitutional atoms in cm&#94;-3 real(kind=dp), public, allocatable :: subs_gfactors (:) g-factors for the substitutional defects. logical, public :: twod Is the system 2d? real(kind=dp), public :: dim Dimension of the system real(kind=dp), public :: thickness Thickness of the system Type-Bound Procedures procedure, public :: initialize => read_input_and_setup_crystal Subroutines public subroutine calculate_wavevectors_full (mesh, wavevecs, blocks, indexlist) Calculate wave vectors (crystal coords.) of the full Brillouin zone (FBZ) Read more… Arguments Type Intent Optional Attributes Name integer(kind=k8), intent(in) :: mesh (3) real(kind=dp), intent(out), allocatable :: wavevecs (:,:) logical, intent(in) :: blocks integer(kind=k8), intent(in), optional :: indexlist (:)","tags":"","loc":"module/crystal_module.html"},{"title":"electron_module – elphbolt","text":"Module containing types and procedures related to the electronic properties. Uses params misc numerics_module wannier_module crystal_module symmetry_module delta module~~electron_module~~UsesGraph module~electron_module electron_module module~crystal_module crystal_module module~electron_module->module~crystal_module module~misc misc module~electron_module->module~misc module~numerics_module numerics_module module~electron_module->module~numerics_module module~wannier_module wannier_module module~electron_module->module~wannier_module module~symmetry_module symmetry_module module~electron_module->module~symmetry_module module~params params module~electron_module->module~params module~delta delta module~electron_module->module~delta module~crystal_module->module~misc module~crystal_module->module~params module~misc->module~params module~numerics_module->module~crystal_module module~numerics_module->module~misc module~numerics_module->module~params module~wannier_module->module~crystal_module module~wannier_module->module~misc module~wannier_module->module~numerics_module module~wannier_module->module~params module~symmetry_module->module~crystal_module module~symmetry_module->module~misc module~symmetry_module->module~params module~spglib_wrapper spglib_wrapper module~symmetry_module->module~spglib_wrapper module~delta->module~misc module~delta->module~params module~spglib_wrapper->module~params iso_c_binding iso_c_binding module~spglib_wrapper->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~electron_module~~UsedByGraph module~electron_module electron_module module~bte_module bte_module module~bte_module->module~electron_module module~bz_sums bz_sums module~bte_module->module~bz_sums module~interactions interactions module~bte_module->module~interactions program~elphbolt elphbolt program~elphbolt->module~electron_module program~elphbolt->module~bte_module program~elphbolt->module~bz_sums program~elphbolt->module~interactions module~bz_sums->module~electron_module module~interactions->module~electron_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types electron Derived Types type, public :: electron Data and procedures related to the electronic properties. Components Type Visibility Attributes Name Initial character(len=2), public :: prefix = 'el' Prefix idenitfying particle type. integer(kind=k8), public :: spindeg Spin degeneracy. integer(kind=k8), public :: numbands Total number of electronic Wannier bands. integer(kind=k8), public :: numtransbands Total number of transport active bands. integer(kind=k8), public :: indlowband Lowest transport band index. integer(kind=k8), public :: indhighband Highest transport band index. integer(kind=k8), public :: indlowconduction Lowest conduction band index. integer(kind=k8), public :: indhighvalence Highest valence band index. integer(kind=k8), public, allocatable :: bandlist (:) List of transport active band indices. integer(kind=k8), public :: mesh_ref Electron mesh refinement factor compared to the phonon mesh. integer(kind=k8), public :: mesh_ref_array (3) The same as above, but in array form. This is useful for 3d vs 2d cases. integer(kind=k8), public :: kmesh (3) Electron wave vector mesh. integer(kind=k8), public :: nk Number of fine electron wave vectors in the full Brillouin zone (FBZ). integer(kind=k8), public :: nk_irred Number of fine electron wave vectors in the irreducible wedge of Brillouin zone (IBZ). integer(kind=k8), public :: nstates_inwindow Number of electron wave vectors within transport window. integer(kind=k8), public :: nstates_irred_inwindow Number of IBZ wedge electron wave vectors within transport window. integer(kind=k8), public, allocatable :: IBZ_inwindow_states (:,:) List of irreducible wedge states within transport window. real(kind=dp), public :: enref Electron reference energy (eV).\n This is the center of the transport energy window. real(kind=dp), public :: fsthick Fermi surface thickness (eV). real(kind=dp), public :: chempot Chemical potential in (eV). real(kind=dp), public, allocatable :: conc (:) Band resolved carrier concentration. real(kind=dp), public :: conc_el Total electron carrier concentration. real(kind=dp), public :: conc_hole Total hole carrier concentration. real(kind=dp), public :: chimp_conc_n Concentration of donor impurities. real(kind=dp), public :: chimp_conc_p Concentration of acceptor impurities. real(kind=dp), public :: Zn Ionization number of donor dopant. real(kind=dp), public :: Zp Ionization number of acceptor dopant. real(kind=dp), public, allocatable :: wavevecs (:,:) List of all electron wave vectors (crystal coordinates). real(kind=dp), public, allocatable :: wavevecs_irred (:,:) List of irreducible electron wave vectors (crystal coordinates). integer(kind=k8), public, allocatable :: indexlist (:) List of muxed indices of the FBZ wave vectors. integer(kind=k8), public, allocatable :: indexlist_irred (:) List of muxed indices of the IBZ wedge. integer(kind=k8), public, allocatable :: nequiv (:) List of the number of equivalent points for each IBZ point. integer(kind=k8), public, allocatable :: ibz2fbz_map (:,:,:) Map from an IBZ electron point to its images.\n The third axis contains the pair (symmetry index, image). integer(kind=k8), public, allocatable :: fbz2ibz_map (:) Map from an FBZ electron point to its IBZ wedge image. integer(kind=k8), public, allocatable :: equiv_map (:,:) Map of equivalent points under rotations.\n Axis 1 runs over rotations.\n Axis 2 runs over wave vectors. real(kind=dp), public, allocatable :: symmetrizers (:,:,:) Symmetrizers of wave vector dependent vectors. integer(kind=k8), public, allocatable :: tetra (:,:) List of all the wave vector mesh tetrahedra vertices.\n First axis list tetraheda and the second axis list the vertices. integer(kind=k8), public, allocatable :: tetracount (:) The number of tetrahedra in which a wave vector belongs. integer(kind=k8), public, allocatable :: tetramap (:,:,:) Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real(kind=dp), public, allocatable :: tetra_evals (:,:,:) Tetrahedra vertices filled with eigenvalues. integer(kind=k8), public, allocatable :: triang (:,:) List of all the wave vector mesh triangles vertices.\n First axis lists triangles and the second axis lists the vertices. integer(kind=k8), public, allocatable :: triangcount (:) The number of triangles in which a wave vector belongs. integer(kind=k8), public, allocatable :: triangmap (:,:,:) Mapping from a wave vector to the (triangle, vertex) where it belongs. real(kind=dp), public, allocatable :: triang_evals (:,:,:) Triangles vertices filled with eigenvalues. real(kind=dp), public, allocatable :: ens (:,:) List of electron energies on FBZ. real(kind=dp), public, allocatable :: ens_irred (:,:) List of electron energies on IBZ. real(kind=dp), public, allocatable :: vels (:,:,:) List of electron velocities on FBZ. real(kind=dp), public, allocatable :: vels_irred (:,:,:) List of electron velocites on IBZ. complex(kind=dp), public, allocatable :: evecs (:,:,:) List of all electron eigenvectors. complex(kind=dp), public, allocatable :: evecs_irred (:,:,:) List of IBZ wedge electron eigenvectors. logical, public :: metallic Is the system metallic? real(kind=dp), public, allocatable :: dos (:,:) Band resolved density of states. character(len=1), public :: dopingtype Type of doping. This is needed for runlevel 0 only. integer(kind=k8), public :: numconc Number of concentration points. This is needed for runlevel 0 only. real(kind=dp), public, allocatable :: conclist (:) List of concentrations. This is needed for runlevel 0 only. integer(kind=k8), public :: numT Number of temperature points. This is needed for runlevel 0 only. real(kind=dp), public, allocatable :: Tlist (:) List of temperatures. This is needed for runlevel 0 only. Type-Bound Procedures procedure, public :: deallocate_eigenvecs procedure, public :: initialize => read_input_and_setup","tags":"","loc":"module/electron_module.html"},{"title":"elphbolt – elphbolt","text":"Uses params misc numerics_module crystal_module symmetry_module electron_module phonon_module wannier_module bte_module bz_sums interactions program~~elphbolt~~UsesGraph program~elphbolt elphbolt module~phonon_module phonon_module program~elphbolt->module~phonon_module module~crystal_module crystal_module program~elphbolt->module~crystal_module module~misc misc program~elphbolt->module~misc module~numerics_module numerics_module program~elphbolt->module~numerics_module module~wannier_module wannier_module program~elphbolt->module~wannier_module module~interactions interactions program~elphbolt->module~interactions module~electron_module electron_module program~elphbolt->module~electron_module module~bte_module bte_module program~elphbolt->module~bte_module module~symmetry_module symmetry_module program~elphbolt->module~symmetry_module module~params params program~elphbolt->module~params module~bz_sums bz_sums program~elphbolt->module~bz_sums module~phonon_module->module~crystal_module module~phonon_module->module~misc module~phonon_module->module~numerics_module module~phonon_module->module~wannier_module module~phonon_module->module~symmetry_module module~phonon_module->module~params module~delta delta module~phonon_module->module~delta module~crystal_module->module~misc module~crystal_module->module~params module~misc->module~params module~numerics_module->module~crystal_module module~numerics_module->module~misc module~numerics_module->module~params module~wannier_module->module~crystal_module module~wannier_module->module~misc module~wannier_module->module~numerics_module module~wannier_module->module~params module~interactions->module~phonon_module module~interactions->module~crystal_module module~interactions->module~misc module~interactions->module~numerics_module module~interactions->module~wannier_module module~interactions->module~electron_module module~interactions->module~params module~interactions->module~delta module~electron_module->module~crystal_module module~electron_module->module~misc module~electron_module->module~numerics_module module~electron_module->module~wannier_module module~electron_module->module~symmetry_module module~electron_module->module~params module~electron_module->module~delta module~bte_module->module~phonon_module module~bte_module->module~crystal_module module~bte_module->module~misc module~bte_module->module~numerics_module module~bte_module->module~interactions module~bte_module->module~electron_module module~bte_module->module~symmetry_module module~bte_module->module~params module~bte_module->module~bz_sums module~symmetry_module->module~crystal_module module~symmetry_module->module~misc module~symmetry_module->module~params module~spglib_wrapper spglib_wrapper module~symmetry_module->module~spglib_wrapper module~bz_sums->module~phonon_module module~bz_sums->module~crystal_module module~bz_sums->module~misc module~bz_sums->module~electron_module module~bz_sums->module~symmetry_module module~bz_sums->module~params module~bz_sums->module~delta module~spglib_wrapper->module~params iso_c_binding iso_c_binding module~spglib_wrapper->iso_c_binding module~delta->module~misc module~delta->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. elphbolt is a program for solving the coupled electron-phonon Boltzmann transport equations\n (e-ph BTEs) as formulated in https://arxiv.org/abs/2109.08547 (2021) with both the\n electron-phonon and phonon-phonon interactions computed ab initio. Calls program~~elphbolt~~CallsGraph program~elphbolt elphbolt proc~calculate_echimp_interaction_ibzk calculate_echimp_interaction_ibzk program~elphbolt->proc~calculate_echimp_interaction_ibzk proc~print_message print_message program~elphbolt->proc~print_message proc~calculate_gkrp calculate_gkRp program~elphbolt->proc~calculate_gkrp proc~calculate_eph_interaction_ibzk calculate_eph_interaction_ibzk program~elphbolt->proc~calculate_eph_interaction_ibzk proc~calculate_eph_interaction_ibzq calculate_eph_interaction_ibzq program~elphbolt->proc~calculate_eph_interaction_ibzq interface~calculate_dos calculate_dos program~elphbolt->interface~calculate_dos proc~subtitle subtitle program~elphbolt->proc~subtitle proc~calculate_3ph_interaction calculate_3ph_interaction program~elphbolt->proc~calculate_3ph_interaction proc~calculate_qtf calculate_qTF program~elphbolt->proc~calculate_qtf proc~welcome welcome program~elphbolt->proc~welcome proc~calculate_greq calculate_gReq program~elphbolt->proc~calculate_greq proc~calculate_echimp_interaction_ibzk->proc~print_message proc~delta_fn_tetra delta_fn_tetra proc~calculate_echimp_interaction_ibzk->proc~delta_fn_tetra proc~mux_state mux_state proc~calculate_echimp_interaction_ibzk->proc~mux_state proc~demux_state demux_state proc~calculate_echimp_interaction_ibzk->proc~demux_state proc~distribute_points distribute_points proc~calculate_echimp_interaction_ibzk->proc~distribute_points proc~delta_fn_triang delta_fn_triang proc~calculate_echimp_interaction_ibzk->proc~delta_fn_triang proc~calculate_gkrp->proc~print_message proc~calculate_gkrp->proc~distribute_points proc~calculate_eph_interaction_ibzk->proc~print_message proc~bose Bose proc~calculate_eph_interaction_ibzk->proc~bose proc~mux_vector mux_vector proc~calculate_eph_interaction_ibzk->proc~mux_vector proc~calculate_eph_interaction_ibzk->proc~delta_fn_tetra proc~exit_with_message exit_with_message proc~calculate_eph_interaction_ibzk->proc~exit_with_message proc~calculate_eph_interaction_ibzk->proc~mux_state proc~calculate_eph_interaction_ibzk->proc~demux_state proc~fermi Fermi proc~calculate_eph_interaction_ibzk->proc~fermi proc~calculate_eph_interaction_ibzk->proc~distribute_points proc~calculate_eph_interaction_ibzk->proc~delta_fn_triang proc~calculate_eph_interaction_ibzq->proc~print_message proc~calculate_eph_interaction_ibzq->proc~bose proc~calculate_eph_interaction_ibzq->proc~mux_vector proc~calculate_eph_interaction_ibzq->proc~delta_fn_tetra proc~calculate_eph_interaction_ibzq->proc~exit_with_message proc~calculate_eph_interaction_ibzq->proc~mux_state proc~binsearch binsearch proc~calculate_eph_interaction_ibzq->proc~binsearch proc~calculate_eph_interaction_ibzq->proc~demux_state proc~calculate_eph_interaction_ibzq->proc~fermi proc~calculate_eph_interaction_ibzq->proc~distribute_points proc~calculate_eph_interaction_ibzq->proc~delta_fn_triang proc~calculate_3ph_interaction->proc~print_message proc~calculate_3ph_interaction->proc~bose proc~calculate_3ph_interaction->proc~mux_vector proc~calculate_3ph_interaction->proc~delta_fn_tetra proc~calculate_3ph_interaction->proc~exit_with_message proc~calculate_3ph_interaction->proc~mux_state proc~expi expi proc~calculate_3ph_interaction->proc~expi proc~calculate_3ph_interaction->proc~demux_state proc~calculate_3ph_interaction->proc~distribute_points proc~calculate_3ph_interaction->proc~delta_fn_triang proc~calculate_qtf->proc~print_message proc~calculate_qtf->proc~fermi proc~calculate_greq->proc~print_message proc~calculate_greq->proc~distribute_points proc~mux_vector->proc~exit_with_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables num crys sym wann el ph bt Variables Type Attributes Name Initial type( numerics ) :: num type( crystal ) :: crys type( symmetry ) :: sym type( epw_wannier ) :: wann type( electron ) :: el type( phonon ) :: ph type( bte ) :: bt","tags":"","loc":"program/elphbolt.html"}]}