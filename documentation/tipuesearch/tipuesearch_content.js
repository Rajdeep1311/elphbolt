var tipuesearch = {"pages":[{"title":" elphbolt ","text":"elphbolt Developer Info Nakib Haider Protik","tags":"home","loc":"index.html"},{"title":"timer – elphbolt ","text":"type, public :: timer Container for timing related data and procedures. Contents Variables rate start end event Type-Bound Procedures end_timer start_timer Components Type Visibility Attributes Name Initial integer(kind=i64), public :: rate = 0 integer(kind=i64), public :: start = -1 integer(kind=i64), public :: end = -1 character(len=:), public, allocatable :: event Type-Bound Procedures procedure, public :: end_timer public  subroutine end_timer (self, event) End the timer and print the elapsed time. This is a blocking call.\nOnly image 1 can modify timing information. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: self character(len=*), intent(in) :: event procedure, public :: start_timer public  subroutine start_timer (self, event) Start/Reset the timer. This is a blocking call.\nOnly image 1 can modify timing information. Arguments Type Intent Optional Attributes Name class( timer ), intent(out) :: self character(len=*), intent(in) :: event","tags":"","loc":"type/timer.html"},{"title":"FC2_parser_factory – elphbolt ","text":"type, public :: FC2_parser_factory Contents Variables FC2 Type-Bound Procedures set_format Components Type Visibility Attributes Name Initial class( FC2 ), public, pointer :: FC2 Type-Bound Procedures procedure, public :: set_format public  function set_format (self, format_name) result(fc2_type) Arguments Type Intent Optional Attributes Name class( FC2_parser_factory ) :: self character(len=*), intent(in) :: format_name Return Value class( FC2 ), pointer","tags":"","loc":"type/fc2_parser_factory.html"},{"title":"FC2 – elphbolt ","text":"type, public, abstract :: FC2 Contents Type-Bound Procedures parser Type-Bound Procedures procedure( generic_parser ), public, deferred, pass(self) :: parser subroutine generic_parser(self) Prototype Arguments Type Intent Optional Attributes Name class( FC2 ), intent(in) :: self","tags":"","loc":"type/fc2.html"},{"title":"fc2_qe – elphbolt ","text":"type, public, extends( FC2 ) :: fc2_qe Quantum Espresso 2nd order force constants format Contents Type-Bound Procedures parser Type-Bound Procedures procedure, public, pass(self) :: parser => qe_parser interface public module subroutine qe_parser(self) Arguments Type Intent Optional Attributes Name class( fc2_qe ), intent(in) :: self","tags":"","loc":"type/fc2_qe.html"},{"title":"fc2_siesta – elphbolt ","text":"type, public, extends( FC2 ) :: fc2_siesta Siesta 2nd order force constants format Contents Type-Bound Procedures parser Type-Bound Procedures procedure, public, pass(self) :: parser => siesta_parser interface public module subroutine siesta_parser(self) Arguments Type Intent Optional Attributes Name class( fc2_siesta ), intent(in) :: self","tags":"","loc":"type/fc2_siesta.html"},{"title":"bte – elphbolt ","text":"type, public :: bte Data and procedures related to the BTE. Contents Variables ph_rta_rates_iso_ibz ph_rta_rates_subs_ibz ph_rta_rates_bound_ibz ph_rta_rates_thinfilm_ibz ph_rta_rates_3ph_ibz ph_rta_rates_4ph_ibz ph_rta_rates_phe_ibz ph_rta_rates_ibz ph_field_term_T ph_response_T ph_field_term_E ph_response_E el_rta_rates_echimp_ibz el_rta_rates_bound_ibz el_rta_rates_eph_ibz el_rta_rates_ibz el_field_term_T el_response_T el_field_term_E el_response_E Type-Bound Procedures post_process solve_bte Components Type Visibility Attributes Name Initial real(kind=r64), public, allocatable :: ph_rta_rates_iso_ibz (:,:) Phonon RTA scattering rates on the IBZ due to isotope scattering. real(kind=r64), public, allocatable :: ph_rta_rates_subs_ibz (:,:) Phonon RTA scattering rates on the IBZ due to substitution scattering. real(kind=r64), public, allocatable :: ph_rta_rates_bound_ibz (:,:) Phonon RTA scattering rates on the IBZ due to boundary scattering. real(kind=r64), public, allocatable :: ph_rta_rates_thinfilm_ibz (:,:) Phonon RTA scattering rates on the IBZ due to thin-film scattering. real(kind=r64), public, allocatable :: ph_rta_rates_3ph_ibz (:,:) Phonon RTA scattering rates on the IBZ due to 3-ph interactions. real(kind=r64), public, allocatable :: ph_rta_rates_4ph_ibz (:,:) Phonon RTA scattering rates on the IBZ due to 4-ph interactions. real(kind=r64), public, allocatable :: ph_rta_rates_phe_ibz (:,:) Phonon RTA scattering rates on the IBZ due to ph-e interactions. real(kind=r64), public, allocatable :: ph_rta_rates_ibz (:,:) Phonon RTA scattering rates on the IBZ. real(kind=r64), public, allocatable :: ph_field_term_T (:,:,:) Phonon field coupling term for gradT field on the FBZ. real(kind=r64), public, allocatable :: ph_response_T (:,:,:) Phonon response function for gradT field on the FBZ. real(kind=r64), public, allocatable :: ph_field_term_E (:,:,:) Phonon field coupling term for E field on the FBZ. real(kind=r64), public, allocatable :: ph_response_E (:,:,:) Phonon response function for E field on the FBZ. real(kind=r64), public, allocatable :: el_rta_rates_echimp_ibz (:,:) Electron RTA scattering rates on the IBZ due to charged impurity scattering. real(kind=r64), public, allocatable :: el_rta_rates_bound_ibz (:,:) Electron RTA scattering rates on the IBZ due to boundary scattering. real(kind=r64), public, allocatable :: el_rta_rates_eph_ibz (:,:) Electron RTA scattering rates on the IBZ due to e-ph interactions. real(kind=r64), public, allocatable :: el_rta_rates_ibz (:,:) Electron RTA scattering rates on the IBZ. real(kind=r64), public, allocatable :: el_field_term_T (:,:,:) Electron field coupling term for gradT field on the FBZ. real(kind=r64), public, allocatable :: el_response_T (:,:,:) Electron response function for gradT field on the FBZ. real(kind=r64), public, allocatable :: el_field_term_E (:,:,:) Electron field coupling term for E field on the FBZ. real(kind=r64), public, allocatable :: el_response_E (:,:,:) Electron response function for E field on the FBZ. Type-Bound Procedures procedure, public :: post_process private  subroutine post_process(self, num, crys, sym, ph, el) Subroutine to post-process results of the BTEs. Arguments Type Intent Optional Attributes Name class( bte ), intent(inout) :: self type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( symmetry ), intent(in) :: sym type( phonon ), intent(in) :: ph type( electron ), intent(in), optional :: el procedure, public :: solve_bte private  subroutine solve_bte(self, num, crys, sym, ph, el) Subroutine to solve the BTE self BTE object\nnum Numerics object\ncrys Crystal object\nsym Symmertry object\nph Phonon object\nel Electron object Arguments Type Intent Optional Attributes Name class( bte ), intent(inout) :: self type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( symmetry ), intent(in) :: sym type( phonon ), intent(in) :: ph type( electron ), intent(in), optional :: el","tags":"","loc":"type/bte.html"},{"title":"phonon – elphbolt ","text":"type, public, extends( particle ) :: phonon Data and procedures related to phonons. Contents Variables numbands wvmesh nwv nwv_irred wavevecs wavevecs_irred indexlist indexlist_irred nequiv ibz2fbz_map fbz2ibz_map equiv_map symmetrizers tetra tetracount tetramap tetra_evals triang triangcount triangmap triang_evals ens ens_irred vels vels_irred evecs evecs_irred dos prefix scell ifc2 ifc3 numtriplets R_j R_k Index_i Index_j Index_k tetra_squared_evals rws cell_r cell_g mm rr Type-Bound Procedures deallocate_phonon_quantities initialize Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numbands Total number of energy dispersion bands. integer(kind=i64), public :: wvmesh (3) Particle wave vector mesh. integer(kind=i64), public :: nwv Number of particle wave vectors in the full Brillouin zone (FBZ). integer(kind=i64), public :: nwv_irred Number of particle wave vectors in the irreducible wedge of Brillouin zone (IBZ). real(kind=r64), public, allocatable :: wavevecs (:,:) List of all particle wave vectors (crystal coordinates). real(kind=r64), public, allocatable :: wavevecs_irred (:,:) List of irreducible particle wave vectors (crystal coordinates). integer(kind=i64), public, allocatable :: indexlist (:) List of muxed indices of the FBZ wave vectors. integer(kind=i64), public, allocatable :: indexlist_irred (:) List of muxed indices of the IBZ wedge. integer(kind=i64), public, allocatable :: nequiv (:) List of the number of equivalent points for each IBZ point. integer(kind=i64), public, allocatable :: ibz2fbz_map (:,:,:) Map from an IBZ particle wave vector point to its images.\nThe third axis contains the pair (symmetry index, image). integer(kind=i64), public, allocatable :: fbz2ibz_map (:) Map from an FBZ particle wave vector point to its IBZ wedge image. integer(kind=i64), public, allocatable :: equiv_map (:,:) Map of equivalent points under rotations.\nAxis 1 runs over rotations.\nAxis 2 runs over wave vectors. real(kind=r64), public, allocatable :: symmetrizers (:,:,:) Symmetrizers of wave vector dependent vectors. integer(kind=i64), public, allocatable :: tetra (:,:) List of all the wave vector mesh tetrahedra vertices.\nFirst axis list tetraheda and the second axis list the vertices. integer(kind=i64), public, allocatable :: tetracount (:) The number of tetrahedra in which a wave vector belongs. integer(kind=i64), public, allocatable :: tetramap (:,:,:) Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real(kind=r64), public, allocatable :: tetra_evals (:,:,:) Tetrahedra vertices filled with eigenvalues. integer(kind=i64), public, allocatable :: triang (:,:) List of all the wave vector mesh triangles vertices.\nFirst axis lists triangles and the second axis lists the vertices. integer(kind=i64), public, allocatable :: triangcount (:) The number of triangles in which a wave vector belongs. integer(kind=i64), public, allocatable :: triangmap (:,:,:) Mapping from a wave vector to the (triangle, vertex) where it belongs. real(kind=r64), public, allocatable :: triang_evals (:,:,:) Triangles vertices filled with eigenvalues. real(kind=r64), public, allocatable :: ens (:,:) List of particle energies on FBZ. real(kind=r64), public, allocatable :: ens_irred (:,:) List of particle energies on IBZ. real(kind=r64), public, allocatable :: vels (:,:,:) List of particle velocities on FBZ. real(kind=r64), public, allocatable :: vels_irred (:,:,:) List of particle velocites on IBZ. complex(kind=r64), public, allocatable :: evecs (:,:,:) List of all particle eigenvectors. complex(kind=r64), public, allocatable :: evecs_irred (:,:,:) List of IBZ wedge particle eigenvectors. real(kind=r64), public, allocatable :: dos (:,:) Band resolved density of states. character(len=2), public :: prefix = 'ph' Prefix idenitfying particle type. integer(kind=i64), public :: scell (3) q-mesh used in DFPT or, equivalently, supercell used in finite displencement\nmethod for calculating the 2nd order force constants. real(kind=r64), public, allocatable :: ifc2 (:,:,:,:,:,:,:) Second order force constants (ifc2) tensor. real(kind=r64), public, allocatable :: ifc3 (:,:,:,:) Third order force constants (ifc3) tensor. integer(kind=i64), public :: numtriplets Number of triplets in the ifc3 file. real(kind=r64), public, allocatable :: R_j (:,:) Position of the 2nd and 3rd unitcell in supercell for an ifc3 triplet. real(kind=r64), public, allocatable :: R_k (:,:) Position of the 2nd and 3rd unitcell in supercell for an ifc3 triplet. integer(kind=i64), public, allocatable :: Index_i (:) Label of primitive cell atoms in the ifc3 triplet. integer(kind=i64), public, allocatable :: Index_j (:) Label of primitive cell atoms in the ifc3 triplet. integer(kind=i64), public, allocatable :: Index_k (:) Label of primitive cell atoms in the ifc3 triplet. real(kind=r64), public, allocatable :: tetra_squared_evals (:,:,:) Tetrahedra vertices filled with squared eigenvalues.\nThis is needed only for the phonon Green's function calculation. real(kind=r64), public :: rws (124,0:3) real(kind=r64), public :: cell_r (1:3,0:3) real(kind=r64), public :: cell_g (1:3,0:3) real(kind=r64), public, allocatable :: mm (:,:) real(kind=r64), public, allocatable :: rr (:,:,:) Type-Bound Procedures procedure, public :: deallocate_phonon_quantities private  subroutine deallocate_phonon_quantities(self) Deallocate the electron eigenvectors Arguments Type Intent Optional Attributes Name class( phonon ), intent(inout) :: self procedure, public :: initialize private  subroutine initialize(self, crys, sym, num) Initialize the phonon data type, calculate ground state phonon properties,\nand read 3rd order force constants data. Arguments Type Intent Optional Attributes Name class( phonon ), intent(out) :: self type( crystal ), intent(in) :: crys type( symmetry ), intent(in) :: sym type( numerics ), intent(in) :: num","tags":"","loc":"type/phonon.html"},{"title":"particle – elphbolt ","text":"type, public :: particle Data related to generic particle properties. Contents Variables numbands wvmesh nwv nwv_irred wavevecs wavevecs_irred indexlist indexlist_irred nequiv ibz2fbz_map fbz2ibz_map equiv_map symmetrizers tetra tetracount tetramap tetra_evals triang triangcount triangmap triang_evals ens ens_irred vels vels_irred evecs evecs_irred dos Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numbands Total number of energy dispersion bands. integer(kind=i64), public :: wvmesh (3) Particle wave vector mesh. integer(kind=i64), public :: nwv Number of particle wave vectors in the full Brillouin zone (FBZ). integer(kind=i64), public :: nwv_irred Number of particle wave vectors in the irreducible wedge of Brillouin zone (IBZ). real(kind=r64), public, allocatable :: wavevecs (:,:) List of all particle wave vectors (crystal coordinates). real(kind=r64), public, allocatable :: wavevecs_irred (:,:) List of irreducible particle wave vectors (crystal coordinates). integer(kind=i64), public, allocatable :: indexlist (:) List of muxed indices of the FBZ wave vectors. integer(kind=i64), public, allocatable :: indexlist_irred (:) List of muxed indices of the IBZ wedge. integer(kind=i64), public, allocatable :: nequiv (:) List of the number of equivalent points for each IBZ point. integer(kind=i64), public, allocatable :: ibz2fbz_map (:,:,:) Map from an IBZ particle wave vector point to its images.\nThe third axis contains the pair (symmetry index, image). integer(kind=i64), public, allocatable :: fbz2ibz_map (:) Map from an FBZ particle wave vector point to its IBZ wedge image. integer(kind=i64), public, allocatable :: equiv_map (:,:) Map of equivalent points under rotations.\nAxis 1 runs over rotations.\nAxis 2 runs over wave vectors. real(kind=r64), public, allocatable :: symmetrizers (:,:,:) Symmetrizers of wave vector dependent vectors. integer(kind=i64), public, allocatable :: tetra (:,:) List of all the wave vector mesh tetrahedra vertices.\nFirst axis list tetraheda and the second axis list the vertices. integer(kind=i64), public, allocatable :: tetracount (:) The number of tetrahedra in which a wave vector belongs. integer(kind=i64), public, allocatable :: tetramap (:,:,:) Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real(kind=r64), public, allocatable :: tetra_evals (:,:,:) Tetrahedra vertices filled with eigenvalues. integer(kind=i64), public, allocatable :: triang (:,:) List of all the wave vector mesh triangles vertices.\nFirst axis lists triangles and the second axis lists the vertices. integer(kind=i64), public, allocatable :: triangcount (:) The number of triangles in which a wave vector belongs. integer(kind=i64), public, allocatable :: triangmap (:,:,:) Mapping from a wave vector to the (triangle, vertex) where it belongs. real(kind=r64), public, allocatable :: triang_evals (:,:,:) Triangles vertices filled with eigenvalues. real(kind=r64), public, allocatable :: ens (:,:) List of particle energies on FBZ. real(kind=r64), public, allocatable :: ens_irred (:,:) List of particle energies on IBZ. real(kind=r64), public, allocatable :: vels (:,:,:) List of particle velocities on FBZ. real(kind=r64), public, allocatable :: vels_irred (:,:,:) List of particle velocites on IBZ. complex(kind=r64), public, allocatable :: evecs (:,:,:) List of all particle eigenvectors. complex(kind=r64), public, allocatable :: evecs_irred (:,:,:) List of IBZ wedge particle eigenvectors. real(kind=r64), public, allocatable :: dos (:,:) Band resolved density of states.","tags":"","loc":"type/particle.html"},{"title":"electron – elphbolt ","text":"type, public, extends( particle ) :: electron Data and procedures related to the electronic properties. Contents Variables numbands wvmesh nwv nwv_irred wavevecs wavevecs_irred indexlist indexlist_irred nequiv ibz2fbz_map fbz2ibz_map equiv_map symmetrizers tetra tetracount tetramap tetra_evals triang triangcount triangmap triang_evals ens ens_irred vels vels_irred evecs evecs_irred dos prefix spindeg numtransbands indlowband indhighband indlowconduction indhighvalence bandlist mesh_ref mesh_ref_array nstates_inwindow nstates_irred_inwindow IBZ_inwindow_states enref fsthick chempot conc conc_el conc_hole chimp_conc_n chimp_conc_p Zn Zp scissor metallic dopingtype numconc conclist numT Tlist spinnormed_dos_fermi Ws_irred Ws Type-Bound Procedures deallocate_eigenvecs initialize Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numbands Total number of energy dispersion bands. integer(kind=i64), public :: wvmesh (3) Particle wave vector mesh. integer(kind=i64), public :: nwv Number of particle wave vectors in the full Brillouin zone (FBZ). integer(kind=i64), public :: nwv_irred Number of particle wave vectors in the irreducible wedge of Brillouin zone (IBZ). real(kind=r64), public, allocatable :: wavevecs (:,:) List of all particle wave vectors (crystal coordinates). real(kind=r64), public, allocatable :: wavevecs_irred (:,:) List of irreducible particle wave vectors (crystal coordinates). integer(kind=i64), public, allocatable :: indexlist (:) List of muxed indices of the FBZ wave vectors. integer(kind=i64), public, allocatable :: indexlist_irred (:) List of muxed indices of the IBZ wedge. integer(kind=i64), public, allocatable :: nequiv (:) List of the number of equivalent points for each IBZ point. integer(kind=i64), public, allocatable :: ibz2fbz_map (:,:,:) Map from an IBZ particle wave vector point to its images.\nThe third axis contains the pair (symmetry index, image). integer(kind=i64), public, allocatable :: fbz2ibz_map (:) Map from an FBZ particle wave vector point to its IBZ wedge image. integer(kind=i64), public, allocatable :: equiv_map (:,:) Map of equivalent points under rotations.\nAxis 1 runs over rotations.\nAxis 2 runs over wave vectors. real(kind=r64), public, allocatable :: symmetrizers (:,:,:) Symmetrizers of wave vector dependent vectors. integer(kind=i64), public, allocatable :: tetra (:,:) List of all the wave vector mesh tetrahedra vertices.\nFirst axis list tetraheda and the second axis list the vertices. integer(kind=i64), public, allocatable :: tetracount (:) The number of tetrahedra in which a wave vector belongs. integer(kind=i64), public, allocatable :: tetramap (:,:,:) Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real(kind=r64), public, allocatable :: tetra_evals (:,:,:) Tetrahedra vertices filled with eigenvalues. integer(kind=i64), public, allocatable :: triang (:,:) List of all the wave vector mesh triangles vertices.\nFirst axis lists triangles and the second axis lists the vertices. integer(kind=i64), public, allocatable :: triangcount (:) The number of triangles in which a wave vector belongs. integer(kind=i64), public, allocatable :: triangmap (:,:,:) Mapping from a wave vector to the (triangle, vertex) where it belongs. real(kind=r64), public, allocatable :: triang_evals (:,:,:) Triangles vertices filled with eigenvalues. real(kind=r64), public, allocatable :: ens (:,:) List of particle energies on FBZ. real(kind=r64), public, allocatable :: ens_irred (:,:) List of particle energies on IBZ. real(kind=r64), public, allocatable :: vels (:,:,:) List of particle velocities on FBZ. real(kind=r64), public, allocatable :: vels_irred (:,:,:) List of particle velocites on IBZ. complex(kind=r64), public, allocatable :: evecs (:,:,:) List of all particle eigenvectors. complex(kind=r64), public, allocatable :: evecs_irred (:,:,:) List of IBZ wedge particle eigenvectors. real(kind=r64), public, allocatable :: dos (:,:) Band resolved density of states. character(len=2), public :: prefix = 'el' Prefix idenitfying particle type. integer(kind=i64), public :: spindeg Spin degeneracy. integer(kind=i64), public :: numtransbands Total number of transport active bands. integer(kind=i64), public :: indlowband Lowest transport band index. integer(kind=i64), public :: indhighband Highest transport band index. integer(kind=i64), public :: indlowconduction Lowest conduction band index. integer(kind=i64), public :: indhighvalence Highest valence band index. integer(kind=i64), public, allocatable :: bandlist (:) List of transport active band indices. integer(kind=i64), public :: mesh_ref Electron mesh refinement factor compared to the phonon mesh. integer(kind=i64), public :: mesh_ref_array (3) The same as above, but in array form. This is useful for 3d vs 2d cases. integer(kind=i64), public :: nstates_inwindow Number of electron wave vectors within transport window. integer(kind=i64), public :: nstates_irred_inwindow Number of IBZ wedge electron wave vectors within transport window. integer(kind=i64), public, allocatable :: IBZ_inwindow_states (:,:) List of irreducible wedge states within transport window. real(kind=r64), public :: enref Electron reference energy (eV).\nThis is the center of the transport energy window. real(kind=r64), public :: fsthick Fermi surface thickness (eV). real(kind=r64), public :: chempot Chemical potential in (eV). real(kind=r64), public, allocatable :: conc (:) Band resolved carrier concentration. real(kind=r64), public :: conc_el Total electron carrier concentration. real(kind=r64), public :: conc_hole Total hole carrier concentration. real(kind=r64), public :: chimp_conc_n Concentration of donor impurities. real(kind=r64), public :: chimp_conc_p Concentration of acceptor impurities. real(kind=r64), public :: Zn Ionization number of donor dopant. real(kind=r64), public :: Zp Ionization number of acceptor dopant. real(kind=r64), public, allocatable :: scissor (:) Scissor operator (eV) logical, public :: metallic Is the system metallic? character(len=1), public :: dopingtype Type of doping. This is needed for runlevel 0 only. integer(kind=i64), public :: numconc Number of concentration points. This is needed for runlevel 0 only. real(kind=r64), public, allocatable :: conclist (:) List of concentrations. This is needed for runlevel 0 only. integer(kind=i64), public :: numT Number of temperature points. This is needed for runlevel 0 only. real(kind=r64), public, allocatable :: Tlist (:) List of temperatures. This is needed for runlevel 0 only. real(kind=r64), public :: spinnormed_dos_fermi Spin-normalized density of states at the Fermi level real(kind=r64), public, allocatable :: Ws_irred (:,:) Electron delta functions normalized by spinnormed_dos_fermi real(kind=r64), public, allocatable :: Ws (:,:) Electron delta functions normalized by spinnormed_dos_fermi Type-Bound Procedures procedure, public :: deallocate_eigenvecs private  subroutine deallocate_eigenvecs(self) Deallocate the electron eigenvectors Arguments Type Intent Optional Attributes Name class( electron ), intent(inout) :: self procedure, public :: initialize => read_input_and_setup private  subroutine read_input_and_setup(self, wann, crys, sym, num) Read input file and setup groundstate electronic system. Arguments Type Intent Optional Attributes Name class( electron ), intent(out) :: self type( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys type( symmetry ), intent(in) :: sym type( numerics ), intent(in) :: num","tags":"","loc":"type/electron.html"},{"title":"phonon_defect – elphbolt ","text":"type, public :: phonon_defect Data and procedures related to phonon defects. Contents Variables range numcells numhosts cell_pos_intvec dimp_cell_pos_intvec pcell_atom_label pcell_atom_dof V_mass V_bond D0 mass_defect approx Type-Bound Procedures calculate_phonon_Tmatrix initialize Components Type Visibility Attributes Name Initial real(kind=r64), public :: range Radius of the defect in nm. This defines a block of cells in the defective supercell. integer(kind=i64), public :: numcells Number of cells in the defective supercell block. integer(kind=i64), public :: numhosts Number of host sites in the unit cell. This can't exceed the number of unique elements. integer(kind=i64), public, allocatable :: cell_pos_intvec (:,:) Unitcell positions as 0-based integer triplets in the defective supercell block. integer(kind=i64), public, allocatable :: dimp_cell_pos_intvec (:,:) Unitcell positions as 0-based integer triplets in the defective supercell block. integer(kind=i64), public, allocatable :: pcell_atom_label (:) Primitive cell equivalence (integer label) of atoms in the defective supercell block. integer(kind=i64), public, allocatable :: pcell_atom_dof (:) Primitive cell equivalent atomic degree of freedom. real(kind=r64), public, allocatable :: V_mass (:) On-site mass defect potential. real(kind=r64), public, allocatable :: V_bond (:,:) General space-dependent, pairwise defect potential. complex(kind=r64), public, allocatable :: D0 (:,:,:) Retarded, bare Green's function defined on the defect space. logical, public :: mass_defect Choose if mass defect is going to be used. character(len=100), public :: approx Approximation of scattering T-matrix. Type-Bound Procedures procedure, public :: calculate_phonon_Tmatrix private  subroutine calculate_phonon_Tmatrix(self, ph, crys) Arguments Type Intent Optional Attributes Name class( phonon_defect ), intent(inout) :: self type( phonon ), intent(in) :: ph type( crystal ), intent(in) :: crys procedure, public :: initialize private  subroutine initialize(self, ph, crys) Initialize the phonon defect data type. Arguments Type Intent Optional Attributes Name class( phonon_defect ), intent(out) :: self type( phonon ), intent(in) :: ph type( crystal ), intent(in) :: crys","tags":"","loc":"type/phonon_defect.html"},{"title":"MigEl_sc – elphbolt ","text":"type, public :: MigEl_sc Data and procedures related to the Migdal-Eliashberg equations solver environment. Contents Variables numqp qp_ens qp_cutoff nummatsubara nummatsubara_upper matsubara_cutoff bose_matsubara_ens fermi_matsubara_ens omegas numomega omegalog iso_lambda0 domega Tstart Tend dT mustar MAD_Tc BCS_delta isotropic use_external_eps Type-Bound Procedures calculate_MigEl_theory calculate_MAD_theory initialize Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numqp Number of point on quasiparticle energy grid real(kind=r64), public, allocatable :: qp_ens (:) Uniform quasiparticle energy mesh integer(kind=i64), public :: qp_cutoff Quasiparticle energy cutoff (factor that multiplies the highest phonon energy) integer(kind=i64), public :: nummatsubara Number of points on Matsubara mesh integer(kind=i64), public :: nummatsubara_upper Number of points on upper plane Matsubara mesh integer(kind=i64), public :: matsubara_cutoff Matsubara energy cutoff (factor of highest phonon energy) real(kind=r64), public, allocatable :: bose_matsubara_ens (:) Uniform Bosonic Matsubara mesh real(kind=r64), public, allocatable :: fermi_matsubara_ens (:) Number of point on phonon energy grid real(kind=r64), public, allocatable :: omegas (:) Uniform Fermionic Matsubara mesh integer(kind=i64), public :: numomega Uniform phonon energy mesh real(kind=r64), public :: omegalog Logarithmic average of phonon energy real(kind=r64), public :: iso_lambda0 Standard, isotropic e-ph coupling real(kind=r64), public :: domega Uniform bosonic mesh energy difference real(kind=r64), public :: Tstart Temperature sweep: start, end, difference real(kind=r64), public :: Tend Temperature sweep: start, end, difference real(kind=r64), public :: dT Temperature sweep: start, end, difference real(kind=r64), public :: mustar Dimensionless Coulomb pseudopotential parameter real(kind=r64), public :: MAD_Tc Superconducting transition temperature in the McMillan-Allen-Dynes (MAD) theory real(kind=r64), public :: BCS_delta Superconducting gap from the BCS theory using the MAD Tc logical, public :: isotropic Use isotropic approximation? logical, public :: use_external_eps Use user generated |epsilon|&#94;2 to screen a2F? Type-Bound Procedures procedure, public :: calculate_MigEl_theory private  subroutine calculate_MigEl_theory(self, el, wann, num, max_ph_en) Solve the Migdal-Eliashberg equations. Arguments Type Intent Optional Attributes Name class( MigEl_sc ), intent(inout) :: self type( electron ), intent(in) :: el type( epw_wannier ), intent(in) :: wann type( numerics ), intent(in) :: num real(kind=r64), intent(in) :: max_ph_en procedure, public :: calculate_MAD_theory private  subroutine calculate_MAD_theory(self) Calculate the supercondting gap and transition temperature\nusing the McMillan-Allen-Dynes (MAD) theory.\nP. B. Allen and R. C. Dynes Phys. Rev. B 12, 905 (1975). Arguments Type Intent Optional Attributes Name class( MigEl_sc ), intent(inout) :: self procedure, public :: initialize private  subroutine initialize(self, max_ph_en) Read input file and setup the T-independent part of the MigEl environment. Arguments Type Intent Optional Attributes Name class( MigEl_sc ), intent(out) :: self real(kind=r64), intent(in) :: max_ph_en","tags":"","loc":"type/migel_sc.html"},{"title":"symmetry – elphbolt ","text":"type, public :: symmetry Data and procedure related to symmetries. Contents Variables nsymm nsymm_rot rotations_orig crotations_orig qrotations_orig rotations crotations qrotations international Type-Bound Procedures calculate_symmetries Components Type Visibility Attributes Name Initial integer(kind=i64), public :: nsymm Number of spacegroup symmetries. integer(kind=i64), public :: nsymm_rot Number of rotations. integer(kind=i64), public, allocatable :: rotations_orig (:,:,:) Rotations without time-reversal, real space, crystal coordinates. real(kind=r64), public, allocatable :: crotations_orig (:,:,:) Rotations without time-reversal, real space, Cartesian coordinates. real(kind=r64), public, allocatable :: qrotations_orig (:,:,:) Rotations without time-reversal, reciprocal space, crystal coordinates. integer(kind=i64), public, allocatable :: rotations (:,:,:) Rotations with time-reversal, real space, crystal coordinates. real(kind=r64), public, allocatable :: crotations (:,:,:) Rotations with time-reversal, real space, Cartesian coordinates. real(kind=r64), public, allocatable :: qrotations (:,:,:) Rotations with time-reversal, reciprocal space, crystal coordinates. character(len=10), public :: international Spacegroup in Hermann–Mauguin (or international) notation. Type-Bound Procedures procedure, public :: calculate_symmetries private  subroutine calculate_symmetries(self, crys, mesh) Subroutine to generate the symmetry related data for a given crystal. This subroutine closely follows parts of config.f90 of the ShengBTE code. Arguments Type Intent Optional Attributes Name class( symmetry ), intent(out) :: self type( crystal ), intent(in) :: crys integer(kind=i64), intent(in) :: mesh (3)","tags":"","loc":"type/symmetry.html"},{"title":"numerics – elphbolt ","text":"type, public :: numerics Data and procedures related to the numerics. Contents Variables qmesh mesh_ref fsthick cwd datadumpdir datadumpdir_T datadumpdir_T_chempot g2dir Vdir Wdir Xdir Ydir scdir read_gq2 read_gk2 read_V read_W tetrahedra phe phiso phsubs phbound fourph fourph_mesh_ref phthinfilm phdef_Tmat onlyphbte onlyebte elchimp elbound drag maxiter conv_thres plot_along_path runlevel ph_en_min ph_en_max ph_en_num el_en_min el_en_max el_en_num ph_mfp_npts Type-Bound Procedures create_chempot_dirs initialize Components Type Visibility Attributes Name Initial integer(kind=i64), public :: qmesh (3) Phonon wave vector mesh. integer(kind=i64), public :: mesh_ref Electron mesh refinement factor compared to the phonon mesh. real(kind=r64), public :: fsthick Fermi surface thickness in eV. character(len=1024), public :: cwd Current working directory. character(len=1024), public :: datadumpdir Runtime data dump repository. character(len=1024), public :: datadumpdir_T Runtime temperature dependent data dump repository. character(len=1024), public :: datadumpdir_T_chempot Runtime temperature and chemical potential dependent data dump repository. character(len=1024), public :: g2dir Directory for e-ph vertex. character(len=1024), public :: Vdir Directory for ph-ph vertex. character(len=1024), public :: Wdir Directory for ph-ph transition rates. character(len=1024), public :: Xdir Directory for e-ph transition rates. character(len=1024), public :: Ydir Directory for ph-e transition rates. character(len=1024), public :: scdir Directory for the superconductivity temporary data. logical, public :: read_gq2 Choose if earlier e-ph (IBZ q) vertices are to be used. logical, public :: read_gk2 Choose if earlier e-ph (IBZ k) vertices are to be used. logical, public :: read_V Choose if earlier ph-ph (IBZ q) vertices are to be used. logical, public :: read_W Choose if earlier ph-ph (IBZ q) transition probabilities are to be used. logical, public :: tetrahedra Choose if the tetrahedron method for 3d delta function evaluation will be used. logical, public :: phe Choose if ph-e interaction will be included. logical, public :: phiso Use phonon-isotope scattering? logical, public :: phsubs Use phonon-substitution scattering? logical, public :: phbound Use phonon-boundary scattering? logical, public :: fourph Use 4-ph scattering? integer(kind=i64), public :: fourph_mesh_ref Mesh refinement factor of phonon wavectors with respect to external 4-ph calculation logical, public :: phthinfilm Use phonon-thin-film scattering? logical, public :: phdef_Tmat Calculate phonon-defect scattering T-matrix? logical, public :: onlyphbte Choose if only phonon BTE will be solved. logical, public :: onlyebte Choose if electron BTE will be solved. logical, public :: elchimp Use electron-charged impurity scattering? logical, public :: elbound Use electron-boundary scattering? logical, public :: drag Choose if the drag effect will be included. integer(kind=i64), public :: maxiter Maximum number of iterations in the BTE/Migdal-Eliashberg equations solver. real(kind=r64), public :: conv_thres BTE/Migdal-Eliashberg euqations iteration convergence criterion. logical, public :: plot_along_path Plot Wannierized quantities along high symmetry wave vectors? integer(kind=i64), public :: runlevel Control for the type of calculation. real(kind=r64), public :: ph_en_min Bounds of equidistant phonon energy mesh. real(kind=r64), public :: ph_en_max Bounds of equidistant phonon energy mesh. integer(kind=i64), public :: ph_en_num Number of equidistant phonon energy mesh points. real(kind=r64), public :: el_en_min Bounds of equidistant electron energy mesh. real(kind=r64), public :: el_en_max Bounds of equidistant electron energy mesh. integer(kind=i64), public :: el_en_num Number of equidistant electron energy mesh points. integer(kind=i64), public :: ph_mfp_npts Number of equidistant phonon mean-free-path mesh points. Type-Bound Procedures procedure, public :: create_chempot_dirs private  subroutine create_chempot_dirs(self, chempot) Subroutine to create data dump directory tagged by the chemical potential\nand subdirectories within. Arguments Type Intent Optional Attributes Name class( numerics ), intent(inout) :: self real(kind=r64), intent(in) :: chempot procedure, public :: initialize => read_input_and_setup private  subroutine read_input_and_setup(self, crys) Read input file for information related to the numerics. self Numerics object\ncrys Crytal object Arguments Type Intent Optional Attributes Name class( numerics ), intent(out) :: self type( crystal ), intent(in) :: crys","tags":"","loc":"type/numerics.html"},{"title":"crystal – elphbolt ","text":"type, public :: crystal Data and procedures related to the crystal structure. Contents Variables numelements numatoms name elements atomtypes masses polar epsilon born epsilon0 read_epsiloninf epsiloninf qTF basis basis_cart lattvecs volume reclattvecs volume_bz T autoisotopes gfactors subs_masses subs_conc subs_gfactors defect_hosts numdopants_types dopant_masses dopant_conc twod dim thickness bound_length thinfilm_height thinfilm_normal Type-Bound Procedures initialize Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numelements Number of types of basis atoms. integer(kind=i64), public :: numatoms Number of basis atoms. character(len=100), public :: name Name of material. character(len=3), public, allocatable :: elements (:) Elements in the basis. integer(kind=i64), public, allocatable :: atomtypes (:) Integer tagging unique elements in the basis. real(kind=r64), public, allocatable :: masses (:) Masses of the basis atoms. logical, public :: polar Is the system polar? real(kind=r64), public :: epsilon (3,3) Dielectric tensor. real(kind=r64), public, allocatable :: born (:,:,:) Born effective charge. real(kind=r64), public :: epsilon0 Static dielectric constant. logical, public :: read_epsiloninf Read high-frequency dielectric constant? real(kind=r64), public :: epsiloninf High frequency dielectric constant. real(kind=r64), public :: qTF Thomas-Fermi screening wave vector. real(kind=r64), public, allocatable :: basis (:,:) Basis vectors (crystal coordinates). real(kind=r64), public, allocatable :: basis_cart (:,:) Basis vectors (Cartesian coordinates). real(kind=r64), public :: lattvecs (3,3) Lattice vectors (nm). real(kind=r64), public :: volume Volume of primitive cell (nm&#94;3). real(kind=r64), public :: reclattvecs (3,3) Reciprocal lattice vectors. real(kind=r64), public :: volume_bz Brillouin zone volume (nm&#94;-3). real(kind=r64), public :: T Crystal temperature (K). logical, public :: autoisotopes Use isotopic mix for masses? real(kind=r64), public, allocatable :: gfactors (:) g-factors. real(kind=r64), public, allocatable :: subs_masses (:) Masses of the substitutional atoms [D] real(kind=r64), public, allocatable :: subs_conc (:) Concentration of the substitutional atoms in cm&#94;-3 [D] real(kind=r64), public, allocatable :: subs_gfactors (:) g-factors for the substitutional defects. [D] integer(kind=i64), public, allocatable :: defect_hosts (:) Basis atom sites that can be a host for an impurity, one for each unique element. integer(kind=i64), public, allocatable :: numdopants_types (:) Number of dopant types at each host atom site. real(kind=r64), public, allocatable :: dopant_masses (:,:) Masses of the dopants at each host atom site. real(kind=r64), public, allocatable :: dopant_conc (:,:) Concentrations [cm&#94;-3] of the dopants at each host atom site. logical, public :: twod Is the system 2d? real(kind=r64), public :: dim Dimension of the system real(kind=r64), public :: thickness Thickness of the system real(kind=r64), public :: bound_length Characteristic boundary scattering length in mm real(kind=r64), public :: thinfilm_height Height of thin-film in mm character(len=1), public :: thinfilm_normal Normal direction of the thin-film: 'x', 'y', or 'z'. Type-Bound Procedures procedure, public :: initialize => read_input_and_setup_crystal private  subroutine read_input_and_setup_crystal(self) Read input file and initialize crystal data. Arguments Type Intent Optional Attributes Name class( crystal ), intent(out) :: self","tags":"","loc":"type/crystal.html"},{"title":"epw_wannier – elphbolt ","text":"type, public :: epw_wannier Data and procedures related to Wannierization. Contents Variables numwannbands numbranches nwsk coarse_qmesh nwsq nwsg rcells_k rcells_q rcells_g elwsdeg phwsdeg gwsdeg Hwann Dphwann gwann Type-Bound Procedures plot_along_path deallocate_wannier g2_epw gReq_epw gkRp_epw ph_wann_epw el_wann_epw read Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numwannbands Number of Wannier bands. integer(kind=i64), public :: numbranches Number of phonon branches. integer(kind=i64), public :: nwsk Number of real space cells for electrons. integer(kind=i64), public :: coarse_qmesh (3) Coarse phonon wave vector mesh in Wannier calculation. integer(kind=i64), public :: nwsq Number of real space cells for phonons. integer(kind=i64), public :: nwsg Number of real space cells for electron-phonon vertex. integer(kind=i64), public, allocatable :: rcells_k (:,:) Real space cell locations for electrons. integer(kind=i64), public, allocatable :: rcells_q (:,:) Real space cell locations for phonons. integer(kind=i64), public, allocatable :: rcells_g (:,:) Real space cell locations for electron-phonon vertex. integer(kind=i64), public, allocatable :: elwsdeg (:) Real space cell multiplicity for electrons. integer(kind=i64), public, allocatable :: phwsdeg (:) Real space cell multiplicity for phonons. integer(kind=i64), public, allocatable :: gwsdeg (:) Real space cell multiplicity for electron-phonon vertex. complex(kind=r64), public, allocatable :: Hwann (:,:,:) Hamiltonian in Wannier representation. complex(kind=r64), public, allocatable :: Dphwann (:,:,:) Dynamical matrix in Wannier representation. complex(kind=r64), public, allocatable :: gwann (:,:,:,:,:) e-ph vertex in Wannier representation. Type-Bound Procedures procedure, public :: plot_along_path private  subroutine plot_along_path(self, crys, num, scissor) Subroutine to plot bands, dispersions, e-ph matrix elements\nusing the Wannier interpolation method with EPW inputs. Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: self type( crystal ), intent(in) :: crys type( numerics ), intent(in) :: num real(kind=r64), intent(in) :: scissor (self%numwannbands) procedure, public :: deallocate_wannier private  subroutine deallocate_wannier(self, num) Deallocates some Wannier quantities Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(inout) :: self type( numerics ), intent(in) :: num procedure, public :: g2_epw private  function g2_epw(self, crys, kvec, qvec, el_evec_k, el_evec_kp, ph_evec_q, ph_en, gmixed, wannspace) Function to calculate |g|&#94;2.\nThis works with EPW real space data\nkvec: electron wave vector in crystal coords\nqvec: phonon wave vector in crystal coords\nel_evec_k(kp): initial(final) electron eigenvector in bands m(n) \nph_evec_q: phonon eigenvector branchs \nph_en: phonon energy in mode (s,qvec)\ngmixed: e-ph matrix element in mixed Wannier-Bloch representation\nwannspace: the species that is in Wannier representation Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: self type( crystal ), intent(in) :: crys real(kind=r64), intent(in) :: kvec (3) real(kind=r64), intent(in) :: qvec (3) complex(kind=r64), intent(in) :: el_evec_k (self%numwannbands) complex(kind=r64), intent(in) :: el_evec_kp (self%numwannbands) complex(kind=r64), intent(in) :: ph_evec_q (self%numbranches) real(kind=r64), intent(in) :: ph_en complex(kind=r64), intent(in) :: gmixed (:,:,:,:) character(len=2) :: wannspace Return Value real(kind=r64) procedure, public :: gReq_epw private  subroutine gReq_epw(self, num, iq, qvec) Calculate the Bloch-Wannier mixed rep. e-ph matrix elements g(Re,q),\nwhere q is an IBZ phonon wave vector and Re is a phonon unit cell.\nNote: this step DOES NOT perform the rotation over the Wannier bands space. The result will be saved to disk tagged with k-index. Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: self type( numerics ), intent(in) :: num integer(kind=i64), intent(in) :: iq real(kind=r64), intent(in) :: qvec (3) procedure, public :: gkRp_epw private  subroutine gkRp_epw(self, num, ik, kvec) Calculate the Bloch-Wannier mixed rep. e-ph matrix elements g(k,Rp),\nwhere k is an IBZ electron wave vector and Rp is a phonon unit cell.\nNote: this step DOES NOT perform the rotation over the Wannier bands space. The result will be saved to disk tagged with k-index. Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: self type( numerics ), intent(in) :: num integer(kind=i64), intent(in) :: ik real(kind=r64), intent(in) :: kvec (3) procedure, public :: ph_wann_epw private  subroutine ph_wann_epw(self, crys, nq, qvecs, energies, evecs) Wannier interpolate phonons on list of arb. q-vec Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: self type( crystal ), intent(in) :: crys integer(kind=i64), intent(in) :: nq real(kind=r64), intent(in) :: qvecs (nq,3) real(kind=r64), intent(out) :: energies (nq,self%numbranches) complex(kind=r64), intent(out), optional :: evecs (nq,self%numbranches,self%numbranches) procedure, public :: el_wann_epw private  subroutine el_wann_epw(self, crys, nk, kvecs, energies, velocities, evecs, scissor) Wannier interpolate electrons on list of arb. k-vecs Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(in) :: self type( crystal ), intent(in) :: crys integer(kind=i64), intent(in) :: nk real(kind=r64), intent(in) :: kvecs (nk,3) real(kind=r64), intent(out) :: energies (nk,self%numwannbands) real(kind=r64), intent(out), optional :: velocities (nk,self%numwannbands,3) complex(kind=r64), intent(out), optional :: evecs (nk,self%numwannbands,self%numwannbands) real(kind=r64), intent(in), optional :: scissor (self%numwannbands) procedure, public :: read => read_EPW_Wannier private  subroutine read_EPW_Wannier(self, num) Read Wannier representation of the hamiltonian, dynamical matrix, and the\ne-ph matrix elements from file epwdata.fmt. Arguments Type Intent Optional Attributes Name class( epw_wannier ), intent(out) :: self type( numerics ), intent(in) :: num","tags":"","loc":"type/epw_wannier.html"},{"title":"generic_parser – elphbolt","text":"abstract interface public  subroutine generic_parser(self) Arguments Type Intent Optional Attributes Name class( FC2 ), intent(in) :: self","tags":"","loc":"interface/generic_parser.html"},{"title":"cross_product – elphbolt","text":"public pure function cross_product(A, B) Cross product of A and B. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: A (3) real(kind=r64), intent(in) :: B (3) Return Value real(kind=r64), (3) Contents","tags":"","loc":"proc/cross_product.html"},{"title":"kronecker – elphbolt","text":"public pure function kronecker(i, j) Kronecker delta Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: i integer(kind=i64), intent(in) :: j Return Value integer(kind=i64) Contents","tags":"","loc":"proc/kronecker.html"},{"title":"expi – elphbolt","text":"public pure function expi(x) Calculate exp(i*x) = cos(x) + isin(x) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x Return Value complex(kind=r64) Contents","tags":"","loc":"proc/expi.html"},{"title":"trace – elphbolt","text":"public pure function trace(mat) Trace of square matrix Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: mat (:,:) Return Value real(kind=r64) Contents","tags":"","loc":"proc/trace.html"},{"title":"mux_vector – elphbolt","text":"public  function mux_vector(v, mesh, base) Multiplex index of a single wave vector.\nv is the demultiplexed triplet of a wave vector.\ni is the multiplexed index of a wave vector (always 1-based).\nmesh is the number of wave vectors along the three reciprocal lattice vectors.\nbase states whether v has 0- or 1-based indexing. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: v (3) integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: base Return Value integer(kind=i64) Contents","tags":"","loc":"proc/mux_vector.html"},{"title":"mux_state – elphbolt","text":"public pure function mux_state(nbands, iband, ik) Multiplex a (band index, wave vector index) pair into a state index nbands is the number of bands\niband is the band index\nik is the wave vector index Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: nbands integer(kind=i64), intent(in) :: iband integer(kind=i64), intent(in) :: ik Return Value integer(kind=i64) Contents","tags":"","loc":"proc/mux_state.html"},{"title":"Bose – elphbolt","text":"public pure function Bose(e, T) e Energy in eV\nT temperature in K Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: e real(kind=r64), intent(in) :: T Return Value real(kind=r64) Contents","tags":"","loc":"proc/bose.html"},{"title":"Fermi – elphbolt","text":"public pure function Fermi(e, chempot, T) e Energy in eV\nchempot Chemical potential in eV\nT temperature in K Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: e real(kind=r64), intent(in) :: chempot real(kind=r64), intent(in) :: T Return Value real(kind=r64) Contents","tags":"","loc":"proc/fermi.html"},{"title":"Pade_continued – elphbolt","text":"public pure function Pade_continued(iomegas, us, xs) Analytically continue from the upper imaginary plane to\nthe positive real axis by solving equation A3 of the following article:\nSolving the Eliashberg equations by means of N-point Pade' approximants\nVidberg and Serene Journal of Low Temperature Physics, Vol. 29, Nos. 3/4, 1977 Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: iomegas (:) real(kind=r64), intent(in) :: us (:) real(kind=r64), intent(in) :: xs (:) Return Value complex(kind=r64), (size(xs)) Contents","tags":"","loc":"proc/pade_continued.html"},{"title":"start_timer – elphbolt","text":"public  subroutine start_timer(self, event) Start/Reset the timer. This is a blocking call.\nOnly image 1 can modify timing information. Arguments Type Intent Optional Attributes Name class( timer ), intent(out) :: self character(len=*), intent(in) :: event Contents","tags":"","loc":"proc/start_timer.html"},{"title":"end_timer – elphbolt","text":"public  subroutine end_timer(self, event) End the timer and print the elapsed time. This is a blocking call.\nOnly image 1 can modify timing information. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: self character(len=*), intent(in) :: event Contents","tags":"","loc":"proc/end_timer.html"},{"title":"linspace – elphbolt","text":"public  subroutine linspace(grid, min, max, num) Create equidistant grid. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out), allocatable :: grid (:) real(kind=r64), intent(in) :: min real(kind=r64), intent(in) :: max integer(kind=i64), intent(in) :: num Contents","tags":"","loc":"proc/linspace.html"},{"title":"exit_with_message – elphbolt","text":"public  subroutine exit_with_message(message) Exit with error message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Contents","tags":"","loc":"proc/exit_with_message.html"},{"title":"print_message – elphbolt","text":"public  subroutine print_message(message) Print message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Contents","tags":"","loc":"proc/print_message.html"},{"title":"write2file_rank1_real – elphbolt","text":"public  subroutine write2file_rank1_real(filename, data) Write rank-1 data to file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(in) :: data (:) Contents","tags":"","loc":"proc/write2file_rank1_real.html"},{"title":"write2file_rank2_real – elphbolt","text":"public  subroutine write2file_rank2_real(filename, data) Write rank-2 data to file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(in) :: data (:,:) Contents","tags":"","loc":"proc/write2file_rank2_real.html"},{"title":"write2file_rank3_real – elphbolt","text":"public  subroutine write2file_rank3_real(filename, data) Write rank-3 data to file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(in) :: data (:,:,:) Contents","tags":"","loc":"proc/write2file_rank3_real.html"},{"title":"write2file_response – elphbolt","text":"public  subroutine write2file_response(filename, data, bandlist) Write list of vectors to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(in) :: data (:,:,:) integer(kind=i64), intent(in), optional :: bandlist (:) Contents","tags":"","loc":"proc/write2file_response.html"},{"title":"readfile_response – elphbolt","text":"public  subroutine readfile_response(filename, data, bandlist) Read list of vectors to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(out) :: data (:,:,:) integer(kind=i64), intent(in), optional :: bandlist (:) Contents","tags":"","loc":"proc/readfile_response.html"},{"title":"append2file_transport_tensor – elphbolt","text":"public  subroutine append2file_transport_tensor(filename, it, data, bandlist) Append 3x3 tensor to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=i64), intent(in) :: it real(kind=r64), intent(in) :: data (:,:,:) integer(kind=i64), intent(in), optional :: bandlist (:) Contents","tags":"","loc":"proc/append2file_transport_tensor.html"},{"title":"write2file_spectral_tensor – elphbolt","text":"public  subroutine write2file_spectral_tensor(filename, data, bandlist) Append 3x3 spectral transport tensor to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(in) :: data (:,:,:,:) integer(kind=i64), intent(in), optional :: bandlist (:) Contents","tags":"","loc":"proc/write2file_spectral_tensor.html"},{"title":"int_div – elphbolt","text":"public  subroutine int_div(num, denom, q, r) Quotient(q) and remainder(r) of the integer division num/denom. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: num integer(kind=i64), intent(in) :: denom integer(kind=i64), intent(out) :: q integer(kind=i64), intent(out) :: r Contents","tags":"","loc":"proc/int_div.html"},{"title":"distribute_points – elphbolt","text":"public  subroutine distribute_points(npts, chunk, istart, iend, num_active_images) Distribute points among processes Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: npts integer(kind=i64), intent(out) :: chunk integer(kind=i64), intent(out) :: istart integer(kind=i64), intent(out) :: iend integer(kind=i64), intent(out) :: num_active_images Contents","tags":"","loc":"proc/distribute_points.html"},{"title":"binsearch – elphbolt","text":"public  subroutine binsearch(array, e, m) Binary search in a list of integers and return index. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: array (:) integer(kind=i64), intent(in) :: e integer(kind=i64), intent(out) :: m Contents","tags":"","loc":"proc/binsearch.html"},{"title":"compsimps – elphbolt","text":"public  subroutine compsimps(f, h, s) Composite Simpson's rule for real function\nf integrand\nh integration variable spacing\ns result Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: f (:) real(kind=r64), intent(in) :: h real(kind=r64), intent(out) :: s Contents","tags":"","loc":"proc/compsimps.html"},{"title":"demux_vector – elphbolt","text":"public  subroutine demux_vector(i, v, mesh, base) Demultiplex index of a single wave vector.\ni is the multiplexed index of a wave vector (always 1-based).\nv is the demultiplexed triplet of a wave vector.\nmesh is the number of wave vectors along the three reciprocal lattice vectors.\nbase chooses whether v has 0- or 1-based indexing. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: i integer(kind=i64), intent(out) :: v (3) integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: base Contents","tags":"","loc":"proc/demux_vector.html"},{"title":"demux_mesh – elphbolt","text":"public  subroutine demux_mesh(index_mesh, nmesh, mesh, base, indexlist) Demultiplex all wave vector indices \n(optionally, from a list of indices).\nInternally uses demux_vector. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(out) :: index_mesh (3,nmesh) integer(kind=i64), intent(in) :: nmesh integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: base integer(kind=i64), intent(in), optional :: indexlist (nmesh) Contents","tags":"","loc":"proc/demux_mesh.html"},{"title":"demux_state – elphbolt","text":"public  subroutine demux_state(m, nbands, iband, ik) Demultiplex a state index into (band index, wave vector index) pair m is the multiplexed state index\nnbands is the number of bands\niband is the band index\nik is the wave vector index Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: m integer(kind=i64), intent(in) :: nbands integer(kind=i64), intent(out) :: iband integer(kind=i64), intent(out) :: ik Contents","tags":"","loc":"proc/demux_state.html"},{"title":"interpolate – elphbolt","text":"public  subroutine interpolate(coarsemesh, refinement, f, q, interpolation) Subroutine to perform BZ interpolation. coarsemesh The coarse mesh.\nrefinement The mesh refinement factor.\nf The coarse mesh function to be interpolated.\nq The 0-based index vector where to evaluate f.\ninterpolation The result Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: coarsemesh (3) integer(kind=i64), intent(in) :: refinement (3) real(kind=r64), intent(in) :: f (:) integer(kind=i64), intent(in) :: q (3) real(kind=r64), intent(out) :: interpolation Contents","tags":"","loc":"proc/interpolate.html"},{"title":"welcome – elphbolt","text":"public  subroutine welcome() Subroutine to print a pretty banner. Arguments None Contents None","tags":"","loc":"proc/welcome.html"},{"title":"subtitle – elphbolt","text":"public  subroutine subtitle(text) Subroutine to print a subtitle. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Contents","tags":"","loc":"proc/subtitle.html"},{"title":"sort – elphbolt","text":"public interface sort Contents Module Procedures sort_int sort_real Module Procedures private  subroutine sort_int(list) Swap sort list of integers Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: list (:) private  subroutine sort_real(list) Swap sort list of reals Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: list (:)","tags":"","loc":"interface/sort.html"},{"title":"twonorm – elphbolt","text":"public interface twonorm Contents Module Procedures twonorm_real_rank1 twonorm_real_rank2 Module Procedures private pure function twonorm_real_rank1(v) 2-norm of a rank-1 real vector Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: v (:) Return Value real(kind=r64) private pure function twonorm_real_rank2(T) Custom 2-norm of a rank-2 real tensor Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: T (:,:) Return Value real(kind=r64)","tags":"","loc":"interface/twonorm.html"},{"title":"invert – elphbolt","text":"public interface invert Contents Module Procedures invert_complex_square Module Procedures private  subroutine invert_complex_square(mat) Wrapper for lapack complex matrix inversion Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout) :: mat (:,:)","tags":"","loc":"interface/invert.html"},{"title":"get_num_operations – elphbolt","text":"public  function get_num_operations(lattice, natoms, types, positions) Return the number of symmetry operations. Useful for allocating\nmemory for get_operations(). Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), dimension(3,3) :: lattice integer(kind=i64), intent(in) :: natoms integer(kind=i64), intent(in), dimension(natoms) :: types real(kind=r64), intent(in), dimension(3,natoms) :: positions Return Value integer(kind=i64) Contents","tags":"","loc":"proc/get_num_operations.html"},{"title":"get_operations – elphbolt","text":"public  subroutine get_operations(lattice, natoms, types, positions, nops, rotations, translations, international) Return the matrix and vector representations of the symmetry\noperations of the system. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), dimension(3,3) :: lattice integer(kind=i64), intent(in) :: natoms integer(kind=i64), intent(in), dimension(natoms) :: types real(kind=r64), intent(in), dimension(3,natoms) :: positions integer(kind=i64), intent(inout) :: nops integer(kind=i64), intent(out), dimension(3,3,nops) :: rotations real(kind=r64), intent(out), dimension(3,nops) :: translations character(len=10), intent(out) :: international Contents","tags":"","loc":"proc/get_operations.html"},{"title":"get_cartesian_operations – elphbolt","text":"public  subroutine get_cartesian_operations(lattice, nops, rotations, translations, crotations, ctranslations) Return the Cartesian components of the rotations and translations\nreturned by get_operations(). Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), dimension(3,3) :: lattice integer(kind=i64), intent(in) :: nops integer(kind=i64), intent(in), dimension(3,3,nops) :: rotations real(kind=r64), intent(in), dimension(3,nops) :: translations real(kind=r64), intent(out), dimension(3,3,nops) :: crotations real(kind=r64), intent(out), dimension(3,nops) :: ctranslations Contents","tags":"","loc":"proc/get_cartesian_operations.html"},{"title":"spg_get_symmetry – elphbolt","text":"interface public  function spg_get_symmetry(rotations, translations, nops, lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_symmetry\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), dimension(3,3,nops) :: rotations real(kind=C_DOUBLE), dimension(3,nops) :: translations integer(kind=C_INT), value :: nops real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT)","tags":"","loc":"interface/spg_get_symmetry.html"},{"title":"spg_get_international – elphbolt","text":"interface public  function spg_get_international(symbol, lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_international\") Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), dimension(11) :: symbol real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT)","tags":"","loc":"interface/spg_get_international.html"},{"title":"spg_get_multiplicity – elphbolt","text":"interface public  function spg_get_multiplicity(lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_multiplicity\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT)","tags":"","loc":"interface/spg_get_multiplicity.html"},{"title":"set_format – elphbolt","text":"public  function set_format(self, format_name) result(fc2_type) Arguments Type Intent Optional Attributes Name class( FC2_parser_factory ) :: self character(len=*), intent(in) :: format_name Return Value class( FC2 ), pointer Contents","tags":"","loc":"proc/set_format.html"},{"title":"qe_parser – elphbolt","text":"interface public module subroutine qe_parser(self) Arguments Type Intent Optional Attributes Name class( fc2_qe ), intent(in) :: self","tags":"","loc":"interface/qe_parser.html"},{"title":"siesta_parser – elphbolt","text":"interface public module subroutine siesta_parser(self) Arguments Type Intent Optional Attributes Name class( fc2_siesta ), intent(in) :: self","tags":"","loc":"interface/siesta_parser.html"},{"title":"calculate_a2F – elphbolt","text":"public  subroutine calculate_a2F(wann, el, ph, num, omegas, iso_lambda0, omegalog, external_eps_switch) Parallel driver of a2F_mk(nk'|sq) over IBZ electron states.\nOther zero temperature quantities such as the isotropic electron-phonon\ncoupling (lambda0) and the log-averaged boson energy (omegalog) are\nalso calculated here. This subroutine will calculate the anisotropic Eliashberg spectral function for\nall the energy window restricted electron-phonon processes for a given\nirreducible initial electron state = (band, wave vector). \nThis list will be written to disk in files tagged with the muxed state index. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( electron ), intent(in) :: el type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num real(kind=r64), intent(in) :: omegas (:) real(kind=r64), intent(out) :: iso_lambda0 real(kind=r64), intent(out) :: omegalog logical, intent(in), optional :: external_eps_switch Contents","tags":"","loc":"proc/calculate_a2f.html"},{"title":"calculate_iso_Matsubara_lambda – elphbolt","text":"public  subroutine calculate_iso_Matsubara_lambda(wann, num, omegas, bose_matsubara_ens, iso_matsubara_lambda) Calculate the isotropic Matsubara electron-phonon coupling, lambda(l).\nHere l is the Bosonic Matsubara energy index. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( numerics ), intent(in) :: num real(kind=r64), intent(in) :: omegas (:) real(kind=r64), intent(in) :: bose_matsubara_ens (:) real(kind=r64), intent(out) :: iso_matsubara_lambda (:) Contents","tags":"","loc":"proc/calculate_iso_matsubara_lambda.html"},{"title":"calculate_aniso_Matsubara_lambda – elphbolt","text":"public  subroutine calculate_aniso_Matsubara_lambda(wann, num, el, omegas, bose_matsubara_ens) Parallel driver of lambda_mk(nk'|sq, l) over IBZ electron states.\nHere l is the Bosonic Matsubara energy index. This subroutine will calculate the anisotropic e-ph coupling function for\nall the energy window restricted electron-phonon processes for a given\nirreducible initial electron state = (band, wave vector). \nThis list will be written to disk in files tagged with the muxed state index. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( numerics ), intent(in) :: num type( electron ), intent(in) :: el real(kind=r64), intent(in) :: omegas (:) real(kind=r64), intent(in) :: bose_matsubara_ens (:) Contents","tags":"","loc":"proc/calculate_aniso_matsubara_lambda.html"},{"title":"calculate_3ph_interaction – elphbolt","text":"public  subroutine calculate_3ph_interaction(ph, crys, num, key) Parallel driver of the 3-ph vertex calculator for all IBZ phonon wave vectors.\nThis subroutine calculates |V-(s1 |s2q2,s3q3)|&#94;2, W-(s1 |s2q2,s3q3),\nand W+(s1 |s2q2,s3q3) for each irreducible phonon and saves the results to disk. key = 'V', 'W' for vertex, transition probabilitiy calculation, respectively. Arguments Type Intent Optional Attributes Name type( phonon ), intent(in) :: ph type( crystal ), intent(in) :: crys type( numerics ), intent(in) :: num character(len=1), intent(in) :: key Contents","tags":"","loc":"proc/calculate_3ph_interaction.html"},{"title":"calculate_gReq – elphbolt","text":"public  subroutine calculate_gReq(wann, ph, num) Parallel driver of gReq_epw over IBZ phonon wave vectors. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num Contents","tags":"","loc":"proc/calculate_greq.html"},{"title":"calculate_gkRp – elphbolt","text":"public  subroutine calculate_gkRp(wann, el, num) Parallel driver of gkRp_epw over IBZ electron wave vectors. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( electron ), intent(in) :: el type( numerics ), intent(in) :: num Contents","tags":"","loc":"proc/calculate_gkrp.html"},{"title":"calculate_eph_interaction_ibzq – elphbolt","text":"public  subroutine calculate_eph_interaction_ibzq(wann, crys, el, ph, num, key) Parallel driver of g2(q,k) over IBZ phonon states. This subroutine will calculate the full Bloch rep. matrix elements for\nall the energy window restricted electron-phonon processes for a given\nirreducible initial phonon state = (branch, wave vector). \nThis list will be written to disk in files tagged with the muxed state index. key = 'g', 'Y' for vertex, transition probability calculation, respectively. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num character(len=1), intent(in) :: key Contents","tags":"","loc":"proc/calculate_eph_interaction_ibzq.html"},{"title":"calculate_eph_interaction_ibzk – elphbolt","text":"public  subroutine calculate_eph_interaction_ibzk(wann, crys, el, ph, num, key) Parallel driver of g2(k,q) over IBZ electron states. This subroutine will calculate the full Bloch rep. matrix elements for\nall the energy window restricted electron-phonon processes for a given\nirreducible initial electron state = (band, wave vector). \nThis list will be written to disk in files tagged with the muxed state index. key = 'g', 'X' for vertex, transition probability calculation, respectively. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num character(len=1), intent(in) :: key Contents","tags":"","loc":"proc/calculate_eph_interaction_ibzk.html"},{"title":"calculate_echimp_interaction_ibzk – elphbolt","text":"public  subroutine calculate_echimp_interaction_ibzk(crys, el, num) Parallel driver of |g_e-chimp(k,k')|&#94;2 over IBZ electron states. Arguments Type Intent Optional Attributes Name type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( numerics ), intent(in) :: num Contents","tags":"","loc":"proc/calculate_echimp_interaction_ibzk.html"},{"title":"calculate_ph_rta_rates – elphbolt","text":"public  subroutine calculate_ph_rta_rates(rta_rates_3ph, rta_rates_phe, num, crys, ph, el) Subroutine for parallel reading of the 3-ph and ph-e transition probabilities\nfrom disk and calculating the relaxation time approximation (RTA)\nscattering rates for the 3-ph and ph-e channels. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out), allocatable :: rta_rates_3ph (:,:) real(kind=r64), intent(out), allocatable :: rta_rates_phe (:,:) type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( phonon ), intent(in) :: ph type( electron ), intent(in), optional :: el Contents","tags":"","loc":"proc/calculate_ph_rta_rates.html"},{"title":"calculate_4ph_rta_rates – elphbolt","text":"public  subroutine calculate_4ph_rta_rates(rta_rates, num, crys, ph) Subroutine for interporlating 4-ph scattering rates from an\nexternal coarser mesh calculation. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out), allocatable :: rta_rates (:,:) type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( phonon ), intent(in) :: ph Contents","tags":"","loc":"proc/calculate_4ph_rta_rates.html"},{"title":"calculate_el_rta_rates – elphbolt","text":"public  subroutine calculate_el_rta_rates(rta_rates_eph, rta_rates_echimp, num, crys, el) Subroutine for parallel reading of the e-ph transition probabilities\nfrom disk and calculating the relaxation time approximation (RTA)\nscattering rates for the e-ph channel. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out), allocatable :: rta_rates_eph (:,:) real(kind=r64), intent(out), allocatable :: rta_rates_echimp (:,:) type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el Contents","tags":"","loc":"proc/calculate_el_rta_rates.html"},{"title":"read_transition_probs_e – elphbolt","text":"public  subroutine read_transition_probs_e(filepath, N, TP, istate1, istate2) Subroutine to read transition probabilities from disk for interaction processes. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath integer(kind=i64), intent(out) :: N real(kind=r64), intent(out), allocatable :: TP (:) integer(kind=i64), intent(out), optional, allocatable :: istate1 (:) integer(kind=i64), intent(out), optional, allocatable :: istate2 (:) Contents","tags":"","loc":"proc/read_transition_probs_e.html"},{"title":"calculate_bound_scatt_rates – elphbolt","text":"public  subroutine calculate_bound_scatt_rates(prefix, finite_crys, length, vels_fbz, indexlist_irred, scatt_rates) Subroutine to calculate the phonon/electron-boundary scattering rates. prefix Type of particle\nfinite_crys Is the crystal finite?\nlength Characteristic boundary scattering length scale in mm\nvels Velocities on the FBZ\nindexlist_irred List of muxed indices of the IBZ wedge.\nscatt_rates Boundary scattering rates on the IBZ Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: prefix logical, intent(in) :: finite_crys real(kind=r64), intent(in) :: length real(kind=r64), intent(in) :: vels_fbz (:,:,:) integer(kind=i64), intent(in) :: indexlist_irred (:) real(kind=r64), intent(out), allocatable :: scatt_rates (:,:) Contents","tags":"","loc":"proc/calculate_bound_scatt_rates.html"},{"title":"calculate_thinfilm_scatt_rates – elphbolt","text":"public  subroutine calculate_thinfilm_scatt_rates(prefix, finite_crys, height, normal, vels_fbz, indexlist_irred, scatt_rates) Subroutine to calculate the phonon/electron-thin-film scattering rates. prefix Type of particle\nfinite_crys Is the crystal finite?\nheight Height of thin-film in mm\nnormal Normal direction to thin-film\nvels Velocities on the FBZ\nindexlist_irred List of muxed indices of the IBZ wedge.\nscatt_rates Thin-film scattering rates on the IBZ Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: prefix logical, intent(in) :: finite_crys real(kind=r64), intent(in) :: height character(len=1), intent(in) :: normal real(kind=r64), intent(in) :: vels_fbz (:,:,:) integer(kind=i64), intent(in) :: indexlist_irred (:) real(kind=r64), intent(out), allocatable :: scatt_rates (:,:) Contents","tags":"","loc":"proc/calculate_thinfilm_scatt_rates.html"},{"title":"calculate_retarded_phonon_D0 – elphbolt","text":"public  subroutine calculate_retarded_phonon_D0(ph, crys, def_supercell_cell_pos_intvec, pcell_atom_label, D0, dimp_cell_pos_intvec, pcell_atom_dof) Parallel driver of the retarded, bare phonon Green's function, D0, over\n the IBZ states. ph Phonon object\n crys Crystal object\n def_supercell_cell_pos_intvec Positions of unitcells (integer 3 vector) in the defective supercell\n pcell_atom_label Primitive cell equivalence of atom labels in the defective supercell\n D0 Green's function $    !Sanity check: print DOS\n$    dos = 0.0_r64\n$    do istate1 = start, end\n$       !Demux state index into branch (s) and wave vector (iq) indices\n$       call demux_state(istate1, ph%numbands, s1, iq1_ibz)\n$\n$       iq1 = ph%indexlist_irred(iq1_ibz)\n$\n$       do i = 1, num_dof_def\n$          dos(iq1_ibz, s1) = dos(iq1_ibz, s1) + &\n$               D0(i, i, istate1)\n$       end do\n$ $       dos(iq1_ibz, s1) = dos(iq1_ibz, s1) ph%ens(iq1, s1)\n$    end do\n$\n$    !Reduce dos\n$    sync all\n$    call co_sum(dos)\n$    sync all\n$ $    call write2file_rank2_real(ph%prefix // '.D0test_'//ph%prefix//'dos', imag(-2.0/pi dos))\n$    sync all\n$    !! Arguments Type Intent Optional Attributes Name type( phonon ), intent(in) :: ph type( crystal ), intent(in) :: crys integer(kind=i64), intent(in) :: def_supercell_cell_pos_intvec (:,:) integer(kind=i64), intent(in) :: pcell_atom_label (:) complex(kind=r64), intent(out), allocatable :: D0 (:,:,:) integer(kind=i64), intent(in) :: dimp_cell_pos_intvec (:,:) integer(kind=i64), intent(in) :: pcell_atom_dof (:) Contents","tags":"","loc":"proc/calculate_retarded_phonon_d0.html"},{"title":"delta_fn_tetra – elphbolt","text":"public pure function delta_fn_tetra(e, ik, ib, mesh, tetramap, tetracount, tetra_evals) Calculate delta function using the tetraheron method. e Sample energy\nik Wave vector index\nib Band index\nmesh Wave vector grid\ntetramap Wave vector to (tetrahedron, vertex) mapping\ntetracount Number of tetrahedra in which a wave vector belongs\ntetra_evals Tetrahedra populated with the eigenvalues Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: e integer(kind=i64), intent(in) :: ik integer(kind=i64), intent(in) :: ib integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: tetramap (:,:,:) integer(kind=i64), intent(in) :: tetracount (:) real(kind=r64), intent(in) :: tetra_evals (:,:,:) Return Value real(kind=r64) Contents","tags":"","loc":"proc/delta_fn_tetra.html"},{"title":"real_tetra – elphbolt","text":"public pure function real_tetra(e, ik, ib, mesh, tetramap, tetracount, tetra_evals) Calculate the real part of the matrix elements of the resolvent operator\nusing the analytic tetraheron method.\nLambin and Vigneron Phys. Rev. B 29 6 1984 Eqs. A3-A6\nNote that typos in Eqs. A4 and A5 have been corrected.\nHere we use the expressions given in\nV. Eyert The Augmented Spherical Wave Method DOI 10.1007/978-3-642-25864-0. e Sample energy\nik Wave vector index\nib Band index\nmesh Wave vector grid\ntetramap Wave vector to (tetrahedron, vertex) mapping\ntetracount Number of tetrahedra in which a wave vector belongs\ntetra_evals Tetrahedra populated with the eigenvalues Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: e integer(kind=i64), intent(in) :: ik integer(kind=i64), intent(in) :: ib integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: tetramap (:,:,:) integer(kind=i64), intent(in) :: tetracount (:) real(kind=r64), intent(in) :: tetra_evals (:,:,:) Return Value real(kind=r64) Contents","tags":"","loc":"proc/real_tetra.html"},{"title":"delta_fn_triang – elphbolt","text":"public pure function delta_fn_triang(e, ik, ib, mesh, triangmap, triangcount, triang_evals) Calculate delta function using the triangle method a la\nKurganskii et al. Phys. Stat. Sol.(b) 129, 293 (1985) e Sample energy\nik Wave vector index\nib Band index\nmesh Wave vector grid\ntriangmap Wave vector to (triangle, vertex) mapping\ntriangcount Number of triangles in which a wave vector belongs\ntriang_evals Triangles populated with the eigenvalues Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: e integer(kind=i64), intent(in) :: ik integer(kind=i64), intent(in) :: ib integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: triangmap (:,:,:) integer(kind=i64), intent(in) :: triangcount (:) real(kind=r64), intent(in) :: triang_evals (:,:,:) Return Value real(kind=r64) Contents","tags":"","loc":"proc/delta_fn_triang.html"},{"title":"form_tetrahedra_3d – elphbolt","text":"public  subroutine form_tetrahedra_3d(nk, mesh, tetra, tetracount, tetramap, blocks, indexlist) Form all the tetrahedra of a 3d FBZ mesh. nk Number of points in the list of FBZ wave vectors\nmesh Wave vector grid\ntetra List of the tetrahedra vertices\ntetracount Number of tetrahedra in which a wave vector belongs\ntetramap Wave vector to (tetrahedron, vertex) mapping\nblocks Is the FBZ wave vector list full or energy restricted?\nindexlist List of muxed indices of the FBZ wave vectors Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: nk integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(out), allocatable :: tetra (:,:) integer(kind=i64), intent(out), allocatable :: tetracount (:) integer(kind=i64), intent(out), allocatable :: tetramap (:,:,:) logical, intent(in) :: blocks integer(kind=i64), intent(in), optional :: indexlist (:) Contents","tags":"","loc":"proc/form_tetrahedra_3d.html"},{"title":"fill_tetrahedra_3d – elphbolt","text":"public  subroutine fill_tetrahedra_3d(tetra, evals, tetra_evals) Populate the (sorted along the vertices) eigenvalues on all the vertices of the tetrahedra tetra List of the tetrahedra vertices\nevals List of eigenvalues \ntetra_evals Tetrahedra populated with the eigenvalues Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: tetra (:,:) real(kind=r64), intent(in) :: evals (:,:) real(kind=r64), intent(out), allocatable :: tetra_evals (:,:,:) Contents","tags":"","loc":"proc/fill_tetrahedra_3d.html"},{"title":"form_triangles – elphbolt","text":"public  subroutine form_triangles(nk, mesh, triang, triangcount, triangmap, blocks, indexlist) Form all the triangles of a 3d FBZ mesh for each z component. nk Number of points in the list of FBZ wave vectors\nmesh Wave vector grid\ntriang List of the triangle vertices\ntriangcount Number of triangles in which a wave vector belongs\ntriangmap Wave vector to (triangle, vertex) mapping\nblocks Is the FBZ wave vector list full or energy restricted?\nindexlist List of muxed indices of the FBZ wave vectors Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: nk integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(out), allocatable :: triang (:,:) integer(kind=i64), intent(out), allocatable :: triangcount (:) integer(kind=i64), intent(out), allocatable :: triangmap (:,:,:) logical, intent(in) :: blocks integer(kind=i64), intent(in), optional :: indexlist (:) Contents","tags":"","loc":"proc/form_triangles.html"},{"title":"fill_triangles – elphbolt","text":"public  subroutine fill_triangles(triang, evals, triang_evals) Populate the (sorted along the vertices) eigenvalues on all the vertices of the triangles triang List of the triangle vertices\nevals List of eigenvalues \ntriang_evals Triangles populated with the eigenvalues Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: triang (:,:) real(kind=r64), intent(in) :: evals (:,:) real(kind=r64), intent(out), allocatable :: triang_evals (:,:,:) Contents","tags":"","loc":"proc/fill_triangles.html"},{"title":"fbz2ibz – elphbolt","text":"public  function fbz2ibz(iwvmux, nwv_irred, nequiv, ibz2fbz_map) Find index in IBZ blocks list for a given FBZ blocks muxed vector index Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: iwvmux integer(kind=i64), intent(in) :: nwv_irred integer(kind=i64), intent(in) :: nequiv (nwv_irred) integer(kind=i64), intent(in) :: ibz2fbz_map (:,:,:) Return Value integer(kind=i64) Contents","tags":"","loc":"proc/fbz2ibz.html"},{"title":"find_equiv_map – elphbolt","text":"public  subroutine find_equiv_map(nsymm_rot, equiv_map, mesh, qrotations, indexlist) Subroutine to create the map of equivalent wave vectors. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: nsymm_rot integer(kind=i64), intent(out) :: equiv_map (:,:) integer(kind=i64), intent(in) :: mesh (3) real(kind=r64), intent(in) :: qrotations (:,:,:) integer(kind=i64), intent(in), optional :: indexlist (:) Contents","tags":"","loc":"proc/find_equiv_map.html"},{"title":"find_irred_wedge – elphbolt","text":"public  subroutine find_irred_wedge(mesh, nwavevecs_irred, wavevecs_irred, indexlist_irred, nequivalent, nsymm_rot, qrotations, ibz2fbz_map, equivalence_map, blocks, indexlist) Find the irreducible wedge of the FBZ and other quantities.\nWedge finding algorithm is inspired by ShengBTE. mesh is the array of number of points along the reciprocal lattice vectors\nnwavevecs_irred is the number of irreducible vectors\nwavevecs_irred are the irreducible vectors\nindexlist_irred is the list containing the muxed indices of the irreducible wave vectors\nnequivalent lists the number of equivalent points of each irreducible point\nibz2fbz_map contains the map from an irreducible BZ (IBZ) vector to its FBZ images\n  The third axis contains the pair (symmetry index, image)\nequivalence_map is a map of the equivalent points under rotations\nblocks chooses whether the FBZ is energy restricted or not\nindexlist is the sorted list of indices of the wavevectors\n  in the energy restricted FBZ which must be present if blocks is true Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(out) :: nwavevecs_irred real(kind=r64), intent(out), allocatable :: wavevecs_irred (:,:) integer(kind=i64), intent(out), allocatable :: indexlist_irred (:) integer(kind=i64), intent(out), allocatable :: nequivalent (:) integer(kind=i64), intent(in) :: nsymm_rot real(kind=r64), intent(in) :: qrotations (:,:,:) integer(kind=i64), intent(out), allocatable :: ibz2fbz_map (:,:,:) integer(kind=i64), intent(out), allocatable :: equivalence_map (:,:) logical, intent(in) :: blocks integer(kind=i64), intent(in), optional :: indexlist (:) Contents","tags":"","loc":"proc/find_irred_wedge.html"},{"title":"create_fbz2ibz_map – elphbolt","text":"public  subroutine create_fbz2ibz_map(fbz2ibz_map, nwv, nwv_irred, indexlist, nequiv, ibz2fbz_map) Subroutine to create map of FBZ blocks to IBZ blocks Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(out), allocatable :: fbz2ibz_map (:) integer(kind=i64), intent(in) :: nwv integer(kind=i64), intent(in) :: nwv_irred integer(kind=i64), intent(in) :: indexlist (nwv) integer(kind=i64), intent(in) :: nequiv (nwv_irred) integer(kind=i64), intent(in) :: ibz2fbz_map (:,:,:) Contents","tags":"","loc":"proc/create_fbz2ibz_map.html"},{"title":"symmetrize_3x3_tensor – elphbolt","text":"public  subroutine symmetrize_3x3_tensor(tensor, crotations) Symmetrize a 3x3 tensor. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: tensor (3,3) real(kind=r64), intent(in) :: crotations (:,:,:) Contents","tags":"","loc":"proc/symmetrize_3x3_tensor.html"},{"title":"calculate_qTF – elphbolt","text":"public  subroutine calculate_qTF(crys, el) Calculate Thomas-Fermi screening wavevector in the simple electron-gas model. Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: crys type( electron ), intent(in) :: el Contents","tags":"","loc":"proc/calculate_qtf.html"},{"title":"calculate_el_dos_Fermi – elphbolt","text":"public  subroutine calculate_el_dos_Fermi(el, usetetra) Calculate spin-normalized electron density of states at the Fermi level el Electron data type\nusetetra Use the tetrahedron method for delta functions? Arguments Type Intent Optional Attributes Name type( electron ), intent(inout) :: el logical, intent(in) :: usetetra Contents","tags":"","loc":"proc/calculate_el_dos_fermi.html"},{"title":"calculate_el_Ws – elphbolt","text":"public  subroutine calculate_el_Ws(el, usetetra) Calculate all electron delta functions scaled by spin-normalized DOS(Ef)\nW_mk = delta[E_mk - Ef]/DOS(Ef) Arguments Type Intent Optional Attributes Name type( electron ), intent(inout) :: el logical, intent(in) :: usetetra Contents","tags":"","loc":"proc/calculate_el_ws.html"},{"title":"calculate_transport_coeff – elphbolt","text":"public  subroutine calculate_transport_coeff(species_prefix, field, T, deg, chempot, ens, vels, volume, mesh, response, sym, trans_coeff_hc, trans_coeff_cc) Subroutine to calculate transport coefficients. species_prefix Prefix of particle type\nfield Type of field\nT Temperature in K\ndeg Degeneracy\nchempot Chemical potential in eV\nens FBZ energies in eV\nvels FBZ velocities in Km/s\nvolume Primitive cell volume in nm&#94;3\nmesh Wave vector grid\nresponse FBZ response function\nsym Symmery object\ntrans_coeff_hc Heat current coefficient\ntrans_coeff_cc Charge current coefficient Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: species_prefix character(len=1), intent(in) :: field real(kind=r64), intent(in) :: T integer(kind=i64), intent(in) :: deg real(kind=r64), intent(in) :: chempot real(kind=r64), intent(in) :: ens (:,:) real(kind=r64), intent(in) :: vels (:,:,:) real(kind=r64), intent(in) :: volume integer(kind=i64), intent(in) :: mesh (3) real(kind=r64), intent(in) :: response (:,:,:) type( symmetry ), intent(in) :: sym real(kind=r64), intent(out) :: trans_coeff_hc (:,:,:) real(kind=r64), intent(out) :: trans_coeff_cc (:,:,:) Contents","tags":"","loc":"proc/calculate_transport_coeff.html"},{"title":"calculate_spectral_transport_coeff – elphbolt","text":"public  subroutine calculate_spectral_transport_coeff(species, field, T, deg, chempot, ens, vels, volume, response, en_grid, usetetra, sym, trans_coeff_hc, trans_coeff_cc) Subroutine to calculate the spectral transport coefficients. species Object of species type\nfield Type of field\nT Temperature in K\ndeg Degeneracy\nchempot Chemical potential in eV\nens FBZ energies in eV\nvels FBZ velocities in Km/s\nvolume Primitive cell volume in nm&#94;3\nusetetra Use tetrahedron method?\nsym Symmery object\ntrans_coeff_hc Heat current coefficient\ntrans_coeff_cc Charge current coefficient Arguments Type Intent Optional Attributes Name class(*), intent(in) :: species character(len=1), intent(in) :: field real(kind=r64), intent(in) :: T integer(kind=i64), intent(in) :: deg real(kind=r64), intent(in) :: chempot real(kind=r64), intent(in) :: ens (:,:) real(kind=r64), intent(in) :: vels (:,:,:) real(kind=r64), intent(in) :: volume real(kind=r64), intent(in) :: response (:,:,:) real(kind=r64), intent(in) :: en_grid (:) logical, intent(in) :: usetetra type( symmetry ), intent(in) :: sym real(kind=r64), intent(out) :: trans_coeff_hc (:,:,:,:) real(kind=r64), intent(out) :: trans_coeff_cc (:,:,:,:) Contents","tags":"","loc":"proc/calculate_spectral_transport_coeff.html"},{"title":"calculate_mfp_cumulative_transport_coeff – elphbolt","text":"public  subroutine calculate_mfp_cumulative_transport_coeff(species_prefix, field, T, deg, chempot, ens, vels, mesh, volume, response, mfp_grid_sampling, mfps, sym, trans_coeff_hc) Subroutine to calculate the mean-free-path cumulative transport coefficients. species_prefix Prefix of particle type\n field Type of field\n T Temperature in K\n deg Degeneracy\n chempot Chemical potential in eV\n ens FBZ energies in eV\n vels FBZ velocities in Km/s\n volume Primitive cell volume in nm&#94;3\n mesh Wave vector mesh\n response Response function (units depend of the specieas and the field type)\n mfp_grid Scalar mean-free-path sampling grid\n mfps Mode resolved mean-free-path\n sym Symmery object\n trans_coeff_hc Heat current coefficient\n trans_coeff_cc Charge current coefficient $          A_cc = 0.0_r64\n$          pow_cc = 0\n$          A_hc = -fac\n$          pow_hc = 1\n$          A_cc = 0.0_r64\n$          pow_cc = 0\n$       if(field == 'T') then\n$          A_cc = -deg qe fac\n$          pow_cc = 0\n$          A_hc = deg qe fac\n$          pow_hc = 1\n$       else if(field == 'E') then\n$          A_cc = deg fac\n$          pow_cc = 0\n$          A_hc = -A_cc\n$          pow_hc = 1\n$       else\n$          call exit_with_message(\"Unknown field type in calculate_mfp_cumulative_transport_coeff. Exiting.\")\n$       end if\n$    trans_coeff_cc = 0.0_r64\n$             dist_factor = Fermi(e, chempot, T)\n$             dist_factor = dist_factor (1.0_r64 - dist_factor)\n$                if(A_cc /= 0.0_r64) then\n$                   trans_coeff_cc(ib, icart, :) = trans_coeff_cc(ib, icart, :) + &\n$                        (e - chempot) pow_cc dist_factor v response(ik, ib, :)\n$                end if\n$    if(A_cc /= 0.0_r64) trans_coeff_cc = A_cc trans_coeff_cc $          if(A_cc /= 0.0_r64) call symmetrize_3x3_tensor(trans_coeff_cc(ib, :, :, imfp), sym%crotations) Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: species_prefix character(len=1), intent(in) :: field real(kind=r64), intent(in) :: T integer(kind=i64), intent(in) :: deg real(kind=r64), intent(in) :: chempot real(kind=r64), intent(in) :: ens (:,:) real(kind=r64), intent(in) :: vels (:,:,:) integer(kind=i64), intent(in) :: mesh (3) real(kind=r64), intent(in) :: volume real(kind=r64), intent(in) :: response (:,:,:) real(kind=r64), intent(in) :: mfp_grid_sampling (:) real(kind=r64), intent(in) :: mfps (:,:) type( symmetry ), intent(in) :: sym real(kind=r64), intent(out) :: trans_coeff_hc (:,:,:,:) Contents","tags":"","loc":"proc/calculate_mfp_cumulative_transport_coeff.html"},{"title":"calculate_dos – elphbolt","text":"public interface calculate_dos Contents Module Procedures calculate_el_dos calculate_ph_dos_iso Module Procedures private  subroutine calculate_el_dos(el, usetetra) Calculate the density of states (DOS) in units of 1/energy. \nThe DOS will be evaluates on the IBZ mesh energies. el Electron data type\nusetetra Use the tetrahedron method for delta functions? Arguments Type Intent Optional Attributes Name type( electron ), intent(inout) :: el logical, intent(in) :: usetetra private  subroutine calculate_ph_dos_iso(ph, usetetra, gfactors, subs_gfactors, atomtypes, W_phiso, W_phsubs, phiso, phsubs) Calculate the phonon density of states (DOS) in units of 1/energy and,\noptionally, the phonon-isotope scattering rates. The DOS and isotope scattering rates will be evaluates on the IBZ mesh energies. ph Phonon data type\nusetetra Use the tetrahedron method for delta functions? Arguments Type Intent Optional Attributes Name type( phonon ), intent(inout) :: ph logical, intent(in) :: usetetra real(kind=r64), intent(in) :: gfactors (:) real(kind=r64), intent(in) :: subs_gfactors (:) integer(kind=i64), intent(in) :: atomtypes (:) real(kind=r64), intent(out), allocatable :: W_phiso (:,:) real(kind=r64), intent(out), allocatable :: W_phsubs (:,:) logical, intent(in) :: phiso logical, intent(in) :: phsubs","tags":"","loc":"interface/calculate_dos.html"},{"title":"calculate_wavevectors_full – elphbolt","text":"public  subroutine calculate_wavevectors_full(mesh, wavevecs, blocks, indexlist) Calculate wave vectors (crystal coords.) of the full Brillouin zone (FBZ) mesh is the array of number of points along the reciprocal lattice vectors\nwavevecs is the list of all the wave vectors Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: mesh (3) real(kind=r64), intent(out), allocatable :: wavevecs (:,:) logical, intent(in) :: blocks integer(kind=i64), intent(in), optional :: indexlist (:) Contents","tags":"","loc":"proc/calculate_wavevectors_full.html"},{"title":"misc – elphbolt","text":"Module containing miscellaneous math and numerics related functions and subroutines. Uses params Contents Interfaces sort twonorm invert Derived Types timer Functions cross_product kronecker expi trace mux_vector mux_state Bose Fermi Pade_continued Subroutines start_timer end_timer linspace exit_with_message print_message write2file_rank1_real write2file_rank2_real write2file_rank3_real write2file_response readfile_response append2file_transport_tensor write2file_spectral_tensor int_div distribute_points binsearch compsimps demux_vector demux_mesh demux_state interpolate welcome subtitle Interfaces public        interface sort private  subroutine sort_int(list) Swap sort list of integers Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(inout) :: list (:) private  subroutine sort_real(list) Swap sort list of reals Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: list (:) public        interface twonorm private pure function twonorm_real_rank1(v) 2-norm of a rank-1 real vector Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: v (:) Return Value real(kind=r64) private pure function twonorm_real_rank2(T) Custom 2-norm of a rank-2 real tensor Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: T (:,:) Return Value real(kind=r64) public        interface invert private  subroutine invert_complex_square(mat) Wrapper for lapack complex matrix inversion Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(inout) :: mat (:,:) Derived Types type, public :: timer Container for timing related data and procedures. Components Type Visibility Attributes Name Initial integer(kind=i64), public :: rate = 0 integer(kind=i64), public :: start = -1 integer(kind=i64), public :: end = -1 character(len=:), public, allocatable :: event Type-Bound Procedures procedure\n                    ,                  public\n                  :: end_timer Subroutine procedure\n                    ,                  public\n                  :: start_timer Subroutine Functions public pure function cross_product (A, B) Cross product of A and B. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: A (3) real(kind=r64), intent(in) :: B (3) Return Value real(kind=r64), (3) public pure function kronecker (i, j) Kronecker delta Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: i integer(kind=i64), intent(in) :: j Return Value integer(kind=i64) public pure function expi (x) Calculate exp(i*x) = cos(x) + isin(x) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x Return Value complex(kind=r64) public pure function trace (mat) Trace of square matrix Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: mat (:,:) Return Value real(kind=r64) public  function mux_vector (v, mesh, base) Multiplex index of a single wave vector.\nv is the demultiplexed triplet of a wave vector.\ni is the multiplexed index of a wave vector (always 1-based).\nmesh is the number of wave vectors along the three reciprocal lattice vectors.\nbase states whether v has 0- or 1-based indexing. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: v (3) integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: base Return Value integer(kind=i64) public pure function mux_state (nbands, iband, ik) Multiplex a (band index, wave vector index) pair into a state index Read more… Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: nbands integer(kind=i64), intent(in) :: iband integer(kind=i64), intent(in) :: ik Return Value integer(kind=i64) public pure function Bose (e, T) e Energy in eV\nT temperature in K Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: e real(kind=r64), intent(in) :: T Return Value real(kind=r64) public pure function Fermi (e, chempot, T) e Energy in eV\nchempot Chemical potential in eV\nT temperature in K Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: e real(kind=r64), intent(in) :: chempot real(kind=r64), intent(in) :: T Return Value real(kind=r64) public pure function Pade_continued (iomegas, us, xs) Analytically continue from the upper imaginary plane to\nthe positive real axis by solving equation A3 of the following article:\nSolving the Eliashberg equations by means of N-point Pade' approximants\nVidberg and Serene Journal of Low Temperature Physics, Vol. 29, Nos. 3/4, 1977 Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: iomegas (:) real(kind=r64), intent(in) :: us (:) real(kind=r64), intent(in) :: xs (:) Return Value complex(kind=r64), (size(xs)) Subroutines public  subroutine start_timer (self, event) Start/Reset the timer. This is a blocking call.\nOnly image 1 can modify timing information. Arguments Type Intent Optional Attributes Name class( timer ), intent(out) :: self character(len=*), intent(in) :: event public  subroutine end_timer (self, event) End the timer and print the elapsed time. This is a blocking call.\nOnly image 1 can modify timing information. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: self character(len=*), intent(in) :: event public  subroutine linspace (grid, min, max, num) Create equidistant grid. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out), allocatable :: grid (:) real(kind=r64), intent(in) :: min real(kind=r64), intent(in) :: max integer(kind=i64), intent(in) :: num public  subroutine exit_with_message (message) Exit with error message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message public  subroutine print_message (message) Print message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message public  subroutine write2file_rank1_real (filename, data) Write rank-1 data to file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(in) :: data (:) public  subroutine write2file_rank2_real (filename, data) Write rank-2 data to file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(in) :: data (:,:) public  subroutine write2file_rank3_real (filename, data) Write rank-3 data to file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(in) :: data (:,:,:) public  subroutine write2file_response (filename, data, bandlist) Write list of vectors to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(in) :: data (:,:,:) integer(kind=i64), intent(in), optional :: bandlist (:) public  subroutine readfile_response (filename, data, bandlist) Read list of vectors to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(out) :: data (:,:,:) integer(kind=i64), intent(in), optional :: bandlist (:) public  subroutine append2file_transport_tensor (filename, it, data, bandlist) Append 3x3 tensor to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=i64), intent(in) :: it real(kind=r64), intent(in) :: data (:,:,:) integer(kind=i64), intent(in), optional :: bandlist (:) public  subroutine write2file_spectral_tensor (filename, data, bandlist) Append 3x3 spectral transport tensor to band/branch resolved files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=r64), intent(in) :: data (:,:,:,:) integer(kind=i64), intent(in), optional :: bandlist (:) public  subroutine int_div (num, denom, q, r) Quotient(q) and remainder(r) of the integer division num/denom. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: num integer(kind=i64), intent(in) :: denom integer(kind=i64), intent(out) :: q integer(kind=i64), intent(out) :: r public  subroutine distribute_points (npts, chunk, istart, iend, num_active_images) Distribute points among processes Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: npts integer(kind=i64), intent(out) :: chunk integer(kind=i64), intent(out) :: istart integer(kind=i64), intent(out) :: iend integer(kind=i64), intent(out) :: num_active_images public  subroutine binsearch (array, e, m) Binary search in a list of integers and return index. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: array (:) integer(kind=i64), intent(in) :: e integer(kind=i64), intent(out) :: m public  subroutine compsimps (f, h, s) Composite Simpson's rule for real function\nf integrand\nh integration variable spacing\ns result Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: f (:) real(kind=r64), intent(in) :: h real(kind=r64), intent(out) :: s public  subroutine demux_vector (i, v, mesh, base) Demultiplex index of a single wave vector.\ni is the multiplexed index of a wave vector (always 1-based).\nv is the demultiplexed triplet of a wave vector.\nmesh is the number of wave vectors along the three reciprocal lattice vectors.\nbase chooses whether v has 0- or 1-based indexing. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: i integer(kind=i64), intent(out) :: v (3) integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: base public  subroutine demux_mesh (index_mesh, nmesh, mesh, base, indexlist) Demultiplex all wave vector indices \n(optionally, from a list of indices).\nInternally uses demux_vector. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(out) :: index_mesh (3,nmesh) integer(kind=i64), intent(in) :: nmesh integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: base integer(kind=i64), intent(in), optional :: indexlist (nmesh) public  subroutine demux_state (m, nbands, iband, ik) Demultiplex a state index into (band index, wave vector index) pair Read more… Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: m integer(kind=i64), intent(in) :: nbands integer(kind=i64), intent(out) :: iband integer(kind=i64), intent(out) :: ik public  subroutine interpolate (coarsemesh, refinement, f, q, interpolation) Subroutine to perform BZ interpolation. Read more… Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: coarsemesh (3) integer(kind=i64), intent(in) :: refinement (3) real(kind=r64), intent(in) :: f (:) integer(kind=i64), intent(in) :: q (3) real(kind=r64), intent(out) :: interpolation public  subroutine welcome () Subroutine to print a pretty banner. Arguments None public  subroutine subtitle (text) Subroutine to print a subtitle. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text","tags":"","loc":"module/misc.html"},{"title":"spglib_wrapper – elphbolt","text":"Wrapper for spglib from ShengBTE. Uses iso_c_binding params Contents Variables symprec Interfaces spg_get_symmetry spg_get_international spg_get_multiplicity Functions get_num_operations Subroutines get_operations get_cartesian_operations Variables Type Visibility Attributes Name Initial real(kind=C_DOUBLE), public, parameter :: symprec = 1d-5 Interfaces interface public  function spg_get_symmetry(rotations, translations, nops, lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_symmetry\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), dimension(3,3,nops) :: rotations real(kind=C_DOUBLE), dimension(3,nops) :: translations integer(kind=C_INT), value :: nops real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT) interface public  function spg_get_international(symbol, lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_international\") Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), dimension(11) :: symbol real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT) interface public  function spg_get_multiplicity(lattice, positions, types, natoms, symprec) bind(C, name=\"spg_get_multiplicity\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), dimension(3,3) :: lattice real(kind=C_DOUBLE), dimension(3,natoms) :: positions integer(kind=C_INT), dimension(natoms) :: types integer(kind=C_INT), value :: natoms real(kind=C_DOUBLE), value :: symprec Return Value integer(kind=C_INT) Functions public  function get_num_operations (lattice, natoms, types, positions) Return the number of symmetry operations. Useful for allocating\nmemory for get_operations(). Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), dimension(3,3) :: lattice integer(kind=i64), intent(in) :: natoms integer(kind=i64), intent(in), dimension(natoms) :: types real(kind=r64), intent(in), dimension(3,natoms) :: positions Return Value integer(kind=i64) Subroutines public  subroutine get_operations (lattice, natoms, types, positions, nops, rotations, translations, international) Return the matrix and vector representations of the symmetry\noperations of the system. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), dimension(3,3) :: lattice integer(kind=i64), intent(in) :: natoms integer(kind=i64), intent(in), dimension(natoms) :: types real(kind=r64), intent(in), dimension(3,natoms) :: positions integer(kind=i64), intent(inout) :: nops integer(kind=i64), intent(out), dimension(3,3,nops) :: rotations real(kind=r64), intent(out), dimension(3,nops) :: translations character(len=10), intent(out) :: international public  subroutine get_cartesian_operations (lattice, nops, rotations, translations, crotations, ctranslations) Return the Cartesian components of the rotations and translations\nreturned by get_operations(). Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in), dimension(3,3) :: lattice integer(kind=i64), intent(in) :: nops integer(kind=i64), intent(in), dimension(3,3,nops) :: rotations real(kind=r64), intent(in), dimension(3,nops) :: translations real(kind=r64), intent(out), dimension(3,3,nops) :: crotations real(kind=r64), intent(out), dimension(3,nops) :: ctranslations","tags":"","loc":"module/spglib_wrapper.html"},{"title":"FC2_parser_factory_module – elphbolt","text":"2nd oder force constants (FC2) parser factory. Uses misc Used by Descendants: fc2_parser_qe fc2_parser_siesta Contents Interfaces qe_parser siesta_parser Abstract Interfaces generic_parser Derived Types FC2_parser_factory FC2 fc2_qe fc2_siesta Functions set_format Interfaces interface public module subroutine qe_parser(self) Arguments Type Intent Optional Attributes Name class( fc2_qe ), intent(in) :: self interface public module subroutine siesta_parser(self) Arguments Type Intent Optional Attributes Name class( fc2_siesta ), intent(in) :: self Abstract Interfaces abstract interface public  subroutine generic_parser(self) Arguments Type Intent Optional Attributes Name class( FC2 ), intent(in) :: self Derived Types type, public :: FC2_parser_factory Components Type Visibility Attributes Name Initial class( FC2 ), public, pointer :: FC2 Type-Bound Procedures procedure\n                    ,                  public\n                  :: set_format Function type, public :: FC2 Type-Bound Procedures procedure\n(generic_parser)                    ,                  public\n, pass(self)                  :: parser type, public, extends( FC2 ) :: fc2_qe Quantum Espresso 2nd order force constants format Type-Bound Procedures procedure\n                    ,                  public\n, pass(self)                  :: parser => qe_parser Interface type, public, extends( FC2 ) :: fc2_siesta Siesta 2nd order force constants format Type-Bound Procedures procedure\n                    ,                  public\n, pass(self)                  :: parser => siesta_parser Interface Functions public  function set_format (self, format_name) result(fc2_type) Arguments Type Intent Optional Attributes Name class( FC2_parser_factory ) :: self character(len=*), intent(in) :: format_name Return Value class( FC2 ), pointer","tags":"","loc":"module/fc2_parser_factory_module.html"},{"title":"eliashberg – elphbolt","text":"Module containing the procedures related to the computation of the Eliashberg\nspectral function a2F and the e-ph coupling factor lambda. Uses electron_module numerics_module delta phonon_module params wannier_module misc Contents Subroutines calculate_a2F calculate_iso_Matsubara_lambda calculate_aniso_Matsubara_lambda Subroutines public  subroutine calculate_a2F (wann, el, ph, num, omegas, iso_lambda0, omegalog, external_eps_switch) Parallel driver of a2F_mk(nk'|sq) over IBZ electron states.\nOther zero temperature quantities such as the isotropic electron-phonon\ncoupling (lambda0) and the log-averaged boson energy (omegalog) are\nalso calculated here. Read more… Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( electron ), intent(in) :: el type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num real(kind=r64), intent(in) :: omegas (:) real(kind=r64), intent(out) :: iso_lambda0 real(kind=r64), intent(out) :: omegalog logical, intent(in), optional :: external_eps_switch public  subroutine calculate_iso_Matsubara_lambda (wann, num, omegas, bose_matsubara_ens, iso_matsubara_lambda) Calculate the isotropic Matsubara electron-phonon coupling, lambda(l).\nHere l is the Bosonic Matsubara energy index. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( numerics ), intent(in) :: num real(kind=r64), intent(in) :: omegas (:) real(kind=r64), intent(in) :: bose_matsubara_ens (:) real(kind=r64), intent(out) :: iso_matsubara_lambda (:) public  subroutine calculate_aniso_Matsubara_lambda (wann, num, el, omegas, bose_matsubara_ens) Parallel driver of lambda_mk(nk'|sq, l) over IBZ electron states.\nHere l is the Bosonic Matsubara energy index. Read more… Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( numerics ), intent(in) :: num type( electron ), intent(in) :: el real(kind=r64), intent(in) :: omegas (:) real(kind=r64), intent(in) :: bose_matsubara_ens (:)","tags":"","loc":"module/eliashberg.html"},{"title":"bte_module – elphbolt","text":"Module containing type and procedures related to the solution of the\nBoltzmann transport equation (BTE). Uses electron_module crystal_module numerics_module bz_sums phonon_module misc params interactions symmetry_module Contents Derived Types bte Derived Types type, public :: bte Data and procedures related to the BTE. Components Type Visibility Attributes Name Initial real(kind=r64), public, allocatable :: ph_rta_rates_iso_ibz (:,:) Phonon RTA scattering rates on the IBZ due to isotope scattering. real(kind=r64), public, allocatable :: ph_rta_rates_subs_ibz (:,:) Phonon RTA scattering rates on the IBZ due to substitution scattering. real(kind=r64), public, allocatable :: ph_rta_rates_bound_ibz (:,:) Phonon RTA scattering rates on the IBZ due to boundary scattering. real(kind=r64), public, allocatable :: ph_rta_rates_thinfilm_ibz (:,:) Phonon RTA scattering rates on the IBZ due to thin-film scattering. real(kind=r64), public, allocatable :: ph_rta_rates_3ph_ibz (:,:) Phonon RTA scattering rates on the IBZ due to 3-ph interactions. real(kind=r64), public, allocatable :: ph_rta_rates_4ph_ibz (:,:) Phonon RTA scattering rates on the IBZ due to 4-ph interactions. real(kind=r64), public, allocatable :: ph_rta_rates_phe_ibz (:,:) Phonon RTA scattering rates on the IBZ due to ph-e interactions. real(kind=r64), public, allocatable :: ph_rta_rates_ibz (:,:) Phonon RTA scattering rates on the IBZ. real(kind=r64), public, allocatable :: ph_field_term_T (:,:,:) Phonon field coupling term for gradT field on the FBZ. real(kind=r64), public, allocatable :: ph_response_T (:,:,:) Phonon response function for gradT field on the FBZ. real(kind=r64), public, allocatable :: ph_field_term_E (:,:,:) Phonon field coupling term for E field on the FBZ. real(kind=r64), public, allocatable :: ph_response_E (:,:,:) Phonon response function for E field on the FBZ. real(kind=r64), public, allocatable :: el_rta_rates_echimp_ibz (:,:) Electron RTA scattering rates on the IBZ due to charged impurity scattering. real(kind=r64), public, allocatable :: el_rta_rates_bound_ibz (:,:) Electron RTA scattering rates on the IBZ due to boundary scattering. real(kind=r64), public, allocatable :: el_rta_rates_eph_ibz (:,:) Electron RTA scattering rates on the IBZ due to e-ph interactions. real(kind=r64), public, allocatable :: el_rta_rates_ibz (:,:) Electron RTA scattering rates on the IBZ. real(kind=r64), public, allocatable :: el_field_term_T (:,:,:) Electron field coupling term for gradT field on the FBZ. real(kind=r64), public, allocatable :: el_response_T (:,:,:) Electron response function for gradT field on the FBZ. real(kind=r64), public, allocatable :: el_field_term_E (:,:,:) Electron field coupling term for E field on the FBZ. real(kind=r64), public, allocatable :: el_response_E (:,:,:) Electron response function for E field on the FBZ. Type-Bound Procedures procedure\n                    ,                  public\n                  :: post_process Subroutine procedure\n                    ,                  public\n                  :: solve_bte Subroutine","tags":"","loc":"module/bte_module.html"},{"title":"params – elphbolt","text":"Module containing various parameters and constants. Uses iso_fortran_env Contents Variables r64 i64 qe me amu hbar hbar_eVps perm0 kB pi twopi Hartree2radTHz Hartree2eV Ryd2radTHz Ryd2eV Ryd2meV Ryd2amu bohr2nm oneI twopiI periodic_table Variables Type Visibility Attributes Name Initial integer, public, parameter :: r64 = real64 integer, public, parameter :: i64 = int64 real(kind=r64), public, parameter :: qe = 1.602176634e-19_r64 Electron charge magnitude (C) real(kind=r64), public, parameter :: me = 9.1093837015e-31_r64 Electron mass (Kg) real(kind=r64), public, parameter :: amu = 1.66053906660e-27_r64 Atomic mass unit (Kg) real(kind=r64), public, parameter :: hbar = 1.05457172647e-22_r64 Reduced Planck's constant (J/THz = J.ps) real(kind=r64), public, parameter :: hbar_eVps = hbar/qe Reduced Planck's constant (eV/THz = eV.ps) real(kind=r64), public, parameter :: perm0 = 8.854187817e-12_r64 Permittivity of free space (F/m) real(kind=r64), public, parameter :: kB = 1.380649e-23_r64/qe Boltzmann constant (eV/K) real(kind=r64), public, parameter :: pi = 4.0_r64*atan(1.0_r64) Value of pi real(kind=r64), public, parameter :: twopi = 2.0_r64*pi Value of 2pi real(kind=r64), public, parameter :: Hartree2radTHz = 27.2116_r64*qe/hbar real(kind=r64), public, parameter :: Hartree2eV = 27.2116_r64 real(kind=r64), public, parameter :: Ryd2radTHz = 0.5_r64*Hartree2radTHz real(kind=r64), public, parameter :: Ryd2eV = 0.5_r64*Hartree2eV real(kind=r64), public, parameter :: Ryd2meV = Ryd2eV*1.0e3_r64 real(kind=r64), public, parameter :: Ryd2amu = 2.0_r64*me/amu real(kind=r64), public, parameter :: bohr2nm = 0.052917721092_r64 complex(kind=r64), public, parameter :: oneI = (0.0_r64, 1.0_r64) complex(kind=r64), public, parameter :: twopiI = twopi*oneI character(len=3), public, parameter :: periodic_table (114) = [character(len=3)::\"H\", \"He\", \"Li\", \"Be\", \"B\", \"C\", \"N\", \"O\", \"F\", \"Ne\", \"Na\", \"Mg\", \"Al\", \"Si\", \"P\", \"S\", \"Cl\", \"Ar\", \"K\", \"Ca\", \"Sc\", \"Ti\", \"V\", \"Cr\", \"Mn\", \"Fe\", \"Co\", \"Ni\", \"Cu\", \"Zn\", \"Ga\", \"Ge\", \"As\", \"Se\", \"Br\", \"Kr\", \"Rb\", \"Sr\", \"Y\", \"Zr\", \"Nb\", \"Mo\", \"Tc\", \"Ru\", \"Rh\", \"Pd\", \"Ag\", \"Cd\", \"In\", \"Sn\", \"Sb\", \"Te\", \"I\", \"Xe\", \"Cs\", \"Ba\", \"La\", \"Ce\", \"Pr\", \"Nd\", \"Pm\", \"Sm\", \"Eu\", \"Gd\", \"Tb\", \"Dy\", \"Ho\", \"Er\", \"Tm\", \"Yb\", \"Lu\", \"Hf\", \"Ta\", \"W\", \"Re\", \"Os\", \"Ir\", \"Pt\", \"Au\", \"Hg\", \"Tl\", \"Pb\", \"Bi\", \"Po\", \"At\", \"Rn\", \"Fr\", \"Ra\", \"Ac\", \"Th\", \"Pa\", \"U\", \"Np\", \"Pu\", \"Am\", \"Cm\", \"Bk\", \"Cf\", \"Es\", \"Fm\", \"Md\", \"No\", \"Lr\", \"Rf\", \"Db\", \"Sg\", \"Bh\", \"Hs\", \"Mt\", \"Ds\", \"Rg\", \"Cn\", \"Uuq\", \"Uuh\"]","tags":"","loc":"module/params.html"},{"title":"interactions – elphbolt","text":"Module containing the procedures related to the computation of interactions. $  subroutine calculate_defect_scatt_rates(prefix, def_frac, indexlist_ibz, ens_fbz, diagT)!, scatt_rates)\n$    !! Subroutine to calculate the phonon-defect scattering rate given\n$    !! the diagonal of the scattering T-matrix.\n$    !!\n$    !! prefix Particle type label\n$    !! def_frac Elemental fraction of defects\n$    !! ens IBZ energies\n$    !! diagT Diagonal of the IBZ T-matrix\n$    !! scatt_rates IBZ Scattering rates\n$\n$    character(len = 2), intent(in) :: prefix\n$    real(r64), intent(in) :: def_frac\n$    real(r64), intent(in) :: ens_fbz(:, :)\n$    integer(i64), intent(in) :: indexlist_ibz(:)\n$    complex(r64), intent(in) :: diagT(:, :)\n$    !real(r64), allocatable, intent(out) :: scatt_rates(:, :)\n$ $    !Local variables\n$    integer(i64) :: nk_ibz, nbands, ik\n$    real(r64), allocatable :: scatt_rates(:, :)\n$\n$    nk_ibz = size(diagT, 1)\n$    nbands = size(diagT, 2)\n$\n$    print , 'def_frac = ', def_frac\n$ $    allocate(scatt_rates(nk_ibz, nbands))\n$\n$    do ik = 1, nk_ibz\n$       scatt_rates(ik, :) = imag(diagT(ik, :))/ens_fbz(indexlist_ibz(ik), :)\n$    end do\n$\n$    scatt_rates = -def_frac scatt_rates/hbar_eVps\n$\n$    !Deal with Gamma point acoustic phonons! and zero-velocity optic phonons\n$    scatt_rates(1, 1:3) = 0.0_r64\n$ $    !Write to file\n$    call write2file_rank2_real(prefix // '.W_rta_'//prefix//'defect', scatt_rates)\n$  end subroutine calculate_defect_scatt_rates Uses electron_module crystal_module numerics_module delta phonon_module params wannier_module misc Contents Subroutines calculate_3ph_interaction calculate_gReq calculate_gkRp calculate_eph_interaction_ibzq calculate_eph_interaction_ibzk calculate_echimp_interaction_ibzk calculate_ph_rta_rates calculate_4ph_rta_rates calculate_el_rta_rates read_transition_probs_e calculate_bound_scatt_rates calculate_thinfilm_scatt_rates Subroutines public  subroutine calculate_3ph_interaction (ph, crys, num, key) Parallel driver of the 3-ph vertex calculator for all IBZ phonon wave vectors.\nThis subroutine calculates |V-(s1 |s2q2,s3q3)|&#94;2, W-(s1 |s2q2,s3q3),\nand W+(s1 |s2q2,s3q3) for each irreducible phonon and saves the results to disk. Read more… Arguments Type Intent Optional Attributes Name type( phonon ), intent(in) :: ph type( crystal ), intent(in) :: crys type( numerics ), intent(in) :: num character(len=1), intent(in) :: key public  subroutine calculate_gReq (wann, ph, num) Parallel driver of gReq_epw over IBZ phonon wave vectors. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num public  subroutine calculate_gkRp (wann, el, num) Parallel driver of gkRp_epw over IBZ electron wave vectors. Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( electron ), intent(in) :: el type( numerics ), intent(in) :: num public  subroutine calculate_eph_interaction_ibzq (wann, crys, el, ph, num, key) Parallel driver of g2(q,k) over IBZ phonon states. Read more… Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num character(len=1), intent(in) :: key public  subroutine calculate_eph_interaction_ibzk (wann, crys, el, ph, num, key) Parallel driver of g2(k,q) over IBZ electron states. Read more… Arguments Type Intent Optional Attributes Name type( epw_wannier ), intent(in) :: wann type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( phonon ), intent(in) :: ph type( numerics ), intent(in) :: num character(len=1), intent(in) :: key public  subroutine calculate_echimp_interaction_ibzk (crys, el, num) Parallel driver of |g_e-chimp(k,k')|&#94;2 over IBZ electron states. Arguments Type Intent Optional Attributes Name type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el type( numerics ), intent(in) :: num public  subroutine calculate_ph_rta_rates (rta_rates_3ph, rta_rates_phe, num, crys, ph, el) Subroutine for parallel reading of the 3-ph and ph-e transition probabilities\nfrom disk and calculating the relaxation time approximation (RTA)\nscattering rates for the 3-ph and ph-e channels. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out), allocatable :: rta_rates_3ph (:,:) real(kind=r64), intent(out), allocatable :: rta_rates_phe (:,:) type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( phonon ), intent(in) :: ph type( electron ), intent(in), optional :: el public  subroutine calculate_4ph_rta_rates (rta_rates, num, crys, ph) Subroutine for interporlating 4-ph scattering rates from an\nexternal coarser mesh calculation. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out), allocatable :: rta_rates (:,:) type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( phonon ), intent(in) :: ph public  subroutine calculate_el_rta_rates (rta_rates_eph, rta_rates_echimp, num, crys, el) Subroutine for parallel reading of the e-ph transition probabilities\nfrom disk and calculating the relaxation time approximation (RTA)\nscattering rates for the e-ph channel. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(out), allocatable :: rta_rates_eph (:,:) real(kind=r64), intent(out), allocatable :: rta_rates_echimp (:,:) type( numerics ), intent(in) :: num type( crystal ), intent(in) :: crys type( electron ), intent(in) :: el public  subroutine read_transition_probs_e (filepath, N, TP, istate1, istate2) Subroutine to read transition probabilities from disk for interaction processes. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath integer(kind=i64), intent(out) :: N real(kind=r64), intent(out), allocatable :: TP (:) integer(kind=i64), intent(out), optional, allocatable :: istate1 (:) integer(kind=i64), intent(out), optional, allocatable :: istate2 (:) public  subroutine calculate_bound_scatt_rates (prefix, finite_crys, length, vels_fbz, indexlist_irred, scatt_rates) Subroutine to calculate the phonon/electron-boundary scattering rates. Read more… Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: prefix logical, intent(in) :: finite_crys real(kind=r64), intent(in) :: length real(kind=r64), intent(in) :: vels_fbz (:,:,:) integer(kind=i64), intent(in) :: indexlist_irred (:) real(kind=r64), intent(out), allocatable :: scatt_rates (:,:) public  subroutine calculate_thinfilm_scatt_rates (prefix, finite_crys, height, normal, vels_fbz, indexlist_irred, scatt_rates) Subroutine to calculate the phonon/electron-thin-film scattering rates. Read more… Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: prefix logical, intent(in) :: finite_crys real(kind=r64), intent(in) :: height character(len=1), intent(in) :: normal real(kind=r64), intent(in) :: vels_fbz (:,:,:) integer(kind=i64), intent(in) :: indexlist_irred (:) real(kind=r64), intent(out), allocatable :: scatt_rates (:,:)","tags":"","loc":"module/interactions.html"},{"title":"phonon_module – elphbolt","text":"Module containing type and procedures related to the phononic properties. Uses crystal_module symmetry_module numerics_module delta misc wannier_module params particle_module Contents Derived Types phonon Derived Types type, public, extends( particle ) :: phonon Data and procedures related to phonons. Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numbands Total number of energy dispersion bands. integer(kind=i64), public :: wvmesh (3) Particle wave vector mesh. integer(kind=i64), public :: nwv Number of particle wave vectors in the full Brillouin zone (FBZ). integer(kind=i64), public :: nwv_irred Number of particle wave vectors in the irreducible wedge of Brillouin zone (IBZ). real(kind=r64), public, allocatable :: wavevecs (:,:) List of all particle wave vectors (crystal coordinates). real(kind=r64), public, allocatable :: wavevecs_irred (:,:) List of irreducible particle wave vectors (crystal coordinates). integer(kind=i64), public, allocatable :: indexlist (:) List of muxed indices of the FBZ wave vectors. integer(kind=i64), public, allocatable :: indexlist_irred (:) List of muxed indices of the IBZ wedge. integer(kind=i64), public, allocatable :: nequiv (:) List of the number of equivalent points for each IBZ point. integer(kind=i64), public, allocatable :: ibz2fbz_map (:,:,:) Map from an IBZ particle wave vector point to its images.\nThe third axis contains the pair (symmetry index, image). integer(kind=i64), public, allocatable :: fbz2ibz_map (:) Map from an FBZ particle wave vector point to its IBZ wedge image. integer(kind=i64), public, allocatable :: equiv_map (:,:) Map of equivalent points under rotations.\nAxis 1 runs over rotations.\nAxis 2 runs over wave vectors. real(kind=r64), public, allocatable :: symmetrizers (:,:,:) Symmetrizers of wave vector dependent vectors. integer(kind=i64), public, allocatable :: tetra (:,:) List of all the wave vector mesh tetrahedra vertices.\nFirst axis list tetraheda and the second axis list the vertices. integer(kind=i64), public, allocatable :: tetracount (:) The number of tetrahedra in which a wave vector belongs. integer(kind=i64), public, allocatable :: tetramap (:,:,:) Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real(kind=r64), public, allocatable :: tetra_evals (:,:,:) Tetrahedra vertices filled with eigenvalues. integer(kind=i64), public, allocatable :: triang (:,:) List of all the wave vector mesh triangles vertices.\nFirst axis lists triangles and the second axis lists the vertices. integer(kind=i64), public, allocatable :: triangcount (:) The number of triangles in which a wave vector belongs. integer(kind=i64), public, allocatable :: triangmap (:,:,:) Mapping from a wave vector to the (triangle, vertex) where it belongs. real(kind=r64), public, allocatable :: triang_evals (:,:,:) Triangles vertices filled with eigenvalues. real(kind=r64), public, allocatable :: ens (:,:) List of particle energies on FBZ. real(kind=r64), public, allocatable :: ens_irred (:,:) List of particle energies on IBZ. real(kind=r64), public, allocatable :: vels (:,:,:) List of particle velocities on FBZ. real(kind=r64), public, allocatable :: vels_irred (:,:,:) List of particle velocites on IBZ. complex(kind=r64), public, allocatable :: evecs (:,:,:) List of all particle eigenvectors. complex(kind=r64), public, allocatable :: evecs_irred (:,:,:) List of IBZ wedge particle eigenvectors. real(kind=r64), public, allocatable :: dos (:,:) Band resolved density of states. character(len=2), public :: prefix = 'ph' Prefix idenitfying particle type. integer(kind=i64), public :: scell (3) q-mesh used in DFPT or, equivalently, supercell used in finite displencement\nmethod for calculating the 2nd order force constants. real(kind=r64), public, allocatable :: ifc2 (:,:,:,:,:,:,:) Second order force constants (ifc2) tensor. real(kind=r64), public, allocatable :: ifc3 (:,:,:,:) Third order force constants (ifc3) tensor. integer(kind=i64), public :: numtriplets Number of triplets in the ifc3 file. real(kind=r64), public, allocatable :: R_j (:,:) Position of the 2nd and 3rd unitcell in supercell for an ifc3 triplet. real(kind=r64), public, allocatable :: R_k (:,:) Position of the 2nd and 3rd unitcell in supercell for an ifc3 triplet. integer(kind=i64), public, allocatable :: Index_i (:) Label of primitive cell atoms in the ifc3 triplet. integer(kind=i64), public, allocatable :: Index_j (:) Label of primitive cell atoms in the ifc3 triplet. integer(kind=i64), public, allocatable :: Index_k (:) Label of primitive cell atoms in the ifc3 triplet. real(kind=r64), public, allocatable :: tetra_squared_evals (:,:,:) Tetrahedra vertices filled with squared eigenvalues.\nThis is needed only for the phonon Green's function calculation. real(kind=r64), public :: rws (124,0:3) real(kind=r64), public :: cell_r (1:3,0:3) real(kind=r64), public :: cell_g (1:3,0:3) real(kind=r64), public, allocatable :: mm (:,:) real(kind=r64), public, allocatable :: rr (:,:,:) Type-Bound Procedures procedure\n                    ,                  public\n                  :: deallocate_phonon_quantities Subroutine procedure\n                    ,                  public\n                  :: initialize Subroutine","tags":"","loc":"module/phonon_module.html"},{"title":"particle_module – elphbolt","text":"Module containing the particle abstract data type. Uses params Contents Derived Types particle Derived Types type, public :: particle Data related to generic particle properties. Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numbands Total number of energy dispersion bands. integer(kind=i64), public :: wvmesh (3) Particle wave vector mesh. integer(kind=i64), public :: nwv Number of particle wave vectors in the full Brillouin zone (FBZ). integer(kind=i64), public :: nwv_irred Number of particle wave vectors in the irreducible wedge of Brillouin zone (IBZ). real(kind=r64), public, allocatable :: wavevecs (:,:) List of all particle wave vectors (crystal coordinates). real(kind=r64), public, allocatable :: wavevecs_irred (:,:) List of irreducible particle wave vectors (crystal coordinates). integer(kind=i64), public, allocatable :: indexlist (:) List of muxed indices of the FBZ wave vectors. integer(kind=i64), public, allocatable :: indexlist_irred (:) List of muxed indices of the IBZ wedge. integer(kind=i64), public, allocatable :: nequiv (:) List of the number of equivalent points for each IBZ point. integer(kind=i64), public, allocatable :: ibz2fbz_map (:,:,:) Map from an IBZ particle wave vector point to its images.\nThe third axis contains the pair (symmetry index, image). integer(kind=i64), public, allocatable :: fbz2ibz_map (:) Map from an FBZ particle wave vector point to its IBZ wedge image. integer(kind=i64), public, allocatable :: equiv_map (:,:) Map of equivalent points under rotations.\nAxis 1 runs over rotations.\nAxis 2 runs over wave vectors. real(kind=r64), public, allocatable :: symmetrizers (:,:,:) Symmetrizers of wave vector dependent vectors. integer(kind=i64), public, allocatable :: tetra (:,:) List of all the wave vector mesh tetrahedra vertices.\nFirst axis list tetraheda and the second axis list the vertices. integer(kind=i64), public, allocatable :: tetracount (:) The number of tetrahedra in which a wave vector belongs. integer(kind=i64), public, allocatable :: tetramap (:,:,:) Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real(kind=r64), public, allocatable :: tetra_evals (:,:,:) Tetrahedra vertices filled with eigenvalues. integer(kind=i64), public, allocatable :: triang (:,:) List of all the wave vector mesh triangles vertices.\nFirst axis lists triangles and the second axis lists the vertices. integer(kind=i64), public, allocatable :: triangcount (:) The number of triangles in which a wave vector belongs. integer(kind=i64), public, allocatable :: triangmap (:,:,:) Mapping from a wave vector to the (triangle, vertex) where it belongs. real(kind=r64), public, allocatable :: triang_evals (:,:,:) Triangles vertices filled with eigenvalues. real(kind=r64), public, allocatable :: ens (:,:) List of particle energies on FBZ. real(kind=r64), public, allocatable :: ens_irred (:,:) List of particle energies on IBZ. real(kind=r64), public, allocatable :: vels (:,:,:) List of particle velocities on FBZ. real(kind=r64), public, allocatable :: vels_irred (:,:,:) List of particle velocites on IBZ. complex(kind=r64), public, allocatable :: evecs (:,:,:) List of all particle eigenvectors. complex(kind=r64), public, allocatable :: evecs_irred (:,:,:) List of IBZ wedge particle eigenvectors. real(kind=r64), public, allocatable :: dos (:,:) Band resolved density of states.","tags":"","loc":"module/particle_module.html"},{"title":"electron_module – elphbolt","text":"Module containing types and procedures related to the electronic properties. Uses crystal_module symmetry_module numerics_module delta misc wannier_module params particle_module Contents Derived Types electron Derived Types type, public, extends( particle ) :: electron Data and procedures related to the electronic properties. Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numbands Total number of energy dispersion bands. integer(kind=i64), public :: wvmesh (3) Particle wave vector mesh. integer(kind=i64), public :: nwv Number of particle wave vectors in the full Brillouin zone (FBZ). integer(kind=i64), public :: nwv_irred Number of particle wave vectors in the irreducible wedge of Brillouin zone (IBZ). real(kind=r64), public, allocatable :: wavevecs (:,:) List of all particle wave vectors (crystal coordinates). real(kind=r64), public, allocatable :: wavevecs_irred (:,:) List of irreducible particle wave vectors (crystal coordinates). integer(kind=i64), public, allocatable :: indexlist (:) List of muxed indices of the FBZ wave vectors. integer(kind=i64), public, allocatable :: indexlist_irred (:) List of muxed indices of the IBZ wedge. integer(kind=i64), public, allocatable :: nequiv (:) List of the number of equivalent points for each IBZ point. integer(kind=i64), public, allocatable :: ibz2fbz_map (:,:,:) Map from an IBZ particle wave vector point to its images.\nThe third axis contains the pair (symmetry index, image). integer(kind=i64), public, allocatable :: fbz2ibz_map (:) Map from an FBZ particle wave vector point to its IBZ wedge image. integer(kind=i64), public, allocatable :: equiv_map (:,:) Map of equivalent points under rotations.\nAxis 1 runs over rotations.\nAxis 2 runs over wave vectors. real(kind=r64), public, allocatable :: symmetrizers (:,:,:) Symmetrizers of wave vector dependent vectors. integer(kind=i64), public, allocatable :: tetra (:,:) List of all the wave vector mesh tetrahedra vertices.\nFirst axis list tetraheda and the second axis list the vertices. integer(kind=i64), public, allocatable :: tetracount (:) The number of tetrahedra in which a wave vector belongs. integer(kind=i64), public, allocatable :: tetramap (:,:,:) Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real(kind=r64), public, allocatable :: tetra_evals (:,:,:) Tetrahedra vertices filled with eigenvalues. integer(kind=i64), public, allocatable :: triang (:,:) List of all the wave vector mesh triangles vertices.\nFirst axis lists triangles and the second axis lists the vertices. integer(kind=i64), public, allocatable :: triangcount (:) The number of triangles in which a wave vector belongs. integer(kind=i64), public, allocatable :: triangmap (:,:,:) Mapping from a wave vector to the (triangle, vertex) where it belongs. real(kind=r64), public, allocatable :: triang_evals (:,:,:) Triangles vertices filled with eigenvalues. real(kind=r64), public, allocatable :: ens (:,:) List of particle energies on FBZ. real(kind=r64), public, allocatable :: ens_irred (:,:) List of particle energies on IBZ. real(kind=r64), public, allocatable :: vels (:,:,:) List of particle velocities on FBZ. real(kind=r64), public, allocatable :: vels_irred (:,:,:) List of particle velocites on IBZ. complex(kind=r64), public, allocatable :: evecs (:,:,:) List of all particle eigenvectors. complex(kind=r64), public, allocatable :: evecs_irred (:,:,:) List of IBZ wedge particle eigenvectors. real(kind=r64), public, allocatable :: dos (:,:) Band resolved density of states. character(len=2), public :: prefix = 'el' Prefix idenitfying particle type. integer(kind=i64), public :: spindeg Spin degeneracy. integer(kind=i64), public :: numtransbands Total number of transport active bands. integer(kind=i64), public :: indlowband Lowest transport band index. integer(kind=i64), public :: indhighband Highest transport band index. integer(kind=i64), public :: indlowconduction Lowest conduction band index. integer(kind=i64), public :: indhighvalence Highest valence band index. integer(kind=i64), public, allocatable :: bandlist (:) List of transport active band indices. integer(kind=i64), public :: mesh_ref Electron mesh refinement factor compared to the phonon mesh. integer(kind=i64), public :: mesh_ref_array (3) The same as above, but in array form. This is useful for 3d vs 2d cases. integer(kind=i64), public :: nstates_inwindow Number of electron wave vectors within transport window. integer(kind=i64), public :: nstates_irred_inwindow Number of IBZ wedge electron wave vectors within transport window. integer(kind=i64), public, allocatable :: IBZ_inwindow_states (:,:) List of irreducible wedge states within transport window. real(kind=r64), public :: enref Electron reference energy (eV).\nThis is the center of the transport energy window. real(kind=r64), public :: fsthick Fermi surface thickness (eV). real(kind=r64), public :: chempot Chemical potential in (eV). real(kind=r64), public, allocatable :: conc (:) Band resolved carrier concentration. real(kind=r64), public :: conc_el Total electron carrier concentration. real(kind=r64), public :: conc_hole Total hole carrier concentration. real(kind=r64), public :: chimp_conc_n Concentration of donor impurities. real(kind=r64), public :: chimp_conc_p Concentration of acceptor impurities. real(kind=r64), public :: Zn Ionization number of donor dopant. real(kind=r64), public :: Zp Ionization number of acceptor dopant. real(kind=r64), public, allocatable :: scissor (:) Scissor operator (eV) logical, public :: metallic Is the system metallic? character(len=1), public :: dopingtype Type of doping. This is needed for runlevel 0 only. integer(kind=i64), public :: numconc Number of concentration points. This is needed for runlevel 0 only. real(kind=r64), public, allocatable :: conclist (:) List of concentrations. This is needed for runlevel 0 only. integer(kind=i64), public :: numT Number of temperature points. This is needed for runlevel 0 only. real(kind=r64), public, allocatable :: Tlist (:) List of temperatures. This is needed for runlevel 0 only. real(kind=r64), public :: spinnormed_dos_fermi Spin-normalized density of states at the Fermi level real(kind=r64), public, allocatable :: Ws_irred (:,:) Electron delta functions normalized by spinnormed_dos_fermi real(kind=r64), public, allocatable :: Ws (:,:) Electron delta functions normalized by spinnormed_dos_fermi Type-Bound Procedures procedure\n                    ,                  public\n                  :: deallocate_eigenvecs Subroutine procedure\n                    ,                  public\n                  :: initialize =>\n                    read_input_and_setup Subroutine","tags":"","loc":"module/electron_module.html"},{"title":"Green_function – elphbolt","text":"Module containing Green's function related procedures. Uses electron_module crystal_module delta phonon_module params misc Contents Subroutines calculate_retarded_phonon_D0 Subroutines public  subroutine calculate_retarded_phonon_D0 (ph, crys, def_supercell_cell_pos_intvec, pcell_atom_label, D0, dimp_cell_pos_intvec, pcell_atom_dof) Parallel driver of the retarded, bare phonon Green's function, D0, over\n the IBZ states. Read more… Arguments Type Intent Optional Attributes Name type( phonon ), intent(in) :: ph type( crystal ), intent(in) :: crys integer(kind=i64), intent(in) :: def_supercell_cell_pos_intvec (:,:) integer(kind=i64), intent(in) :: pcell_atom_label (:) complex(kind=r64), intent(out), allocatable :: D0 (:,:,:) integer(kind=i64), intent(in) :: dimp_cell_pos_intvec (:,:) integer(kind=i64), intent(in) :: pcell_atom_dof (:)","tags":"","loc":"module/green_function.html"},{"title":"phonon_defect_module – elphbolt","text":"Module containing phonon defect related data type and procedures. Uses phonon_module misc params crystal_module Contents Derived Types phonon_defect Derived Types type, public :: phonon_defect Data and procedures related to phonon defects. Components Type Visibility Attributes Name Initial real(kind=r64), public :: range Radius of the defect in nm. This defines a block of cells in the defective supercell. integer(kind=i64), public :: numcells Number of cells in the defective supercell block. integer(kind=i64), public :: numhosts Number of host sites in the unit cell. This can't exceed the number of unique elements. integer(kind=i64), public, allocatable :: cell_pos_intvec (:,:) Unitcell positions as 0-based integer triplets in the defective supercell block. integer(kind=i64), public, allocatable :: dimp_cell_pos_intvec (:,:) Unitcell positions as 0-based integer triplets in the defective supercell block. integer(kind=i64), public, allocatable :: pcell_atom_label (:) Primitive cell equivalence (integer label) of atoms in the defective supercell block. integer(kind=i64), public, allocatable :: pcell_atom_dof (:) Primitive cell equivalent atomic degree of freedom. real(kind=r64), public, allocatable :: V_mass (:) On-site mass defect potential. real(kind=r64), public, allocatable :: V_bond (:,:) General space-dependent, pairwise defect potential. complex(kind=r64), public, allocatable :: D0 (:,:,:) Retarded, bare Green's function defined on the defect space. logical, public :: mass_defect Choose if mass defect is going to be used. character(len=100), public :: approx Approximation of scattering T-matrix. Type-Bound Procedures procedure\n                    ,                  public\n                  :: calculate_phonon_Tmatrix Subroutine procedure\n                    ,                  public\n                  :: initialize Subroutine","tags":"","loc":"module/phonon_defect_module.html"},{"title":"delta – elphbolt","text":"Module containing the procedures related to delta function evaulation. Uses misc params Contents Functions delta_fn_tetra real_tetra delta_fn_triang Subroutines form_tetrahedra_3d fill_tetrahedra_3d form_triangles fill_triangles Functions public pure function delta_fn_tetra (e, ik, ib, mesh, tetramap, tetracount, tetra_evals) Calculate delta function using the tetraheron method. Read more… Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: e integer(kind=i64), intent(in) :: ik integer(kind=i64), intent(in) :: ib integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: tetramap (:,:,:) integer(kind=i64), intent(in) :: tetracount (:) real(kind=r64), intent(in) :: tetra_evals (:,:,:) Return Value real(kind=r64) public pure function real_tetra (e, ik, ib, mesh, tetramap, tetracount, tetra_evals) Calculate the real part of the matrix elements of the resolvent operator\nusing the analytic tetraheron method.\nLambin and Vigneron Phys. Rev. B 29 6 1984 Eqs. A3-A6\nNote that typos in Eqs. A4 and A5 have been corrected.\nHere we use the expressions given in\nV. Eyert The Augmented Spherical Wave Method DOI 10.1007/978-3-642-25864-0. Read more… Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: e integer(kind=i64), intent(in) :: ik integer(kind=i64), intent(in) :: ib integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: tetramap (:,:,:) integer(kind=i64), intent(in) :: tetracount (:) real(kind=r64), intent(in) :: tetra_evals (:,:,:) Return Value real(kind=r64) public pure function delta_fn_triang (e, ik, ib, mesh, triangmap, triangcount, triang_evals) Calculate delta function using the triangle method a la\nKurganskii et al. Phys. Stat. Sol.(b) 129, 293 (1985) Read more… Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: e integer(kind=i64), intent(in) :: ik integer(kind=i64), intent(in) :: ib integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(in) :: triangmap (:,:,:) integer(kind=i64), intent(in) :: triangcount (:) real(kind=r64), intent(in) :: triang_evals (:,:,:) Return Value real(kind=r64) Subroutines public  subroutine form_tetrahedra_3d (nk, mesh, tetra, tetracount, tetramap, blocks, indexlist) Form all the tetrahedra of a 3d FBZ mesh. Read more… Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: nk integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(out), allocatable :: tetra (:,:) integer(kind=i64), intent(out), allocatable :: tetracount (:) integer(kind=i64), intent(out), allocatable :: tetramap (:,:,:) logical, intent(in) :: blocks integer(kind=i64), intent(in), optional :: indexlist (:) public  subroutine fill_tetrahedra_3d (tetra, evals, tetra_evals) Populate the (sorted along the vertices) eigenvalues on all the vertices of the tetrahedra Read more… Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: tetra (:,:) real(kind=r64), intent(in) :: evals (:,:) real(kind=r64), intent(out), allocatable :: tetra_evals (:,:,:) public  subroutine form_triangles (nk, mesh, triang, triangcount, triangmap, blocks, indexlist) Form all the triangles of a 3d FBZ mesh for each z component. Read more… Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: nk integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(out), allocatable :: triang (:,:) integer(kind=i64), intent(out), allocatable :: triangcount (:) integer(kind=i64), intent(out), allocatable :: triangmap (:,:,:) logical, intent(in) :: blocks integer(kind=i64), intent(in), optional :: indexlist (:) public  subroutine fill_triangles (triang, evals, triang_evals) Populate the (sorted along the vertices) eigenvalues on all the vertices of the triangles Read more… Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: triang (:,:) real(kind=r64), intent(in) :: evals (:,:) real(kind=r64), intent(out), allocatable :: triang_evals (:,:,:)","tags":"","loc":"module/delta.html"},{"title":"MigEl_sc_module – elphbolt","text":"Module containing types and procedures related to the\nMigdal-Eliashberg (MigEl) solver environment. Uses electron_module numerics_module eliashberg params wannier_module misc Contents Derived Types MigEl_sc Derived Types type, public :: MigEl_sc Data and procedures related to the Migdal-Eliashberg equations solver environment. Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numqp Number of point on quasiparticle energy grid real(kind=r64), public, allocatable :: qp_ens (:) Uniform quasiparticle energy mesh integer(kind=i64), public :: qp_cutoff Quasiparticle energy cutoff (factor that multiplies the highest phonon energy) integer(kind=i64), public :: nummatsubara Number of points on Matsubara mesh integer(kind=i64), public :: nummatsubara_upper Number of points on upper plane Matsubara mesh integer(kind=i64), public :: matsubara_cutoff Matsubara energy cutoff (factor of highest phonon energy) real(kind=r64), public, allocatable :: bose_matsubara_ens (:) Uniform Bosonic Matsubara mesh real(kind=r64), public, allocatable :: fermi_matsubara_ens (:) Number of point on phonon energy grid real(kind=r64), public, allocatable :: omegas (:) Uniform Fermionic Matsubara mesh integer(kind=i64), public :: numomega Uniform phonon energy mesh real(kind=r64), public :: omegalog Logarithmic average of phonon energy real(kind=r64), public :: iso_lambda0 Standard, isotropic e-ph coupling real(kind=r64), public :: domega Uniform bosonic mesh energy difference real(kind=r64), public :: Tstart Temperature sweep: start, end, difference real(kind=r64), public :: Tend Temperature sweep: start, end, difference real(kind=r64), public :: dT Temperature sweep: start, end, difference real(kind=r64), public :: mustar Dimensionless Coulomb pseudopotential parameter real(kind=r64), public :: MAD_Tc Superconducting transition temperature in the McMillan-Allen-Dynes (MAD) theory real(kind=r64), public :: BCS_delta Superconducting gap from the BCS theory using the MAD Tc logical, public :: isotropic Use isotropic approximation? logical, public :: use_external_eps Use user generated |epsilon|&#94;2 to screen a2F? Type-Bound Procedures procedure\n                    ,                  public\n                  :: calculate_MigEl_theory Subroutine procedure\n                    ,                  public\n                  :: calculate_MAD_theory Subroutine procedure\n                    ,                  public\n                  :: initialize Subroutine","tags":"","loc":"module/migel_sc_module.html"},{"title":"symmetry_module – elphbolt","text":"Module containing type and procedures related to crystal and\nBrillouin zone symmetries. Uses misc spglib_wrapper params crystal_module Contents Derived Types symmetry Functions fbz2ibz Subroutines find_equiv_map find_irred_wedge create_fbz2ibz_map symmetrize_3x3_tensor Derived Types type, public :: symmetry Data and procedure related to symmetries. Components Type Visibility Attributes Name Initial integer(kind=i64), public :: nsymm Number of spacegroup symmetries. integer(kind=i64), public :: nsymm_rot Number of rotations. integer(kind=i64), public, allocatable :: rotations_orig (:,:,:) Rotations without time-reversal, real space, crystal coordinates. real(kind=r64), public, allocatable :: crotations_orig (:,:,:) Rotations without time-reversal, real space, Cartesian coordinates. real(kind=r64), public, allocatable :: qrotations_orig (:,:,:) Rotations without time-reversal, reciprocal space, crystal coordinates. integer(kind=i64), public, allocatable :: rotations (:,:,:) Rotations with time-reversal, real space, crystal coordinates. real(kind=r64), public, allocatable :: crotations (:,:,:) Rotations with time-reversal, real space, Cartesian coordinates. real(kind=r64), public, allocatable :: qrotations (:,:,:) Rotations with time-reversal, reciprocal space, crystal coordinates. character(len=10), public :: international Spacegroup in Hermann–Mauguin (or international) notation. Type-Bound Procedures procedure\n                    ,                  public\n                  :: calculate_symmetries Subroutine Functions public  function fbz2ibz (iwvmux, nwv_irred, nequiv, ibz2fbz_map) Find index in IBZ blocks list for a given FBZ blocks muxed vector index Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: iwvmux integer(kind=i64), intent(in) :: nwv_irred integer(kind=i64), intent(in) :: nequiv (nwv_irred) integer(kind=i64), intent(in) :: ibz2fbz_map (:,:,:) Return Value integer(kind=i64) Subroutines public  subroutine find_equiv_map (nsymm_rot, equiv_map, mesh, qrotations, indexlist) Subroutine to create the map of equivalent wave vectors. Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: nsymm_rot integer(kind=i64), intent(out) :: equiv_map (:,:) integer(kind=i64), intent(in) :: mesh (3) real(kind=r64), intent(in) :: qrotations (:,:,:) integer(kind=i64), intent(in), optional :: indexlist (:) public  subroutine find_irred_wedge (mesh, nwavevecs_irred, wavevecs_irred, indexlist_irred, nequivalent, nsymm_rot, qrotations, ibz2fbz_map, equivalence_map, blocks, indexlist) Find the irreducible wedge of the FBZ and other quantities.\nWedge finding algorithm is inspired by ShengBTE. Read more… Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: mesh (3) integer(kind=i64), intent(out) :: nwavevecs_irred real(kind=r64), intent(out), allocatable :: wavevecs_irred (:,:) integer(kind=i64), intent(out), allocatable :: indexlist_irred (:) integer(kind=i64), intent(out), allocatable :: nequivalent (:) integer(kind=i64), intent(in) :: nsymm_rot real(kind=r64), intent(in) :: qrotations (:,:,:) integer(kind=i64), intent(out), allocatable :: ibz2fbz_map (:,:,:) integer(kind=i64), intent(out), allocatable :: equivalence_map (:,:) logical, intent(in) :: blocks integer(kind=i64), intent(in), optional :: indexlist (:) public  subroutine create_fbz2ibz_map (fbz2ibz_map, nwv, nwv_irred, indexlist, nequiv, ibz2fbz_map) Subroutine to create map of FBZ blocks to IBZ blocks Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(out), allocatable :: fbz2ibz_map (:) integer(kind=i64), intent(in) :: nwv integer(kind=i64), intent(in) :: nwv_irred integer(kind=i64), intent(in) :: indexlist (nwv) integer(kind=i64), intent(in) :: nequiv (nwv_irred) integer(kind=i64), intent(in) :: ibz2fbz_map (:,:,:) public  subroutine symmetrize_3x3_tensor (tensor, crotations) Symmetrize a 3x3 tensor. Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: tensor (3,3) real(kind=r64), intent(in) :: crotations (:,:,:)","tags":"","loc":"module/symmetry_module.html"},{"title":"bz_sums – elphbolt","text":"Module containing the procedures to do Brillouin zone sums. Uses electron_module crystal_module symmetry_module delta phonon_module params misc Contents Interfaces calculate_dos Subroutines calculate_qTF calculate_el_dos_Fermi calculate_el_Ws calculate_transport_coeff calculate_spectral_transport_coeff calculate_mfp_cumulative_transport_coeff Interfaces public        interface calculate_dos private  subroutine calculate_el_dos(el, usetetra) Calculate the density of states (DOS) in units of 1/energy. \nThe DOS will be evaluates on the IBZ mesh energies. el Electron data type\nusetetra Use the tetrahedron method for delta functions? Arguments Type Intent Optional Attributes Name type( electron ), intent(inout) :: el logical, intent(in) :: usetetra private  subroutine calculate_ph_dos_iso(ph, usetetra, gfactors, subs_gfactors, atomtypes, W_phiso, W_phsubs, phiso, phsubs) Calculate the phonon density of states (DOS) in units of 1/energy and,\noptionally, the phonon-isotope scattering rates. The DOS and isotope scattering rates will be evaluates on the IBZ mesh energies. ph Phonon data type\nusetetra Use the tetrahedron method for delta functions? Arguments Type Intent Optional Attributes Name type( phonon ), intent(inout) :: ph logical, intent(in) :: usetetra real(kind=r64), intent(in) :: gfactors (:) real(kind=r64), intent(in) :: subs_gfactors (:) integer(kind=i64), intent(in) :: atomtypes (:) real(kind=r64), intent(out), allocatable :: W_phiso (:,:) real(kind=r64), intent(out), allocatable :: W_phsubs (:,:) logical, intent(in) :: phiso logical, intent(in) :: phsubs Subroutines public  subroutine calculate_qTF (crys, el) Calculate Thomas-Fermi screening wavevector in the simple electron-gas model. Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: crys type( electron ), intent(in) :: el public  subroutine calculate_el_dos_Fermi (el, usetetra) Calculate spin-normalized electron density of states at the Fermi level Read more… Arguments Type Intent Optional Attributes Name type( electron ), intent(inout) :: el logical, intent(in) :: usetetra public  subroutine calculate_el_Ws (el, usetetra) Calculate all electron delta functions scaled by spin-normalized DOS(Ef)\nW_mk = delta[E_mk - Ef]/DOS(Ef) Arguments Type Intent Optional Attributes Name type( electron ), intent(inout) :: el logical, intent(in) :: usetetra public  subroutine calculate_transport_coeff (species_prefix, field, T, deg, chempot, ens, vels, volume, mesh, response, sym, trans_coeff_hc, trans_coeff_cc) Subroutine to calculate transport coefficients. Read more… Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: species_prefix character(len=1), intent(in) :: field real(kind=r64), intent(in) :: T integer(kind=i64), intent(in) :: deg real(kind=r64), intent(in) :: chempot real(kind=r64), intent(in) :: ens (:,:) real(kind=r64), intent(in) :: vels (:,:,:) real(kind=r64), intent(in) :: volume integer(kind=i64), intent(in) :: mesh (3) real(kind=r64), intent(in) :: response (:,:,:) type( symmetry ), intent(in) :: sym real(kind=r64), intent(out) :: trans_coeff_hc (:,:,:) real(kind=r64), intent(out) :: trans_coeff_cc (:,:,:) public  subroutine calculate_spectral_transport_coeff (species, field, T, deg, chempot, ens, vels, volume, response, en_grid, usetetra, sym, trans_coeff_hc, trans_coeff_cc) Subroutine to calculate the spectral transport coefficients. Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: species character(len=1), intent(in) :: field real(kind=r64), intent(in) :: T integer(kind=i64), intent(in) :: deg real(kind=r64), intent(in) :: chempot real(kind=r64), intent(in) :: ens (:,:) real(kind=r64), intent(in) :: vels (:,:,:) real(kind=r64), intent(in) :: volume real(kind=r64), intent(in) :: response (:,:,:) real(kind=r64), intent(in) :: en_grid (:) logical, intent(in) :: usetetra type( symmetry ), intent(in) :: sym real(kind=r64), intent(out) :: trans_coeff_hc (:,:,:,:) real(kind=r64), intent(out) :: trans_coeff_cc (:,:,:,:) public  subroutine calculate_mfp_cumulative_transport_coeff (species_prefix, field, T, deg, chempot, ens, vels, mesh, volume, response, mfp_grid_sampling, mfps, sym, trans_coeff_hc) Subroutine to calculate the mean-free-path cumulative transport coefficients. Read more… Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: species_prefix character(len=1), intent(in) :: field real(kind=r64), intent(in) :: T integer(kind=i64), intent(in) :: deg real(kind=r64), intent(in) :: chempot real(kind=r64), intent(in) :: ens (:,:) real(kind=r64), intent(in) :: vels (:,:,:) integer(kind=i64), intent(in) :: mesh (3) real(kind=r64), intent(in) :: volume real(kind=r64), intent(in) :: response (:,:,:) real(kind=r64), intent(in) :: mfp_grid_sampling (:) real(kind=r64), intent(in) :: mfps (:,:) type( symmetry ), intent(in) :: sym real(kind=r64), intent(out) :: trans_coeff_hc (:,:,:,:)","tags":"","loc":"module/bz_sums.html"},{"title":"numerics_module – elphbolt","text":"Module containing type and procedures related to the numerics. Uses misc params crystal_module Contents Derived Types numerics Derived Types type, public :: numerics Data and procedures related to the numerics. Components Type Visibility Attributes Name Initial integer(kind=i64), public :: qmesh (3) Phonon wave vector mesh. integer(kind=i64), public :: mesh_ref Electron mesh refinement factor compared to the phonon mesh. real(kind=r64), public :: fsthick Fermi surface thickness in eV. character(len=1024), public :: cwd Current working directory. character(len=1024), public :: datadumpdir Runtime data dump repository. character(len=1024), public :: datadumpdir_T Runtime temperature dependent data dump repository. character(len=1024), public :: datadumpdir_T_chempot Runtime temperature and chemical potential dependent data dump repository. character(len=1024), public :: g2dir Directory for e-ph vertex. character(len=1024), public :: Vdir Directory for ph-ph vertex. character(len=1024), public :: Wdir Directory for ph-ph transition rates. character(len=1024), public :: Xdir Directory for e-ph transition rates. character(len=1024), public :: Ydir Directory for ph-e transition rates. character(len=1024), public :: scdir Directory for the superconductivity temporary data. logical, public :: read_gq2 Choose if earlier e-ph (IBZ q) vertices are to be used. logical, public :: read_gk2 Choose if earlier e-ph (IBZ k) vertices are to be used. logical, public :: read_V Choose if earlier ph-ph (IBZ q) vertices are to be used. logical, public :: read_W Choose if earlier ph-ph (IBZ q) transition probabilities are to be used. logical, public :: tetrahedra Choose if the tetrahedron method for 3d delta function evaluation will be used. logical, public :: phe Choose if ph-e interaction will be included. logical, public :: phiso Use phonon-isotope scattering? logical, public :: phsubs Use phonon-substitution scattering? logical, public :: phbound Use phonon-boundary scattering? logical, public :: fourph Use 4-ph scattering? integer(kind=i64), public :: fourph_mesh_ref Mesh refinement factor of phonon wavectors with respect to external 4-ph calculation logical, public :: phthinfilm Use phonon-thin-film scattering? logical, public :: phdef_Tmat Calculate phonon-defect scattering T-matrix? logical, public :: onlyphbte Choose if only phonon BTE will be solved. logical, public :: onlyebte Choose if electron BTE will be solved. logical, public :: elchimp Use electron-charged impurity scattering? logical, public :: elbound Use electron-boundary scattering? logical, public :: drag Choose if the drag effect will be included. integer(kind=i64), public :: maxiter Maximum number of iterations in the BTE/Migdal-Eliashberg equations solver. real(kind=r64), public :: conv_thres BTE/Migdal-Eliashberg euqations iteration convergence criterion. logical, public :: plot_along_path Plot Wannierized quantities along high symmetry wave vectors? integer(kind=i64), public :: runlevel Control for the type of calculation. real(kind=r64), public :: ph_en_min Bounds of equidistant phonon energy mesh. real(kind=r64), public :: ph_en_max Bounds of equidistant phonon energy mesh. integer(kind=i64), public :: ph_en_num Number of equidistant phonon energy mesh points. real(kind=r64), public :: el_en_min Bounds of equidistant electron energy mesh. real(kind=r64), public :: el_en_max Bounds of equidistant electron energy mesh. integer(kind=i64), public :: el_en_num Number of equidistant electron energy mesh points. integer(kind=i64), public :: ph_mfp_npts Number of equidistant phonon mean-free-path mesh points. Type-Bound Procedures procedure\n                    ,                  public\n                  :: create_chempot_dirs Subroutine procedure\n                    ,                  public\n                  :: initialize =>\n                    read_input_and_setup Subroutine","tags":"","loc":"module/numerics_module.html"},{"title":"crystal_module – elphbolt","text":"Module containing type and procedures related to the crystal structure. Uses misc params Contents Derived Types crystal Subroutines calculate_wavevectors_full Derived Types type, public :: crystal Data and procedures related to the crystal structure. Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numelements Number of types of basis atoms. integer(kind=i64), public :: numatoms Number of basis atoms. character(len=100), public :: name Name of material. character(len=3), public, allocatable :: elements (:) Elements in the basis. integer(kind=i64), public, allocatable :: atomtypes (:) Integer tagging unique elements in the basis. real(kind=r64), public, allocatable :: masses (:) Masses of the basis atoms. logical, public :: polar Is the system polar? real(kind=r64), public :: epsilon (3,3) Dielectric tensor. real(kind=r64), public, allocatable :: born (:,:,:) Born effective charge. real(kind=r64), public :: epsilon0 Static dielectric constant. logical, public :: read_epsiloninf Read high-frequency dielectric constant? real(kind=r64), public :: epsiloninf High frequency dielectric constant. real(kind=r64), public :: qTF Thomas-Fermi screening wave vector. real(kind=r64), public, allocatable :: basis (:,:) Basis vectors (crystal coordinates). real(kind=r64), public, allocatable :: basis_cart (:,:) Basis vectors (Cartesian coordinates). real(kind=r64), public :: lattvecs (3,3) Lattice vectors (nm). real(kind=r64), public :: volume Volume of primitive cell (nm&#94;3). real(kind=r64), public :: reclattvecs (3,3) Reciprocal lattice vectors. real(kind=r64), public :: volume_bz Brillouin zone volume (nm&#94;-3). real(kind=r64), public :: T Crystal temperature (K). logical, public :: autoisotopes Use isotopic mix for masses? real(kind=r64), public, allocatable :: gfactors (:) g-factors. real(kind=r64), public, allocatable :: subs_masses (:) Masses of the substitutional atoms [D] real(kind=r64), public, allocatable :: subs_conc (:) Concentration of the substitutional atoms in cm&#94;-3 [D] real(kind=r64), public, allocatable :: subs_gfactors (:) g-factors for the substitutional defects. [D] integer(kind=i64), public, allocatable :: defect_hosts (:) Basis atom sites that can be a host for an impurity, one for each unique element. integer(kind=i64), public, allocatable :: numdopants_types (:) Number of dopant types at each host atom site. real(kind=r64), public, allocatable :: dopant_masses (:,:) Masses of the dopants at each host atom site. real(kind=r64), public, allocatable :: dopant_conc (:,:) Concentrations [cm&#94;-3] of the dopants at each host atom site. logical, public :: twod Is the system 2d? real(kind=r64), public :: dim Dimension of the system real(kind=r64), public :: thickness Thickness of the system real(kind=r64), public :: bound_length Characteristic boundary scattering length in mm real(kind=r64), public :: thinfilm_height Height of thin-film in mm character(len=1), public :: thinfilm_normal Normal direction of the thin-film: 'x', 'y', or 'z'. Type-Bound Procedures procedure\n                    ,                  public\n                  :: initialize =>\n                    read_input_and_setup_crystal Subroutine Subroutines public  subroutine calculate_wavevectors_full (mesh, wavevecs, blocks, indexlist) Calculate wave vectors (crystal coords.) of the full Brillouin zone (FBZ) Read more… Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: mesh (3) real(kind=r64), intent(out), allocatable :: wavevecs (:,:) logical, intent(in) :: blocks integer(kind=i64), intent(in), optional :: indexlist (:)","tags":"","loc":"module/crystal_module.html"},{"title":"wannier_module – elphbolt","text":"Module containing type and procedures related to Wannierization. Uses misc numerics_module params crystal_module Contents Derived Types epw_wannier Derived Types type, public :: epw_wannier Data and procedures related to Wannierization. Components Type Visibility Attributes Name Initial integer(kind=i64), public :: numwannbands Number of Wannier bands. integer(kind=i64), public :: numbranches Number of phonon branches. integer(kind=i64), public :: nwsk Number of real space cells for electrons. integer(kind=i64), public :: coarse_qmesh (3) Coarse phonon wave vector mesh in Wannier calculation. integer(kind=i64), public :: nwsq Number of real space cells for phonons. integer(kind=i64), public :: nwsg Number of real space cells for electron-phonon vertex. integer(kind=i64), public, allocatable :: rcells_k (:,:) Real space cell locations for electrons. integer(kind=i64), public, allocatable :: rcells_q (:,:) Real space cell locations for phonons. integer(kind=i64), public, allocatable :: rcells_g (:,:) Real space cell locations for electron-phonon vertex. integer(kind=i64), public, allocatable :: elwsdeg (:) Real space cell multiplicity for electrons. integer(kind=i64), public, allocatable :: phwsdeg (:) Real space cell multiplicity for phonons. integer(kind=i64), public, allocatable :: gwsdeg (:) Real space cell multiplicity for electron-phonon vertex. complex(kind=r64), public, allocatable :: Hwann (:,:,:) Hamiltonian in Wannier representation. complex(kind=r64), public, allocatable :: Dphwann (:,:,:) Dynamical matrix in Wannier representation. complex(kind=r64), public, allocatable :: gwann (:,:,:,:,:) e-ph vertex in Wannier representation. Type-Bound Procedures procedure\n                    ,                  public\n                  :: plot_along_path Subroutine procedure\n                    ,                  public\n                  :: deallocate_wannier Subroutine procedure\n                    ,                  public\n                  :: g2_epw Function procedure\n                    ,                  public\n                  :: gReq_epw Subroutine procedure\n                    ,                  public\n                  :: gkRp_epw Subroutine procedure\n                    ,                  public\n                  :: ph_wann_epw Subroutine procedure\n                    ,                  public\n                  :: el_wann_epw Subroutine procedure\n                    ,                  public\n                  :: read =>\n                    read_EPW_Wannier Subroutine","tags":"","loc":"module/wannier_module.html"},{"title":"fc2_parser_qe – elphbolt","text":"Uses Ancestors: FC2_parser_factory_module Contents None","tags":"","loc":"module/fc2_parser_qe.html"},{"title":"fc2_parser_siesta – elphbolt","text":"Uses Ancestors: FC2_parser_factory_module Contents None","tags":"","loc":"module/fc2_parser_siesta.html"},{"title":"supersweet – elphbolt","text":"Uses electron_module crystal_module numerics_module MigEl_sc_module bz_sums phonon_module misc eliashberg params wannier_module interactions symmetry_module supersweet is the superconductivity suite of elphbolt.\n This is a solver for the Migdal-Eliashberg equations as described in\n E. R. Margine and F. Giustino, Phys. Rev. B 87, 024505 (2013). $  !DEBUG For now calling with a random value of temperature\n$  call migel%generate_matsubara_meshes(300.0_r64, maxval(ph%ens(:,:))) $  !Calculate phonon density of states\n$  call calculate_dos(ph, num%tetrahedra, crys%gfactors, crys%subs_gfactors, &\n$       crys%atomtypes) $  !After this point the phonon eigenvectors and other quantities are not needed\n$  call ph%deallocate_phonon_quantities $  call calculate_lambda(wann, el, num, migel%omegas, migel%iso_lambda0, migel%omegalog, migel%bose_matsubara_ens, migel%isotropic) Contents Variables num crys sym wann el ph migel t_all t_event Variables Type Attributes Name Initial type( numerics ) :: num type( crystal ) :: crys type( symmetry ) :: sym type( epw_wannier ) :: wann type( electron ) :: el type( phonon ) :: ph type( MigEl_sc ) :: migel type( timer ) :: t_all type( timer ) :: t_event","tags":"","loc":"program/supersweet.html"},{"title":"misc.f90 – elphbolt","text":"Contents Modules misc Source Code misc.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module misc !! Module containing miscellaneous math and numerics related functions and subroutines. use params , only : r64 , i64 , kB implicit none public private :: sort_int , sort_real , Pade_coeffs , twonorm_real_rank1 , twonorm_real_rank2 , & invert_complex_square type timer !! Container for timing related data and procedures. integer ( i64 ) :: rate = 0 integer ( i64 ) :: start = - 1 integer ( i64 ) :: end = - 1 character ( len = :), allocatable :: event contains procedure :: start_timer , end_timer end type timer interface sort module procedure :: sort_int , sort_real end interface sort interface twonorm module procedure :: twonorm_real_rank1 , twonorm_real_rank2 end interface twonorm interface invert module procedure :: invert_complex_square end interface invert contains subroutine start_timer ( self , event ) !! Start/Reset the timer. This is a blocking call. !! Only image 1 can modify timing information. class ( timer ), intent ( out ) :: self character ( len = * ), intent ( in ) :: event sync all if ( this_image () == 1 ) then !Set the clock rate call system_clock ( count_rate = self % rate ) !Clock in call system_clock ( count = self % start ) !(Re)set the event name self % event = event end if end subroutine start_timer subroutine end_timer ( self , event ) !! End the timer and print the elapsed time. This is a blocking call. !! Only image 1 can modify timing information. class ( timer ), intent ( inout ) :: self character ( len = * ), intent ( in ) :: event !Local variable real ( r64 ) :: time_elapsed sync all if ( this_image () == 1 ) then !Clock in call system_clock ( count = self % end ) !Check the event name and if clock-in happened if (( event /= self % event ) . or . ( self % start == - 1_i64 )) then call exit_with_message ( 'Clock-in event does not match this clock-out event.' ) end if !Calculate and print time taken for this event time_elapsed = dble ( self % end - self % start ) / self % rate / 360 0.0_r64 !hours write ( * , \"(A)\" ) \"..............\" write ( * , \"(A, A, 1E16.8, A)\" ) \"| Timing info: \" , trim ( event ), time_elapsed , \" hr\" write ( * , \"(A)\" ) \"..............\" end if end subroutine end_timer subroutine linspace ( grid , min , max , num ) !! Create equidistant grid. real ( r64 ), allocatable , intent ( out ) :: grid (:) real ( r64 ), intent ( in ) :: min , max integer ( i64 ), intent ( in ) :: num !Local variables integer ( i64 ) :: i real ( r64 ) :: spacing !Allocate grid array allocate ( grid ( num )) !Calculate grid spacing spacing = ( max - min ) / dble ( num - 1 ) !Calculate grid do i = 1 , num grid ( i ) = min + ( i - 1 ) * spacing end do end subroutine linspace subroutine exit_with_message ( message ) !! Exit with error message. character ( len = * ), intent ( in ) :: message if ( this_image () == 1 ) then write ( * , \"(A)\" ) trim ( message ) stop end if end subroutine exit_with_message subroutine print_message ( message ) !! Print message. character ( len = * ), intent ( in ) :: message if ( this_image () == 1 ) write ( * , \"(A)\" ) trim ( message ) end subroutine print_message subroutine write2file_rank1_real ( filename , data ) !! Write rank-1 data to file. character ( len = * ), intent ( in ) :: filename real ( r64 ), intent ( in ) :: data (:) integer ( i64 ) :: ik , nk nk = size ( data (:)) if ( this_image () == 1 ) then open ( 1 , file = trim ( filename ), status = \"replace\" ) do ik = 1 , nk write ( 1 , \"(E20.10)\" ) data ( ik ) end do close ( 1 ) end if sync all end subroutine write2file_rank1_real subroutine write2file_rank2_real ( filename , data ) !! Write rank-2 data to file. character ( len = * ), intent ( in ) :: filename real ( r64 ), intent ( in ) :: data (:,:) integer ( i64 ) :: ik , nk character ( len = 1024 ) :: numcols nk = size ( data (:, 1 )) write ( numcols , \"(I0)\" ) size ( data ( 1 , :)) if ( this_image () == 1 ) then open ( 1 , file = trim ( filename ), status = \"replace\" ) do ik = 1 , nk write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & data ( ik , :) end do close ( 1 ) end if sync all end subroutine write2file_rank2_real subroutine write2file_rank3_real ( filename , data ) !! Write rank-3 data to file. character ( len = * ), intent ( in ) :: filename real ( r64 ), intent ( in ) :: data (:,:,:) integer ( i64 ) :: ik , nk character ( len = 1024 ) :: numcols nk = size ( data (:, 1 , 1 )) write ( numcols , \"(I0)\" ) size ( data ( 1 , :, 1 )) * size ( data ( 1 , 1 , :)) if ( this_image () == 1 ) then open ( 1 , file = trim ( filename ), status = \"replace\" ) do ik = 1 , nk write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & data ( ik , :, :) end do close ( 1 ) end if end subroutine write2file_rank3_real subroutine write2file_response ( filename , data , bandlist ) !! Write list of vectors to band/branch resolved files. character ( len = * ), intent ( in ) :: filename real ( r64 ), intent ( in ) :: data (:,:,:) integer ( i64 ), intent ( in ), optional :: bandlist (:) !Local variables integer ( i64 ) :: ib , ibstart , ibend , nb , ik , nk , dim character ( len = 1 ) :: numcols character ( len = 1024 ) :: bandtag real ( r64 ), allocatable :: aux (:,:) if ( this_image () == 1 ) then nk = size ( data (:, 1 , 1 )) if ( present ( bandlist )) then nb = size ( bandlist ) ibstart = bandlist ( 1 ) ibend = bandlist ( nb ) else nb = size ( data ( 1 , :, 1 )) ibstart = 1 ibend = nb end if dim = size ( data ( 1 , 1 , :)) write ( numcols , \"(I0)\" ) dim !Band/branch summed open ( 1 , file = trim ( filename // \"tot\" ), status = \"replace\" ) allocate ( aux ( nk , 3 )) aux = sum ( data , dim = 2 ) do ik = 1 , nk write ( 1 , \"(3(1E20.10),x)\" ) aux ( ik , :) end do close ( 1 ) !Band/branch resolved do ib = ibstart , ibend write ( bandtag , \"(I0)\" ) ib open ( 2 , file = trim ( filename // bandtag ), status = \"replace\" ) do ik = 1 , nk write ( 2 , \"(3(1E20.10),x)\" ) data ( ik , ib , :) end do close ( 2 ) end do end if sync all end subroutine write2file_response subroutine readfile_response ( filename , data , bandlist ) !! Read list of vectors to band/branch resolved files. character ( len = * ), intent ( in ) :: filename real ( r64 ), intent ( out ) :: data (:,:,:) integer ( i64 ), intent ( in ), optional :: bandlist (:) !Local variables integer ( i64 ) :: ib , ibstart , ibend , nb , ik , nk , dim character ( len = 1 ) :: numcols character ( len = 1024 ) :: bandtag nk = size ( data (:, 1 , 1 )) if ( present ( bandlist )) then nb = size ( bandlist ) ibstart = bandlist ( 1 ) ibend = bandlist ( nb ) else nb = size ( data ( 1 , :, 1 )) ibstart = 1 ibend = nb end if dim = size ( data ( 1 , 1 , :)) write ( numcols , \"(I0)\" ) dim !Band/branch resolved do ib = ibstart , ibend write ( bandtag , \"(I0)\" ) ib open ( 1 , file = trim ( filename // bandtag ), status = \"old\" ) do ik = 1 , nk read ( 1 , * ) data ( ik , ib , :) end do close ( 1 ) end do sync all end subroutine readfile_response subroutine append2file_transport_tensor ( filename , it , data , bandlist ) !! Append 3x3 tensor to band/branch resolved files. character ( len = * ), intent ( in ) :: filename integer ( i64 ), intent ( in ) :: it real ( r64 ), intent ( in ) :: data (:,:,:) integer ( i64 ), intent ( in ), optional :: bandlist (:) !Local variables integer ( i64 ) :: ib , nb , ibstart , ibend character ( len = 1 ) :: numcols character ( len = 1024 ) :: bandtag if ( this_image () == 1 ) then if ( present ( bandlist )) then nb = size ( bandlist ) ibstart = bandlist ( 1 ) ibend = bandlist ( nb ) else nb = size ( data (:, 1 , 1 )) ibstart = 1 ibend = nb end if write ( numcols , \"(I0)\" ) 9 !Band/branch summed if ( it == 0 ) then open ( 1 , file = trim ( filename // \"tot\" ), status = \"replace\" ) else open ( 1 , file = trim ( filename // \"tot\" ), access = \"append\" , status = \"old\" ) end if write ( 1 , \"(I3, \" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & it , sum ( data , dim = 1 ) close ( 1 ) !Band/branch resolved do ib = ibstart , ibend write ( bandtag , \"(I0)\" ) ib if ( it == 0 ) then open ( 2 , file = trim ( filename // bandtag ), status = \"replace\" ) else open ( 2 , file = trim ( filename // bandtag ), access = \"append\" , status = \"old\" ) end if write ( 2 , \"(I3, \" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & it , data ( ib , :, :) close ( 2 ) end do end if sync all end subroutine append2file_transport_tensor subroutine write2file_spectral_tensor ( filename , data , bandlist ) !! Append 3x3 spectral transport tensor to band/branch resolved files. character ( len = * ), intent ( in ) :: filename real ( r64 ), intent ( in ) :: data (:,:,:,:) integer ( i64 ), intent ( in ), optional :: bandlist (:) !Local variables integer ( i64 ) :: ie , ne , ib , nb , ibstart , ibend character ( len = 1 ) :: numcols character ( len = 1024 ) :: bandtag real ( r64 ) :: aux ( 3 , 3 ) if ( this_image () == 1 ) then !Number of energy points on grid ne = size ( data ( 1 , 1 , 1 , :)) !Number of bands/branches and bounds if ( present ( bandlist )) then nb = size ( bandlist ) ibstart = bandlist ( 1 ) ibend = bandlist ( nb ) else nb = size ( data (:, 1 , 1 , 1 )) ibstart = 1 ibend = nb end if write ( numcols , \"(I0)\" ) 9 !Band/branch summed open ( 1 , file = trim ( filename // \"tot\" ), status = \"replace\" ) do ie = 1 , ne aux = 0.0_r64 do ib = ibstart , ibend aux (:,:) = aux (:,:) + data ( ib , :, :, ie ) end do write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) aux end do close ( 1 ) !Band/branch resolved do ib = ibstart , ibend write ( bandtag , \"(I0)\" ) ib open ( 2 , file = trim ( filename // bandtag ), status = \"replace\" ) do ie = 1 , ne write ( 2 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & data ( ib , :, :, ie ) end do close ( 2 ) end do end if sync all end subroutine write2file_spectral_tensor subroutine int_div ( num , denom , q , r ) !! Quotient(q) and remainder(r) of the integer division num/denom. integer ( i64 ), intent ( in ) :: num , denom integer ( i64 ), intent ( out ) :: q , r q = num / denom r = mod ( num , denom ) end subroutine int_div subroutine distribute_points ( npts , chunk , istart , iend , num_active_images ) !! Distribute points among processes integer ( i64 ), intent ( in ) :: npts integer ( i64 ), intent ( out ) :: chunk , istart , iend , num_active_images !Number of active images num_active_images = min ( npts , num_images ()) !Number of points per process chunk = ceiling ( dble ( npts ) / num_images ()) !Start index istart = ( this_image () - 1 ) * chunk + 1 !End index iend = min ( chunk * this_image (), npts ) !Update chunk if ( istart < iend ) then chunk = iend - istart + 1 else chunk = 1 end if end subroutine distribute_points pure function cross_product ( A , B ) !! Cross product of A and B. real ( r64 ), intent ( in ) :: A ( 3 ), B ( 3 ) real ( r64 ) :: cross_product ( 3 ) cross_product ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) cross_product ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) cross_product ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) end function cross_product pure integer ( i64 ) function kronecker ( i , j ) !! Kronecker delta integer ( i64 ), intent ( in ) :: i , j if ( i == j ) then kronecker = 1 else kronecker = 0 end if end function kronecker pure complex ( r64 ) function expi ( x ) !! Calculate exp(i*x) = cos(x) + isin(x) real ( r64 ), intent ( in ) :: x expi = cmplx ( cos ( x ), sin ( x ), r64 ) end function expi pure real ( r64 ) function twonorm_real_rank1 ( v ) !! 2-norm of a rank-1 real vector real ( r64 ), intent ( in ) :: v (:) integer ( i64 ) :: i , s s = size ( v ) twonorm_real_rank1 = 0.0_r64 do i = 1 , s twonorm_real_rank1 = v ( i ) ** 2 + twonorm_real_rank1 end do twonorm_real_rank1 = sqrt ( twonorm_real_rank1 ) end function twonorm_real_rank1 pure real ( r64 ) function twonorm_real_rank2 ( T ) !! Custom 2-norm of a rank-2 real tensor real ( r64 ), intent ( in ) :: T (:, :) integer ( i64 ) :: i , j , s1 , s2 s1 = size ( T (:, 1 )) s2 = size ( T ( 1 , :)) twonorm_real_rank2 = 0.0_r64 do i = 1 , s1 do j = 1 , s2 twonorm_real_rank2 = T ( i , j ) ** 2 + twonorm_real_rank2 end do end do twonorm_real_rank2 = sqrt ( twonorm_real_rank2 ) end function twonorm_real_rank2 pure real ( r64 ) function trace ( mat ) !! Trace of square matrix real ( r64 ), intent ( in ) :: mat (:,:) integer ( i64 ) :: i , dim dim = size ( mat (:, 1 )) trace = 0.0_r64 do i = 1 , dim trace = trace + mat ( i , i ) end do end function trace subroutine sort_int ( list ) !! Swap sort list of integers integer ( i64 ), intent ( inout ) :: list (:) integer ( i64 ) :: i , j , n integer ( i64 ) :: aux , tmp n = size ( list ) do i = 1 , n aux = list ( i ) do j = i + 1 , n if ( aux > list ( j )) then tmp = list ( j ) list ( j ) = aux list ( i ) = tmp aux = tmp end if end do end do end subroutine sort_int subroutine sort_real ( list ) !! Swap sort list of reals real ( r64 ), intent ( inout ) :: list (:) real ( r64 ) :: aux , tmp integer ( i64 ) :: i , j , n n = size ( list ) do i = 1 , n aux = list ( i ) do j = i + 1 , n if ( aux > list ( j )) then tmp = list ( j ) list ( j ) = aux list ( i ) = tmp aux = tmp end if end do end do end subroutine sort_real subroutine binsearch ( array , e , m ) !! Binary search in a list of integers and return index. integer ( i64 ), intent ( in ) :: array (:), e integer ( i64 ), intent ( out ) :: m integer ( i64 ) :: a , b , mid a = 1 b = size ( array ) m = ( b + a ) / 2 mid = array ( m ) do while ( mid /= e ) if ( e > mid ) then a = m + 1 else if ( e < mid ) then b = m - 1 end if if ( a > b ) then m = - 1 exit end if m = ( b + a ) / 2 mid = array ( m ) end do end subroutine binsearch subroutine compsimps ( f , h , s ) !! Composite Simpson's rule for real function !! f integrand !! h integration variable spacing !! s result real ( r64 ), intent ( in ) :: h , f (:) real ( r64 ), intent ( out ) :: s !Local variables integer ( i64 ) :: i , numint , n real ( r64 ) :: a , b n = size ( f ) s = 0.0_r64 a = f ( 1 ) !If n is odd then number of intervals is even, carry on. !Otherwise, do trapezoidal rule in the last interval. if ( mod ( n , 2 ) /= 0 ) then numint = n - 1 b = f ( n ) else !Note: Number of sample points is even, so !I will do trapezoidal rule in the last interval. numint = n - 2 b = f ( n - 1 ) end if s = s + a + b !even sites do i = 2 , numint , 2 s = s + 4.0_r64 * f ( i ) end do !odd sites do i = 3 , numint , 2 s = s + 2.0_r64 * f ( i ) end do s = s * h / 3.0_r64 if ( mod ( n , 2 ) == 0 ) then !trapezoidal rule s = s + 0.5_r64 * ( f ( n ) + f ( n - 1 )) * h end if end subroutine compsimps function mux_vector ( v , mesh , base ) !! Multiplex index of a single wave vector. !! v is the demultiplexed triplet of a wave vector. !! i is the multiplexed index of a wave vector (always 1-based). !! mesh is the number of wave vectors along the three reciprocal lattice vectors. !! base states whether v has 0- or 1-based indexing. integer ( i64 ), intent ( in ) :: v ( 3 ), mesh ( 3 ), base integer ( i64 ) :: mux_vector if ( base < 0 . or . base > 1 ) then call exit_with_message ( \"Base has to be either 0 or 1 in misc.f90:mux_vector\" ) end if if ( base == 0 ) then mux_vector = ( v ( 3 ) * mesh ( 2 ) + v ( 2 )) * mesh ( 1 ) + v ( 1 ) + 1 else mux_vector = (( v ( 3 ) - 1 ) * mesh ( 2 ) + ( v ( 2 ) - 1 )) * mesh ( 1 ) + v ( 1 ) end if end function mux_vector subroutine demux_vector ( i , v , mesh , base ) !! Demultiplex index of a single wave vector. !! i is the multiplexed index of a wave vector (always 1-based). !! v is the demultiplexed triplet of a wave vector. !! mesh is the number of wave vectors along the three reciprocal lattice vectors. !! base chooses whether v has 0- or 1-based indexing. integer ( i64 ), intent ( in ) :: i , mesh ( 3 ), base integer ( i64 ), intent ( out ) :: v ( 3 ) integer ( i64 ) :: aux if ( base < 0 . or . base > 1 ) then call exit_with_message ( \"Base has to be either 0 or 1 in misc.f90:demux_vector\" ) end if call int_div ( i - 1 , mesh ( 1 ), aux , v ( 1 )) call int_div ( aux , mesh ( 2 ), v ( 3 ), v ( 2 )) if ( base == 1 ) then v ( 1 ) = v ( 1 ) + 1 v ( 2 ) = v ( 2 ) + 1 v ( 3 ) = v ( 3 ) + 1 end if end subroutine demux_vector subroutine demux_mesh ( index_mesh , nmesh , mesh , base , indexlist ) !! Demultiplex all wave vector indices !! (optionally, from a list of indices). !! Internally uses demux_vector. integer ( i64 ), intent ( in ) :: nmesh , mesh ( 3 ), base integer ( i64 ), optional , intent ( in ) :: indexlist ( nmesh ) integer ( i64 ), intent ( out ) :: index_mesh ( 3 , nmesh ) integer ( i64 ) :: i do i = 1 , nmesh !over total number of wave vectors if ( present ( indexlist )) then call demux_vector ( indexlist ( i ), index_mesh (:, i ), mesh , base ) else call demux_vector ( i , index_mesh (:, i ), mesh , base ) end if end do end subroutine demux_mesh pure integer ( i64 ) function mux_state ( nbands , iband , ik ) !! Multiplex a (band index, wave vector index) pair into a state index !! !! nbands is the number of bands !! iband is the band index !! ik is the wave vector index integer ( i64 ), intent ( in ) :: nbands , ik , iband mux_state = ( ik - 1 ) * nbands + iband end function mux_state subroutine demux_state ( m , nbands , iband , ik ) !! Demultiplex a state index into (band index, wave vector index) pair !! !! m is the multiplexed state index !! nbands is the number of bands !! iband is the band index !! ik is the wave vector index integer ( i64 ), intent ( in ) :: m , nbands integer ( i64 ), intent ( out ) :: ik , iband iband = modulo ( m - 1 , nbands ) + 1 ik = int (( m - 1 ) / nbands ) + 1 end subroutine demux_state pure real ( r64 ) function Bose ( e , T ) !! e Energy in eV !! T temperature in K real ( r64 ), intent ( in ) :: e , T Bose = 1.0_r64 / ( exp ( e / kB / T ) - 1.0_r64 ) end function Bose pure real ( r64 ) function Fermi ( e , chempot , T ) !! e Energy in eV !! chempot Chemical potential in eV !! T temperature in K real ( r64 ), intent ( in ) :: e , chempot , T Fermi = 1.0_r64 / ( exp (( e - chempot ) / kB / T ) + 1.0_r64 ) end function Fermi subroutine interpolate ( coarsemesh , refinement , f , q , interpolation ) !! Subroutine to perform BZ interpolation. !! !! coarsemesh The coarse mesh. !! refinement The mesh refinement factor. !! f The coarse mesh function to be interpolated. !! q The 0-based index vector where to evaluate f. !! interpolation The result integer ( i64 ), intent ( in ) :: coarsemesh ( 3 ), q ( 3 ), refinement ( 3 ) real ( r64 ), intent ( in ) :: f (:) real ( r64 ), intent ( out ) :: interpolation integer ( i64 ) :: info , r0 ( 3 ), r1 ( 3 ), ipol , mode , count integer ( i64 ), allocatable :: pivot (:) integer ( i64 ) :: i000 , i100 , i010 , i110 , i001 , i101 , i011 , i111 , equalpol real ( r64 ) :: x0 , x1 , y0 , y1 , z0 , z1 , x , y , z , v ( 2 ), v0 ( 2 ), v1 ( 2 ) real ( r64 ), allocatable :: T (:, :), c (:) real ( r64 ) :: aux !External procedures external :: dgesv aux = 0.0_r64 equalpol = 0_i64 !Find on the coarse mesh the two diagonals. r0 = modulo ( floor ( q / dble ( refinement )), coarsemesh ) r1 = modulo ( ceiling ( q / dble ( refinement )), coarsemesh ) mode = 0 do ipol = 1 , 3 if ( r1 ( ipol ) == r0 ( ipol )) then mode = mode + 1 end if end do !mode = 0: 3d interpolation !mode = 1: 2d interpolation !mode = 2: 1d interpolation if ( mode == 0 ) then !3d allocate ( pivot ( 8 ), T ( 8 , 8 ), c ( 8 )) !Fine mesh point x = q ( 1 ) / dble ( refinement ( 1 ) * coarsemesh ( 1 )) y = q ( 2 ) / dble ( refinement ( 2 ) * coarsemesh ( 2 )) z = q ( 3 ) / dble ( refinement ( 3 ) * coarsemesh ( 3 )) !Coarse mesh walls x0 = floor ( q ( 1 ) / dble ( refinement ( 1 ))) / dble ( coarsemesh ( 1 )) y0 = floor ( q ( 2 ) / dble ( refinement ( 2 ))) / dble ( coarsemesh ( 2 )) z0 = floor ( q ( 3 ) / dble ( refinement ( 3 ))) / dble ( coarsemesh ( 3 )) x1 = ceiling ( q ( 1 ) / dble ( refinement ( 1 ))) / dble ( coarsemesh ( 1 )) y1 = ceiling ( q ( 2 ) / dble ( refinement ( 2 ))) / dble ( coarsemesh ( 2 )) z1 = ceiling ( q ( 3 ) / dble ( refinement ( 3 ))) / dble ( coarsemesh ( 3 )) !Coarse mesh corners i000 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 i010 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i110 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 i001 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i101 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 i011 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i111 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 !Evaluate functions at the corners and form rhs c = ( / f ( i000 ), f ( i100 ), f ( i010 ), f ( i110 ),& f ( i001 ), f ( i101 ), f ( i011 ), f ( i111 ) / ) !Form the transformation matrix T T ( 1 ,:) = ( / 1.0_r64 , x0 , y0 , z0 , x0 * y0 , x0 * z0 , y0 * z0 , x0 * y0 * z0 / ) T ( 2 ,:) = ( / 1.0_r64 , x1 , y0 , z0 , x1 * y0 , x1 * z0 , y0 * z0 , x1 * y0 * z0 / ) T ( 3 ,:) = ( / 1.0_r64 , x0 , y1 , z0 , x0 * y1 , x0 * z0 , y1 * z0 , x0 * y1 * z0 / ) T ( 4 ,:) = ( / 1.0_r64 , x1 , y1 , z0 , x1 * y1 , x1 * z0 , y1 * z0 , x1 * y1 * z0 / ) T ( 5 ,:) = ( / 1.0_r64 , x0 , y0 , z1 , x0 * y0 , x0 * z1 , y0 * z1 , x0 * y0 * z1 / ) T ( 6 ,:) = ( / 1.0_r64 , x1 , y0 , z1 , x1 * y0 , x1 * z1 , y0 * z1 , x1 * y0 * z1 / ) T ( 7 ,:) = ( / 1.0_r64 , x0 , y1 , z1 , x0 * y1 , x0 * z1 , y1 * z1 , x0 * y1 * z1 / ) T ( 8 ,:) = ( / 1.0_r64 , x1 , y1 , z1 , x1 * y1 , x1 * z1 , y1 * z1 , x1 * y1 * z1 / ) !Solve Ta = c for a, !where c is an array containing the function values at the 8 corners. call dgesv ( 8 , 1 , T , 8 , pivot , c , 8 , info ) !Approximate f(x,y,z) in terms of a. aux = c ( 1 ) + c ( 2 ) * x + c ( 3 ) * y + c ( 4 ) * z + & c ( 5 ) * x * y + c ( 6 ) * x * z + c ( 7 ) * y * z + c ( 8 ) * x * y * z else if ( mode == 1 ) then !2d allocate ( pivot ( 4 ), T ( 4 , 4 ), c ( 4 )) count = 1 do ipol = 1 , 3 if ( r1 ( ipol ) . eq . r0 ( ipol )) then equalpol = ipol else v ( count ) = q ( ipol ) / dble ( refinement ( ipol ) * coarsemesh ( ipol )) v0 ( count ) = floor ( q ( ipol ) / dble ( refinement ( ipol ))) / dble ( coarsemesh ( ipol )) v1 ( count ) = ceiling ( q ( ipol ) / dble ( refinement ( ipol ))) / dble ( coarsemesh ( ipol )) count = count + 1 end if end do i000 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 if ( equalpol . eq . 1 ) then !1st 2 subindices of i are y,z i010 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i110 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 else if ( equalpol . eq . 2 ) then !x,z i010 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 i110 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 else !x,y i010 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 i110 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 end if c = ( / f ( i000 ), f ( i010 ), f ( i100 ), f ( i110 ) / ) T ( 1 ,:) = ( / 1.0_r64 , v0 ( 1 ), v0 ( 2 ), v0 ( 1 ) * v0 ( 2 ) / ) T ( 2 ,:) = ( / 1.0_r64 , v0 ( 1 ), v1 ( 2 ), v0 ( 1 ) * v1 ( 2 ) / ) T ( 3 ,:) = ( / 1.0_r64 , v1 ( 1 ), v0 ( 2 ), v1 ( 1 ) * v0 ( 2 ) / ) T ( 4 ,:) = ( / 1.0_r64 , v1 ( 1 ), v1 ( 2 ), v1 ( 1 ) * v1 ( 2 ) / ) call dgesv ( 4 , 1 , T , 4 , pivot , c , 4 , info ) aux = c ( 1 ) + c ( 2 ) * v ( 1 ) + c ( 3 ) * v ( 2 ) + c ( 4 ) * v ( 1 ) * v ( 2 ) else !1d do ipol = 1 , 3 if ( r1 ( ipol ) /= r0 ( ipol )) then x = q ( ipol ) / dble ( refinement ( ipol ) * coarsemesh ( ipol )) x0 = floor ( q ( ipol ) / dble ( refinement ( ipol ))) / dble ( coarsemesh ( ipol )) x1 = ceiling ( q ( ipol ) / dble ( refinement ( ipol ))) / dble ( coarsemesh ( ipol )) i000 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 if ( ipol . eq . 1 ) then i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r1 ( 1 ) + 1 else if ( ipol . eq . 2 ) then i100 = ( r0 ( 3 ) * coarsemesh ( 2 ) + r1 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 else i100 = ( r1 ( 3 ) * coarsemesh ( 2 ) + r0 ( 2 )) * coarsemesh ( 1 ) + r0 ( 1 ) + 1 end if aux = f ( i000 ) + ( x - x0 ) * ( f ( i100 ) - f ( i000 )) / ( x1 - x0 ) end if end do end if interpolation = aux end subroutine interpolate pure function Pade_coeffs ( iomegas , us ) !! Evaluate eqs. A2 from the following article: !! Solving the Eliashberg equations by means of N-point Pade' approximants !! Vidberg and Serene Journal of Low Temperature Physics, Vol. 29, Nos. 3/4, 1977 complex ( r64 ), intent ( in ) :: iomegas (:) real ( r64 ), intent ( in ) :: us (:) complex ( r64 ) :: Pade_coeffs ( size ( iomegas )) !Local variables integer ( i64 ) :: N , p , i complex ( r64 ), allocatable :: g (:, :) N = size ( iomegas ) allocate ( g ( N , N )) !Base condition g ( 1 , :) = us (:) Pade_coeffs ( 1 ) = g ( 1 , 1 ) do p = 2 , N do i = p , N g ( p , i ) = ( g ( p - 1 , p - 1 ) / g ( p - 1 , i ) - 1.0_r64 ) / & ( iomegas ( i ) - iomegas ( p - 1 )) end do Pade_coeffs ( p ) = g ( p , p ) end do end function Pade_coeffs pure function Pade_continued ( iomegas , us , xs ) !! Analytically continue from the upper imaginary plane to !! the positive real axis by solving equation A3 of the following article: !! Solving the Eliashberg equations by means of N-point Pade' approximants !! Vidberg and Serene Journal of Low Temperature Physics, Vol. 29, Nos. 3/4, 1977 complex ( r64 ), intent ( in ) :: iomegas (:) real ( r64 ), intent ( in ) :: us (:) real ( r64 ), intent ( in ) :: xs (:) complex ( r64 ) :: Pade_continued ( size ( xs )) !Local variables integer ( i64 ) :: N_matsubara , N_real , i , n real ( r64 ) :: xi complex ( r64 ), allocatable :: A (:), B (:), as (:) N_matsubara = size ( iomegas ) N_real = size ( xs ) allocate ( as ( N_matsubara )) allocate ( A ( 0 : N_matsubara ), B ( 0 : N_matsubara )) as = Pade_coeffs ( iomegas , us ) !Base conditions A ( 0 ) = 0.0_r64 A ( 1 ) = as ( 1 ) B ( 0 ) = 1.0_r64 B ( 1 ) = 1.0_r64 do i = 1 , N_real xi = xs ( i ) do n = 1 , N_matsubara - 1 A ( n + 1 ) = A ( n ) + ( xi - iomegas ( n )) * as ( n + 1 ) * A ( n - 1 ) B ( n + 1 ) = B ( n ) + ( xi - iomegas ( n )) * as ( n + 1 ) * B ( n - 1 ) end do Pade_continued ( i ) = A ( N_matsubara ) / B ( N_matsubara ) end do end function Pade_continued subroutine invert_complex_square ( mat ) !! Wrapper for lapack complex matrix inversion complex ( r64 ), intent ( inout ) :: mat (:, :) !Local variables integer :: N , info , lwork complex ( r64 ), allocatable :: work (:), ipivot (:) !Size of matrix N = size ( mat , 1 ) if ( N /= size ( mat , 2 )) & call exit_with_message ( \"invert_complex_square called with non-zquare matrix. Exiting.\" ) allocate ( work ( N ), ipivot ( N )) call zgetrf ( N , N , mat , N , ipivot , info ) if ( info /= 0 ) & call exit_with_message ( \"Matrix is singular in invert_complex_square. Exiting.\" ) call zgetri ( N , mat , N , ipivot , work , lwork , info ) if ( info /= 0 ) & call exit_with_message ( \"Matrix inversion failed in invert_complex_square. Exiting.\" ) end subroutine invert_complex_square subroutine welcome !! Subroutine to print a pretty banner. if ( this_image () == 1 ) then write ( * , '(A75)' ) \"+-------------------------------------------------------------------------+\" write ( * , '(A75)' ) \"| \\                                                                       |\" write ( * , '(A75)' ) \"|  \\                                                                      |\" write ( * , '(A75)' ) \"|   \\   \\                                                                 |\" write ( * , '(A75)' ) \"|    \\   \\                                                                |\" write ( * , '(A75)' ) \"|   __\\   \\              _        _    _           _    _                 |\" write ( * , '(A75)' ) \"|   \\      \\         ___|.|      |.|  | |__   ___ |.|_ / /__              |\" write ( * , '(A75)' ) \"|    \\    __\\       / _ \\.|   _  |.|_ | '_ \\ / _ \\|.|_  ___/              |\" write ( * , '(A75)' ) \"|     \\  \\         |  __/.| |/ \\_|/  \\| |_) : (_) |.|/ /__                |\" write ( * , '(A75)' ) \"|      \\ \\          \\___|_|/|__/ |   /| ___/ \\___/|_|\\___/                |\" write ( * , '(A75)' ) \"|       \\ \\                /|                                             |\" write ( * , '(A75)' ) \"|        \\\\                \\|                                             |\" write ( * , '(A75)' ) \"|         \\\\                '                                             |\" write ( * , '(A75)' ) \"|          \\                                                              |\" write ( * , '(A75)' ) \"|           \\                                                             |\" write ( * , '(A75)' ) \"| A solver for the coupled electron-phonon Boltzmann transport equations. |\" write ( * , '(A75)' ) \"| Copyright (C) 2020- Nakib Haider Protik.                                |\" write ( * , '(A75)' ) \"|                                                                         |\" write ( * , '(A75)' ) \"| This is a 'free as in freedom'[*] software, distributed under the GPLv3.|\" write ( * , '(A75)' ) \"| [*] https://www.gnu.org/philosophy/free-sw.en.html                      |\" write ( * , '(A75)' ) \"+-------------------------------------------------------------------------+\" print * , ' ' write ( * , '(A, I5)' ) 'Number of coarray images = ' , num_images () end if end subroutine welcome subroutine subtitle ( text ) !! Subroutine to print a subtitle. character ( len = * ), intent ( in ) :: text integer ( i64 ) :: length character ( len = 75 ) :: string2print length = len ( text ) string2print = '___________________________________________________________________________' if ( this_image () == 1 ) write ( * , '(A75)' ) string2print string2print ( 75 - length + 1 : 75 ) = text if ( this_image () == 1 ) write ( * , '(A75)' ) string2print end subroutine subtitle end module misc","tags":"","loc":"sourcefile/misc.f90.html"},{"title":"fc2_parser_qe.f90 – elphbolt","text":"Contents Submodules fc2_parser_qe Source Code fc2_parser_qe.f90 Source Code submodule ( FC2_parser_factory_module ) fc2_parser_qe implicit none contains module subroutine qe_parser ( self ) !! Quantum Espresso 2nd order force constants parser class ( fc2_qe ), intent ( in ) :: self print * , 'TODO: Please, implement QE format FC2 parser here.' end subroutine qe_parser end submodule fc2_parser_qe","tags":"","loc":"sourcefile/fc2_parser_qe.f90.html"},{"title":"spglib_wrapper.f90 – elphbolt","text":"Contents Modules spglib_wrapper Source Code spglib_wrapper.f90 Source Code !From ShengBTE symmetry.f90 !  ShengBTE, a solver for the Boltzmann Transport Equation for phonons !  Copyright (C) 2012-2017 Wu Li <wu.li.phys2011@gmail.com> !  Copyright (C) 2012-2017 Jesús Carrete Montaña <jcarrete@gmail.com> !  Copyright (C) 2012-2017 Nebil Ayape Katcho <nebil.ayapekatcho@cea.fr> !  Copyright (C) 2012-2017 Natalio Mingo Bisquert <natalio.mingo@cea.fr> ! !  This program is free software: you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation, either version 3 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program.  If not, see <http://www.gnu.org/licenses/>. ! Thin, specialized wrapper around spglib, a library by Atsushi Togo. ! Small change in data type declaration -- Nakib H. Protik module spglib_wrapper !! Wrapper for spglib from ShengBTE. use params , only : r64 , i64 use iso_c_binding implicit none public external dgesv ! Tolerance parameter passed to spglib. real ( kind = C_DOUBLE ), parameter :: symprec = 1 d - 5 ! Explicit interfaces to spglib. interface function spg_get_symmetry ( rotations , translations , nops , lattice ,& positions , types , natoms , symprec ) bind ( C , name = \"spg_get_symmetry\" ) use iso_c_binding integer ( kind = C_INT ), value :: nops integer ( kind = C_INT ), value :: natoms integer ( kind = C_INT ) :: spg_get_symmetry integer ( kind = C_INT ), dimension ( 3 , 3 , nops ) :: rotations real ( kind = C_DOUBLE ), dimension ( 3 , nops ) :: translations real ( kind = C_DOUBLE ), dimension ( 3 , 3 ) :: lattice real ( kind = C_DOUBLE ), dimension ( 3 , natoms ) :: positions integer ( kind = C_INT ), dimension ( natoms ) :: types real ( kind = C_DOUBLE ), value :: symprec end function spg_get_symmetry function spg_get_international ( symbol , lattice ,& positions , types , natoms , symprec ) bind ( C , name = \"spg_get_international\" ) use iso_c_binding integer ( kind = C_INT ), value :: natoms integer ( kind = C_INT ) :: spg_get_international character ( kind = C_CHAR ), dimension ( 11 ) :: symbol real ( kind = C_DOUBLE ), dimension ( 3 , 3 ) :: lattice real ( kind = C_DOUBLE ), dimension ( 3 , natoms ) :: positions integer ( kind = C_INT ), dimension ( natoms ) :: types real ( kind = C_DOUBLE ), value :: symprec end function spg_get_international function spg_get_multiplicity ( lattice ,& positions , types , natoms , symprec ) bind ( C , name = \"spg_get_multiplicity\" ) use iso_c_binding integer ( kind = C_INT ), value :: natoms integer ( kind = C_INT ) :: spg_get_multiplicity real ( kind = C_DOUBLE ), dimension ( 3 , 3 ) :: lattice real ( kind = C_DOUBLE ), dimension ( 3 , natoms ) :: positions integer ( kind = C_INT ), dimension ( natoms ) :: types real ( kind = C_DOUBLE ), value :: symprec end function spg_get_multiplicity end interface contains function get_num_operations ( lattice , natoms , types , positions ) !! Return the number of symmetry operations. Useful for allocating !! memory for get_operations(). real ( r64 ), dimension ( 3 , 3 ), intent ( in ) :: lattice integer ( i64 ), intent ( in ) :: natoms integer ( i64 ), dimension ( natoms ), intent ( in ) :: types real ( r64 ), dimension ( 3 , natoms ), intent ( in ) :: positions integer ( i64 ) :: get_num_operations ! Notice the explicit C-compatible types used through this module. real ( kind = C_DOUBLE ), dimension ( 3 , 3 ) :: clattice integer ( kind = C_INT ) :: cnatoms integer ( kind = C_INT ), dimension ( natoms ) :: ctypes real ( kind = C_DOUBLE ), dimension ( 3 , natoms ) :: cpositions integer ( kind = C_INT ) :: num ! This kind of transposition is needed for interoperability with ! C. clattice = transpose ( lattice ) cnatoms = natoms ctypes = types cpositions = positions num = spg_get_multiplicity ( clattice , cpositions , ctypes ,& cnatoms , symprec ) get_num_operations = num end function get_num_operations subroutine get_operations ( lattice , natoms , types , positions , nops ,& rotations , translations , international ) !! Return the matrix and vector representations of the symmetry !! operations of the system. real ( r64 ), dimension ( 3 , 3 ), intent ( in ) :: lattice integer ( i64 ), intent ( in ) :: natoms integer ( i64 ), dimension ( natoms ), intent ( in ) :: types real ( r64 ), dimension ( 3 , natoms ), intent ( in ) :: positions integer ( i64 ), intent ( inout ) :: nops integer ( i64 ), dimension ( 3 , 3 , nops ), intent ( out ) :: rotations real ( r64 ), dimension ( 3 , nops ), intent ( out ) :: translations character ( len = 10 ), intent ( out ) :: international integer ( kind = C_INT ) :: i integer ( kind = C_INT ) :: newnops real ( kind = C_DOUBLE ), dimension ( 3 , 3 ) :: clattice integer ( kind = C_INT ) :: cnatoms integer ( kind = C_INT ), dimension ( natoms ) :: ctypes real ( kind = C_DOUBLE ), dimension ( 3 , natoms ) :: cpositions integer ( kind = C_INT ) :: cnops integer ( kind = C_INT ), dimension ( 3 , 3 , nops ) :: crotations real ( kind = C_DOUBLE ), dimension ( 3 , nops ) :: ctranslations character ( len = 11 , kind = C_CHAR ) :: intertmp clattice = transpose ( lattice ) cnatoms = natoms ctypes = types cpositions = positions cnops = nops intertmp = '           ' !Empty spaces ! If nops changes value, something went wrong. Checking ! this condition is up to the user. newnops = spg_get_symmetry ( crotations , ctranslations , cnops ,& clattice , cpositions , ctypes , cnatoms , symprec ) i = spg_get_international ( intertmp , clattice , cpositions ,& ctypes , cnatoms , symprec ) international = intertmp ( 1 : 10 ) nops = newnops ! Transform from C to Fortran order. do i = 1 , nops rotations (:,:, i ) = transpose ( crotations (:,:, i )) end do translations = ctranslations end subroutine get_operations subroutine get_cartesian_operations ( lattice , nops , rotations , translations ,& crotations , ctranslations ) !! Return the Cartesian components of the rotations and translations !! returned by get_operations(). real ( r64 ), dimension ( 3 , 3 ), intent ( in ) :: lattice integer ( i64 ), intent ( in ) :: nops integer ( i64 ), dimension ( 3 , 3 , nops ), intent ( in ) :: rotations real ( r64 ), dimension ( 3 , nops ), intent ( in ) :: translations real ( r64 ), dimension ( 3 , 3 , nops ), intent ( out ) :: crotations real ( r64 ), dimension ( 3 , nops ), intent ( out ) :: ctranslations integer ( i64 ) :: i , info integer ( i64 ), dimension ( 3 ) :: P real ( r64 ), dimension ( 3 , 3 ) :: tmp1 , tmp2 ctranslations = matmul ( lattice , translations ) do i = 1 , nops tmp1 = transpose ( lattice ) tmp2 = transpose ( matmul ( lattice , rotations (:,:, i ))) ! Rotations transform as tensors: both the lattice-vector matrix ! and its inverse are needed. Explicit inversions are avoided. call dgesv ( 3 , 3 , tmp1 , 3 , P , tmp2 , 3 , info ) crotations (:,:, i ) = transpose ( tmp2 ) end do end subroutine get_cartesian_operations end module spglib_wrapper","tags":"","loc":"sourcefile/spglib_wrapper.f90.html"},{"title":"fc2_parser_siesta.f90 – elphbolt","text":"Contents Submodules fc2_parser_siesta Source Code fc2_parser_siesta.f90 Source Code submodule ( FC2_parser_factory_module ) fc2_parser_siesta implicit none contains module subroutine siesta_parser ( self ) !! Siesta 2nd order force constants parser class ( fc2_siesta ), intent ( in ) :: self print * , 'TODO: Please, implement SIESTA format FC2 parser here.' end subroutine siesta_parser end submodule fc2_parser_siesta","tags":"","loc":"sourcefile/fc2_parser_siesta.f90.html"},{"title":"fc2_parser_factory.f90 – elphbolt","text":"Contents Modules FC2_parser_factory_module Source Code fc2_parser_factory.f90 Source Code module FC2_parser_factory_module !! 2nd oder force constants (FC2) parser factory. use misc , only : exit_with_message implicit none type FC2_parser_factory class ( FC2 ), pointer :: FC2 contains procedure :: set_format end type FC2_parser_factory type , abstract :: FC2 contains procedure ( generic_parser ), deferred , pass ( self ) :: parser end type FC2 abstract interface subroutine generic_parser ( self ) import :: FC2 class ( FC2 ), intent ( in ) :: self end subroutine generic_parser end interface type , extends ( FC2 ) :: fc2_qe !! Quantum Espresso 2nd order force constants format contains procedure , pass ( self ) :: parser => qe_parser end type fc2_qe interface module subroutine qe_parser ( self ) class ( fc2_qe ), intent ( in ) :: self end subroutine qe_parser end interface type , extends ( FC2 ) :: fc2_siesta !! Siesta 2nd order force constants format contains procedure , pass ( self ) :: parser => siesta_parser end type fc2_siesta interface module subroutine siesta_parser ( self ) class ( fc2_siesta ), intent ( in ) :: self end subroutine siesta_parser end interface contains function set_format ( self , format_name ) result ( fc2_type ) class ( FC2_parser_factory ) :: self character ( len =* ), intent ( in ) :: format_name class ( FC2 ), pointer :: fc2_type if ( associated ( self % FC2 )) deallocate ( self % FC2 ) select case ( format_name ) case ( \"qe\" ) allocate ( fc2_qe :: self % fc2 ) case ( \"siesta\" ) allocate ( fc2_siesta :: self % fc2 ) case default call exit_with_message ( \"Unknown 2nd order force constants type specified. Exiting.\" ) end select fc2_type => self % fc2 end function set_format end module FC2_parser_factory_module","tags":"","loc":"sourcefile/fc2_parser_factory.f90.html"},{"title":"eliashberg.f90 – elphbolt","text":"Contents Modules eliashberg Source Code eliashberg.f90 Source Code ! Copyright (C) 2022- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module eliashberg !! Module containing the procedures related to the computation of the Eliashberg !! spectral function a2F and the e-ph coupling factor lambda. use params , only : i64 , r64 use misc , only : exit_with_message , print_message , distribute_points , & demux_state , mux_vector , write2file_rank1_real , write2file_rank2_real , & compsimps use wannier_module , only : epw_wannier use electron_module , only : electron use phonon_module , only : phonon use numerics_module , only : numerics use delta , only : delta_fn_tetra , delta_fn_triang implicit none private public calculate_a2F , calculate_iso_Matsubara_lambda , calculate_aniso_Matsubara_lambda !external chdir contains subroutine calculate_a2F ( wann , el , ph , num , omegas , iso_lambda0 , omegalog , external_eps_switch ) !! Parallel driver of a2F_mk(nk'|sq) over IBZ electron states. !! Other zero temperature quantities such as the isotropic electron-phonon !! coupling (lambda0) and the log-averaged boson energy (omegalog) are !! also calculated here. !! !! This subroutine will calculate the anisotropic Eliashberg spectral function for !! all the energy window restricted electron-phonon processes for a given !! irreducible initial electron state = (band, wave vector). !! This list will be written to disk in files tagged with the muxed state index. ! !In the FBZ and IBZ blocks a wave vector was retained when at least one !band belonged within the energy window. Here the bands outside the energy !window will be skipped in the calculation as they are irrelevant for transport. type ( epw_wannier ), intent ( in ) :: wann type ( electron ), intent ( in ) :: el type ( phonon ), intent ( in ) :: ph type ( numerics ), intent ( in ) :: num real ( r64 ), intent ( in ) :: omegas (:) real ( r64 ), intent ( out ) :: iso_lambda0 , omegalog logical , intent ( in ), optional :: external_eps_switch !Local variables integer ( i64 ) :: nstates_irred , istate , m , ik , n , ikp , s , & iq , start , end , chunk , k_indvec ( 3 ), kp_indvec ( 3 ), & q_indvec ( 3 ), count , nprocs , num_active_images , & iomega , numomega real ( r64 ) :: k ( 3 ), kp ( 3 ), en_el , WWp , aux , domega real ( r64 ), allocatable :: ph_deltas (:, :, :), g2_istate (:), a2F_istate (:, :), & iso_a2F_branches (:, :), cum_iso_lambda_branches (:, :), eps_squared (:) character ( len = 1024 ) :: filename logical :: use_external_eps = . false . !Number of equidistant Boson energy points numomega = size ( omegas ) !Boson energy difference domega = omegas ( 2 ) - omegas ( 1 ) !Precalculate the phonon delta functions. call print_message ( \"Precalculating FBZ phonon delta functions...\" ) ! Allocate and initialize allocate ( ph_deltas ( wann % numbranches , ph % nwv , numomega )) ph_deltas = 0.0_r64 call distribute_points ( numomega , chunk , start , end , num_active_images ) ! Handle tetrahedron vs triangle choice. if ( num % tetrahedra ) then !tetrahedron method do iomega = start , end do iq = 1 , ph % nwv do s = 1 , wann % numbranches ph_deltas ( s , iq , iomega ) = & delta_fn_tetra ( omegas ( iomega ), iq , s , ph % wvmesh , ph % tetramap , & ph % tetracount , ph % tetra_evals ) end do end do end do else !triangle method do iomega = start , end do iq = 1 , ph % nwv do s = 1 , wann % numbranches ph_deltas ( s , iq , iomega ) = & delta_fn_triang ( omegas ( iomega ), iq , s , ph % wvmesh , ph % triangmap , & ph % triangcount , ph % triang_evals ) end do end do end do end if ! The delta weights above were supercell number normalized. ! Taking this fact into account here: ph_deltas = ph_deltas * product ( ph % wvmesh ) ! Absorb DOS(Ef) in the definition of ph_deltas ph_deltas = ph_deltas * el % spinnormed_dos_fermi ! Reduce ph_deltas sync all call co_sum ( ph_deltas ) sync all call print_message ( \"Calculating a2F for all IBZ electrons...\" ) if ( present ( external_eps_switch ) . and . external_eps_switch ) then use_external_eps = . true . call print_message ( \" Externally generated screening will be used...\" ) allocate ( eps_squared ( numomega )) !Read |epsilon|&#94;2 from file if ( this_image () == 1 ) then call chdir ( num % cwd ) filename = 'eps_squared' open ( 1 , file = trim ( filename ), status = 'old' ) do iomega = 1 , numomega read ( 1 , * ) eps_squared ( iomega ) end do close ( 1 ) end if sync all call co_broadcast ( eps_squared , 1 ) sync all end if !Total number of IBZ blocks states nstates_irred = el % nwv_irred * wann % numwannbands call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" #states = \" , nstates_irred write ( * , \"(A, I10)\" ) \" #states/image = \" , chunk end if !Allocate and initialize isotropic a2F allocate ( iso_a2F_branches ( numomega , wann % numbranches )) iso_a2F_branches = 0.0_r64 do istate = start , end !over IBZ blocks states !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , wann % numwannbands , m , ik ) !Electron energy en_el = el % ens_irred ( ik , m ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( en_el - el % enref ) > el % fsthick ) cycle !Initial (IBZ blocks) wave vector (crystal coords.) k = el % wavevecs_irred ( ik , :) !Convert from crystal to 0-based index vector k_indvec = nint ( k * el % wvmesh ) !Load g2_istate from disk for a2F_istate calculation ! Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) ! Read data in binary format write ( filename , '(I9)' ) istate filename = 'gk2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'old' , access = 'stream' ) read ( 1 ) nprocs if ( allocated ( g2_istate )) deallocate ( g2_istate , a2F_istate ) allocate ( g2_istate ( nprocs ), a2F_istate ( nprocs , numomega )) if ( nprocs > 0 ) read ( 1 ) g2_istate close ( 1 ) ! Change back to working directory call chdir ( num % cwd ) !Initialize eligible process counter for this state count = 0 !Run over final (FBZ blocks) electron wave vectors do ikp = 1 , el % nwv !Final wave vector (crystal coords.) kp = el % wavevecs ( ikp , :) !Convert from crystal to 0-based index vector kp_indvec = nint ( kp * el % wvmesh ) !Find interacting phonon wave vector ! Note that q, k, and k' are all on the same mesh q_indvec = modulo ( kp_indvec - k_indvec , el % wvmesh ) ! Muxed index of q iq = mux_vector ( q_indvec , el % wvmesh , 0_i64 ) !Run over final electron bands do n = 1 , wann % numwannbands !Apply energy window to final electron if ( abs ( el % ens ( ikp , n ) - el % enref ) > el % fsthick ) cycle !Delta function contributions and k-point weight WWp = el % Ws_irred ( ik , m ) * el % Ws ( ikp , n ) * el % nequiv ( ik ) !Run over phonon branches do s = 1 , wann % numbranches !Increment g2 processes counter count = count + 1 !Note that the phonon branch index iterates last for a2F_istate a2F_istate ( count , :) = g2_istate ( count ) * ph_deltas ( s , iq , :) !Sum contribuion to the isotropic a2F iso_a2F_branches (:, s ) = iso_a2F_branches (:, s ) + & a2F_istate ( count , :) * WWp end do !s end do !n end do !ikp !Change to data output directory call chdir ( trim ( adjustl ( num % scdir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'a2F.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) a2F_istate close ( 1 ) !Change back to working directory call chdir ( num % cwd ) deallocate ( g2_istate , a2F_istate ) end do !Screen, if desired. if ( use_external_eps ) then do s = 1 , wann % numbranches iso_a2F_branches (:, s ) = iso_a2F_branches (:, s ) / eps_squared (:) end do end if !Reduce iso_a2F_branches sync all call co_sum ( iso_a2F_branches ) sync all !Write isotropic a2F to file call chdir ( num % cwd ) call write2file_rank2_real ( 'a2F_iso_branch_resolved' , iso_a2F_branches ) call write2file_rank1_real ( 'a2F_iso' , sum ( iso_a2F_branches , dim = 2 )) ! Calculate cumulative lambda allocate ( cum_iso_lambda_branches ( numomega , wann % numbranches )) do s = 1 , wann % numbranches do iomega = 1 , numomega call compsimps (& iso_a2F_branches ( 1 : iomega , s ) * 2.0_r64 / omegas ( 1 : iomega ), & domega , aux ) cum_iso_lambda_branches ( iomega , s ) = aux end do end do ! Calculate and print out standard isotropic lambda iso_lambda0 = sum ( cum_iso_lambda_branches ( numomega , :)) if ( this_image () == 1 ) then write ( * , \"(A, (1E16.8))\" ) ' Standard, isotropic e-ph coupling =' , & iso_lambda0 end if ! Calculate and print out log-averaged phonon energy call compsimps (& log ( omegas (:)) * sum ( iso_a2F_branches , dim = 2 ) * 2.0_r64 / omegas (:), & domega , aux ) omegalog = exp ( aux / iso_lambda0 ) if ( this_image () == 1 ) then write ( * , \"(A, (1E16.8, x), A)\" ) ' Log-averaged phonon energy =' , & omegalog * 1.0e3_r64 , ' meV' end if ! Print cumulative lambda to file call write2file_rank2_real ( 'cum_lambda_iso_branch_resolved' , cum_iso_lambda_branches ) sync all end subroutine calculate_a2F subroutine calculate_iso_Matsubara_lambda ( wann , num , omegas , bose_matsubara_ens , & iso_matsubara_lambda ) !! Calculate the isotropic Matsubara electron-phonon coupling, lambda(l). !! Here l is the Bosonic Matsubara energy index. type ( epw_wannier ), intent ( in ) :: wann type ( numerics ), intent ( in ) :: num real ( r64 ), intent ( in ) :: omegas (:), bose_matsubara_ens (:) real ( r64 ), intent ( out ) :: iso_matsubara_lambda (:) !Local variables integer ( i64 ) :: s , l , iomega , numomega , nummatsubara real ( r64 ) :: aux , domega real ( r64 ), allocatable :: iso_a2F_branches (:, :) character ( len = 1024 ) :: filename !Number of equidistant Boson energy points numomega = size ( omegas ) !Boson energy difference domega = omegas ( 2 ) - omegas ( 1 ) !Number of Bosonic Matsubara energy points nummatsubara = size ( bose_matsubara_ens ) call print_message ( \"   Calculating isotropic Matsubara lambda...\" ) !Read iso_a2F_branches from file allocate ( iso_a2F_branches ( numomega , wann % numbranches )) if ( this_image () == 1 ) then call chdir ( num % cwd ) filename = 'a2F_iso_branch_resolved' open ( 1 , file = trim ( filename ), status = 'old' ) do iomega = 1 , numomega read ( 1 , * ) iso_a2F_branches ( iomega , :) end do close ( 1 ) end if sync all call co_broadcast ( iso_a2F_branches , 1 ) sync all !Isotropic theory iso_matsubara_lambda = 0.0_r64 !Sum over phonon branches do s = 1 , wann % numbranches !Run over Matsubara frequencies do l = 1 , nummatsubara call compsimps (& iso_a2F_branches (:, s ) * 2.0_r64 * omegas (:) / & ( omegas (:) ** 2 + bose_matsubara_ens ( l ) ** 2 ), domega , aux ) iso_matsubara_lambda ( l ) = iso_matsubara_lambda ( l ) + aux end do end do end subroutine calculate_iso_Matsubara_lambda subroutine calculate_aniso_Matsubara_lambda ( wann , num , el , omegas , bose_matsubara_ens ) !! Parallel driver of lambda_mk(nk'|sq, l) over IBZ electron states. !! Here l is the Bosonic Matsubara energy index. !! !! This subroutine will calculate the anisotropic e-ph coupling function for !! all the energy window restricted electron-phonon processes for a given !! irreducible initial electron state = (band, wave vector). !! This list will be written to disk in files tagged with the muxed state index. ! !In the FBZ and IBZ blocks a wave vector was retained when at least one !band belonged within the energy window. Here the bands outside the energy !window will be skipped in the calculation as they are irrelevant for transport. type ( epw_wannier ), intent ( in ) :: wann type ( electron ), intent ( in ) :: el type ( numerics ), intent ( in ) :: num real ( r64 ), intent ( in ) :: omegas (:), bose_matsubara_ens (:) !Local variables integer ( i64 ) :: nstates_irred , istate , m , ik , n , ikp , s , l , & start , end , chunk , count , nprocs , & num_active_images , numomega , nummatsubara real ( r64 ) :: aux , domega real ( r64 ), allocatable :: a2F_istate (:, :), matsubara_lambda_istate (:, :) character ( len = 1024 ) :: filename call print_message ( \"   Calculating lambda for all IBZ electrons...\" ) !Number of equidistant Boson energy points numomega = size ( omegas ) !Boson energy difference domega = omegas ( 2 ) - omegas ( 1 ) !Number of Bosonic Matsubara energy points nummatsubara = size ( bose_matsubara_ens ) !Total number of IBZ blocks states nstates_irred = el % nwv_irred * wann % numwannbands call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \"    #states = \" , nstates_irred write ( * , \"(A, I10)\" ) \"    #states/image = \" , chunk end if !Anisotropic theory do istate = start , end !over IBZ blocks states !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , wann % numwannbands , m , ik ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( el % ens_irred ( ik , m ) - el % enref ) > el % fsthick ) cycle !Load a2F_istate from disk for matsubara_lambda_istate calculation ! Change to data output directory call chdir ( trim ( adjustl ( num % scdir ))) ! Read data in binary format write ( filename , '(I9)' ) istate filename = 'a2F.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'old' , access = 'stream' ) read ( 1 ) nprocs if ( allocated ( a2F_istate )) deallocate ( a2F_istate , matsubara_lambda_istate ) allocate ( a2F_istate ( nprocs , numomega ), matsubara_lambda_istate ( nprocs , nummatsubara )) if ( nprocs > 0 ) read ( 1 ) a2F_istate close ( 1 ) ! Change back to working directory call chdir ( num % cwd ) !Initialize eligible process counter for this state count = 0 !Run over final (FBZ blocks) electron wave vectors do ikp = 1 , el % nwv !Run over final electron bands do n = 1 , wann % numwannbands !Apply energy window to final electron if ( abs ( el % ens ( ikp , n ) - el % enref ) > el % fsthick ) cycle !Run over phonon branches do s = 1 , wann % numbranches !Increment g2 processes counter count = count + 1 !Note that the phonon branch index iterates last for a2F_istate !and matsubara_lambda_istate is similarly phonon branch resolved. ! !Calculate lambda for each Matsubara energy do l = 1 , nummatsubara call compsimps (& a2F_istate ( count , :) * 2.0_r64 * omegas (:) / & ( omegas (:) ** 2 + bose_matsubara_ens ( l ) ** 2 ), domega , aux ) matsubara_lambda_istate ( count , l ) = aux end do end do !s end do !n end do !ikp !Change to data output directory call chdir ( trim ( adjustl ( num % scdir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'lambda.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) matsubara_lambda_istate close ( 1 ) !Change back to working directory call chdir ( num % cwd ) deallocate ( a2F_istate , matsubara_lambda_istate ) end do sync all end subroutine calculate_aniso_Matsubara_lambda end module eliashberg","tags":"","loc":"sourcefile/eliashberg.f90.html"},{"title":"bte.f90 – elphbolt","text":"Contents Modules bte_module Source Code bte.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module bte_module !! Module containing type and procedures related to the solution of the !! Boltzmann transport equation (BTE). use params , only : r64 , i64 , qe , kB use misc , only : print_message , exit_with_message , write2file_rank2_real , & distribute_points , demux_state , binsearch , interpolate , demux_vector , & trace , subtitle , append2file_transport_tensor , write2file_response , & linspace , readfile_response , write2file_spectral_tensor , subtitle , timer , & twonorm , write2file_rank1_real use numerics_module , only : numerics use crystal_module , only : crystal use symmetry_module , only : symmetry use phonon_module , only : phonon use electron_module , only : electron use interactions , only : calculate_ph_rta_rates , read_transition_probs_e , & calculate_el_rta_rates , calculate_bound_scatt_rates , calculate_thinfilm_scatt_rates , & calculate_4ph_rta_rates use bz_sums , only : calculate_transport_coeff , calculate_spectral_transport_coeff , & calculate_mfp_cumulative_transport_coeff implicit none !external system, chdir private public bte type bte !! Data and procedures related to the BTE. real ( r64 ), allocatable :: ph_rta_rates_iso_ibz (:,:) !! Phonon RTA scattering rates on the IBZ due to isotope scattering. real ( r64 ), allocatable :: ph_rta_rates_subs_ibz (:,:) !! Phonon RTA scattering rates on the IBZ due to substitution scattering. real ( r64 ), allocatable :: ph_rta_rates_bound_ibz (:,:) !! Phonon RTA scattering rates on the IBZ due to boundary scattering. real ( r64 ), allocatable :: ph_rta_rates_thinfilm_ibz (:,:) !! Phonon RTA scattering rates on the IBZ due to thin-film scattering. real ( r64 ), allocatable :: ph_rta_rates_3ph_ibz (:,:) !! Phonon RTA scattering rates on the IBZ due to 3-ph interactions. real ( r64 ), allocatable :: ph_rta_rates_4ph_ibz (:,:) !! Phonon RTA scattering rates on the IBZ due to 4-ph interactions. real ( r64 ), allocatable :: ph_rta_rates_phe_ibz (:,:) !! Phonon RTA scattering rates on the IBZ due to ph-e interactions. real ( r64 ), allocatable :: ph_rta_rates_ibz (:,:) !! Phonon RTA scattering rates on the IBZ. real ( r64 ), allocatable :: ph_field_term_T (:,:,:) !! Phonon field coupling term for gradT field on the FBZ. real ( r64 ), allocatable :: ph_response_T (:,:,:) !! Phonon response function for gradT field on the FBZ. real ( r64 ), allocatable :: ph_field_term_E (:,:,:) !! Phonon field coupling term for E field on the FBZ. real ( r64 ), allocatable :: ph_response_E (:,:,:) !! Phonon response function for E field on the FBZ. real ( r64 ), allocatable :: el_rta_rates_echimp_ibz (:,:) !! Electron RTA scattering rates on the IBZ due to charged impurity scattering. real ( r64 ), allocatable :: el_rta_rates_bound_ibz (:,:) !! Electron RTA scattering rates on the IBZ due to boundary scattering. real ( r64 ), allocatable :: el_rta_rates_eph_ibz (:,:) !! Electron RTA scattering rates on the IBZ due to e-ph interactions. real ( r64 ), allocatable :: el_rta_rates_ibz (:,:) !! Electron RTA scattering rates on the IBZ. real ( r64 ), allocatable :: el_field_term_T (:,:,:) !! Electron field coupling term for gradT field on the FBZ. real ( r64 ), allocatable :: el_response_T (:,:,:) !! Electron response function for gradT field on the FBZ. real ( r64 ), allocatable :: el_field_term_E (:,:,:) !! Electron field coupling term for E field on the FBZ. real ( r64 ), allocatable :: el_response_E (:,:,:) !! Electron response function for E field on the FBZ. contains procedure :: solve_bte , post_process end type bte contains subroutine solve_bte ( self , num , crys , sym , ph , el ) !! Subroutine to solve the BTE !! !! self BTE object !! num Numerics object !! crys Crystal object !! sym Symmertry object !! ph Phonon object !! el Electron object class ( bte ), intent ( inout ) :: self type ( numerics ), intent ( in ) :: num type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( phonon ), intent ( in ) :: ph type ( electron ), intent ( in ), optional :: el !Local variables character ( len = 1024 ) :: tag , Tdir , tableheader integer ( i64 ) :: iq , ik , it_ph , it_el , icart real ( r64 ), allocatable :: I_diff (:,:,:), I_drag (:,:,:), ph_kappa (:,:,:), ph_alphabyT (:,:,:), & el_sigma (:,:,:), el_sigmaS (:,:,:), el_alphabyT (:,:,:), el_kappa0 (:,:,:), & dummy (:,:,:), ph_drag_term_T (:,:,:), ph_drag_term_E (:,:,:) real ( r64 ) :: ph_kappa_scalar , ph_kappa_scalar_old , el_sigma_scalar , el_sigma_scalar_old , & el_sigmaS_scalar , el_sigmaS_scalar_old , el_kappa0_scalar , el_kappa0_scalar_old , & ph_alphabyT_scalar , ph_alphabyT_scalar_old , el_alphabyT_scalar , el_alphabyT_scalar_old , & KO_dev , tot_alphabyT_scalar , lambda type ( timer ) :: t call subtitle ( \"Calculating transport...\" ) call print_message ( \"Only the trace-averaged transport coefficients are printed below:\" ) !Create output folder tagged by temperature and create it write ( tag , \"(E9.3)\" ) crys % T Tdir = trim ( adjustl ( num % cwd )) // '/T' // trim ( adjustl ( tag )) if ( this_image () == 1 ) then call system ( 'mkdir -p ' // trim ( adjustl ( Tdir ))) end if sync all if (. not . num % onlyebte ) then call t % start_timer ( 'RTA ph BTE' ) !Allocate phonon transport coefficients allocate ( ph_kappa ( ph % numbands , 3 , 3 ), ph_alphabyT ( ph % numbands , 3 , 3 ), & dummy ( ph % numbands , 3 , 3 )) !Allocate total RTA scattering rates allocate ( self % ph_rta_rates_ibz ( ph % nwv_irred , ph % numbands )) !Calculate RTA scattering rates ! phonon-boundary call calculate_bound_scatt_rates ( ph % prefix , num % phbound , crys % bound_length , & ph % vels , ph % indexlist_irred , self % ph_rta_rates_bound_ibz ) ! phonon-thin-film call calculate_thinfilm_scatt_rates ( ph % prefix , num % phthinfilm , crys % thinfilm_height , & crys % thinfilm_normal , ph % vels , ph % indexlist_irred , self % ph_rta_rates_thinfilm_ibz ) ! 3-phonon and, optionally, phonon-electron if ( num % phe ) then call calculate_ph_rta_rates ( self % ph_rta_rates_3ph_ibz , self % ph_rta_rates_phe_ibz , num , crys , ph , el ) else call calculate_ph_rta_rates ( self % ph_rta_rates_3ph_ibz , self % ph_rta_rates_phe_ibz , num , crys , ph ) end if ! 4-ph scattering rates call calculate_4ph_rta_rates ( self % ph_rta_rates_4ph_ibz , num , crys , ph ) !Matthiessen's rule self % ph_rta_rates_ibz = self % ph_rta_rates_3ph_ibz + self % ph_rta_rates_phe_ibz + & self % ph_rta_rates_iso_ibz + self % ph_rta_rates_subs_ibz + & self % ph_rta_rates_bound_ibz + self % ph_rta_rates_thinfilm_ibz + & self % ph_rta_rates_4ph_ibz !gradT field: ! Calculate field term (gradT=>F0) call calculate_field_term ( 'ph' , 'T' , ph % nequiv , ph % ibz2fbz_map , & crys % T , 0.0_r64 , ph % ens , ph % vels , self % ph_rta_rates_ibz , self % ph_field_term_T ) ! Symmetrize field term do iq = 1 , ph % nwv self % ph_field_term_T ( iq ,:,:) = transpose (& matmul ( ph % symmetrizers (:,:, iq ), transpose ( self % ph_field_term_T ( iq ,:,:)))) end do ! RTA solution of BTE allocate ( self % ph_response_T ( ph % nwv , ph % numbands , 3 )) self % ph_response_T = self % ph_field_term_T ! Calculate transport coefficient call calculate_transport_coeff ( 'ph' , 'T' , crys % T , 1_i64 , 0.0_r64 , ph % ens , ph % vels , & crys % volume , ph % wvmesh , self % ph_response_T , sym , ph_kappa , dummy ) !---------------------------------------------------------------------------------! !E field: ! Calculate field term (E=>G0) call calculate_field_term ( 'ph' , 'E' , ph % nequiv , ph % ibz2fbz_map , & crys % T , 0.0_r64 , ph % ens , ph % vels , self % ph_rta_rates_ibz , self % ph_field_term_E ) ! RTA solution of BTE allocate ( self % ph_response_E ( ph % nwv , ph % numbands , 3 )) self % ph_response_E = self % ph_field_term_E ! Calculate transport coefficient call calculate_transport_coeff ( 'ph' , 'E' , crys % T , 1_i64 , 0.0_r64 , ph % ens , ph % vels , & crys % volume , ph % wvmesh , self % ph_response_E , sym , ph_alphabyT , dummy ) ph_alphabyT = ph_alphabyT / crys % T !---------------------------------------------------------------------------------! !Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) !Write T-dependent RTA scattering rates to file call write2file_rank2_real ( 'ph.W_rta_3ph' , self % ph_rta_rates_3ph_ibz ) call write2file_rank2_real ( 'ph.W_rta_4ph' , self % ph_rta_rates_4ph_ibz ) call write2file_rank2_real ( 'ph.W_rta_phe' , self % ph_rta_rates_phe_ibz ) call write2file_rank2_real ( 'ph.W_rta' , self % ph_rta_rates_ibz ) !Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) !Calculate and print transport scalars !gradT: ph_kappa_scalar = trace ( sum ( ph_kappa , dim = 1 )) / crys % dim !E: ph_alphabyT_scalar = trace ( sum ( ph_alphabyT , dim = 1 )) / crys % dim if (. not . num % drag . and . this_image () == 1 ) then write ( * , * ) \"iter    k_ph[W/m/K]\" write ( * , \"(I3, A, 1E16.8)\" ) 0 , \"    \" , ph_kappa_scalar end if ph_kappa_scalar_old = ph_kappa_scalar ph_alphabyT_scalar_old = ph_alphabyT_scalar ! Append RTA coefficients in no-drag files ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'nodrag_ph_kappa_' , 0_i64 , ph_kappa ) ! Print RTA band/branch resolved response functions call write2file_response ( 'RTA_F0_' , self % ph_response_T ) !gradT, ph ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) call t % end_timer ( 'RTA ph BTE' ) end if if (. not . num % onlyphbte ) then call t % start_timer ( 'RTA e BTE' ) !Allocate electron transport coefficients allocate ( el_sigma ( el % numbands , 3 , 3 ), el_sigmaS ( el % numbands , 3 , 3 ), & el_alphabyT ( el % numbands , 3 , 3 ), el_kappa0 ( el % numbands , 3 , 3 )) !Calculate RTA scattering rates ! e-ph and e-impurity call calculate_el_rta_rates ( self % el_rta_rates_eph_ibz , self % el_rta_rates_echimp_ibz , num , crys , el ) ! e-boundary call calculate_bound_scatt_rates ( el % prefix , num % elbound , crys % bound_length , & el % vels , el % indexlist_irred , self % el_rta_rates_bound_ibz ) !Allocate total RTA scattering rates allocate ( self % el_rta_rates_ibz ( el % nwv_irred , el % numbands )) !Matthiessen's rule self % el_rta_rates_ibz = self % el_rta_rates_eph_ibz + self % el_rta_rates_echimp_ibz + & self % el_rta_rates_bound_ibz !gradT field: ! Calculate field term (gradT=>I0) call calculate_field_term ( 'el' , 'T' , el % nequiv , el % ibz2fbz_map , & crys % T , el % chempot , el % ens , el % vels , self % el_rta_rates_ibz , & self % el_field_term_T , el % indexlist ) ! Symmetrize field term do ik = 1 , el % nwv self % el_field_term_T ( ik ,:,:) = transpose (& matmul ( el % symmetrizers (:,:, ik ), transpose ( self % el_field_term_T ( ik ,:,:)))) end do ! RTA solution of BTE allocate ( self % el_response_T ( el % nwv , el % numbands , 3 )) self % el_response_T = self % el_field_term_T ! Calculate transport coefficient call calculate_transport_coeff ( 'el' , 'T' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , el % wvmesh , self % el_response_T , sym , el_kappa0 , el_sigmaS ) !E field: ! Calculate field term (E=>J0) call calculate_field_term ( 'el' , 'E' , el % nequiv , el % ibz2fbz_map , & crys % T , el % chempot , el % ens , el % vels , self % el_rta_rates_ibz , & self % el_field_term_E , el % indexlist ) ! Symmetrize field term do ik = 1 , el % nwv self % el_field_term_E ( ik ,:,:) = transpose (& matmul ( el % symmetrizers (:,:, ik ), transpose ( self % el_field_term_E ( ik ,:,:)))) end do ! RTA solution of BTE allocate ( self % el_response_E ( el % nwv , el % numbands , 3 )) self % el_response_E = self % el_field_term_E ! Calculate transport coefficient call calculate_transport_coeff ( 'el' , 'E' , crys % T , el % spindeg , el % chempot , el % ens , el % vels , & crys % volume , el % wvmesh , self % el_response_E , sym , el_alphabyT , el_sigma ) el_alphabyT = el_alphabyT / crys % T !--! !Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) !Write RTA scattering rates to file call write2file_rank2_real ( 'el.W_rta_eph' , self % el_rta_rates_eph_ibz ) !Write e-chimp RTA scattering rates to file call write2file_rank2_real ( 'el.W_rta_echimp' , self % el_rta_rates_echimp_ibz ) !Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) !Calculate and print transport scalars !gradT: el_kappa0_scalar = trace ( sum ( el_kappa0 , dim = 1 )) / crys % dim el_sigmaS_scalar = trace ( sum ( el_sigmaS , dim = 1 )) / crys % dim !E: el_sigma_scalar = trace ( sum ( el_sigma , dim = 1 )) / crys % dim el_alphabyT_scalar = trace ( sum ( el_alphabyT , dim = 1 )) / crys % dim if (. not . num % drag . and . this_image () == 1 ) then write ( * , * ) \"iter    k0_el[W/m/K]        sigmaS[A/m/K]\" , & \"         sigma[1/Ohm/m]      alpha_el/T[A/m/K]\" write ( * , \"(I3, A, 1E16.8, A, 1E16.8, A, 1E16.8, A, 1E16.8)\" ) 0 , & \"    \" , el_kappa0_scalar , \"     \" , el_sigmaS_scalar , & \"     \" , el_sigma_scalar , \"     \" , el_alphabyT_scalar end if el_kappa0_scalar_old = el_kappa0_scalar el_sigmaS_scalar_old = el_sigmaS_scalar el_sigma_scalar_old = el_sigma_scalar el_alphabyT_scalar_old = el_alphabyT_scalar ! Append RTA coefficients in no-drag files ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'nodrag_el_sigmaS_' , 0_i64 , el_sigmaS , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_sigma_' , 0_i64 , el_sigma , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_alphabyT_' , 0_i64 , el_alphabyT , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_kappa0_' , 0_i64 , el_kappa0 , el % bandlist ) ! Print RTA band/branch resolved response functions call write2file_response ( 'RTA_I0_' , self % el_response_T , el % bandlist ) !gradT, el call write2file_response ( 'RTA_J0_' , self % el_response_E , el % bandlist ) !E, el ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) call t % end_timer ( 'RTA e BTE' ) end if if ( num % drag ) then !Coupled BTEs call t % start_timer ( 'Coupled e-ph BTEs' ) tot_alphabyT_scalar = el_alphabyT_scalar + ph_alphabyT_scalar KO_dev = 10 0.0_r64 * abs (& ( el_sigmaS_scalar - tot_alphabyT_scalar ) / tot_alphabyT_scalar ) call print_message ( \"RTA solution:\" ) call print_message ( \"-------------\" ) if ( this_image () == 1 ) then tableheader = \"iter     k0_el[W/m/K]         sigmaS[A/m/K]         k_ph[W/m/K]\" & // \"         sigma[1/Ohm/m]         alpha_el/T[A/m/K]         alpha_ph/T[A/m/K]\" & // \"         KO dev.[%]\" write ( * , * ) trim ( tableheader ) end if !RTA if ( this_image () == 1 ) then write ( * , \"(I3, A, 1E16.8, A, 1E16.8, A, 1E16.8, A, 1E16.8, & A, 1E16.8, A, 1E16.8, A, 1F6.3)\" ) 0 , \"     \" , el_kappa0_scalar , & \"      \" , el_sigmaS_scalar , \"     \" , ph_kappa_scalar , & \"    \" , el_sigma_scalar , \"        \" , el_alphabyT_scalar , & \"         \" , ph_alphabyT_scalar , \"           \" , KO_dev end if !Append RTA coefficients in drag files ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'drag_ph_kappa_' , 0_i64 , ph_kappa ) call append2file_transport_tensor ( 'drag_ph_alphabyT_' , 0_i64 , ph_alphabyT ) call append2file_transport_tensor ( 'drag_el_sigmaS_' , 0_i64 , el_sigmaS , el % bandlist ) call append2file_transport_tensor ( 'drag_el_sigma_' , 0_i64 , el_sigma , el % bandlist ) call append2file_transport_tensor ( 'drag_el_alphabyT_' , 0_i64 , el_alphabyT , el % bandlist ) call append2file_transport_tensor ( 'drag_el_kappa0_' , 0_i64 , el_kappa0 , el % bandlist ) ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) call print_message ( \"Coupled electron-phonon transport:\" ) call print_message ( \"----------------------------------\" ) if ( this_image () == 1 ) then tableheader = \"iter     k0_el[W/m/K]         sigmaS[A/m/K]         k_ph[W/m/K]\" & // \"         sigma[1/Ohm/m]         alpha_el/T[A/m/K]         alpha_ph/T[A/m/K]\" & // \"         KO dev.[%]\" write ( * , * ) trim ( tableheader ) end if !These will be needed below allocate ( I_drag ( el % nwv , el % numbands , 3 ), I_diff ( el % nwv , el % numbands , 3 ), & ph_drag_term_T ( el % nwv , el % numbands , 3 ), ph_drag_term_E ( el % nwv , el % numbands , 3 )) !Start iterator do it_ph = 1 , num % maxiter !Scheme: for each step of phonon response, fully iterate the electron response. !Iterate phonon response once call iterate_bte_ph ( crys % T , . True ., num , ph , el , self % ph_rta_rates_ibz , & self % ph_field_term_T , self % ph_response_T , self % el_response_T ) call iterate_bte_ph ( crys % T , . True ., num , ph , el , self % ph_rta_rates_ibz , & self % ph_field_term_E , self % ph_response_E , self % el_response_E ) !Calculate phonon transport coefficients call calculate_transport_coeff ( 'ph' , 'T' , crys % T , 1_i64 , 0.0_r64 , ph % ens , ph % vels , & crys % volume , ph % wvmesh , self % ph_response_T , sym , ph_kappa , dummy ) call calculate_transport_coeff ( 'ph' , 'E' , crys % T , 1_i64 , 0.0_r64 , ph % ens , ph % vels , & crys % volume , ph % wvmesh , self % ph_response_E , sym , ph_alphabyT , dummy ) ph_alphabyT = ph_alphabyT / crys % T !Calculate phonon drag term for the current phBTE iteration. call calculate_phonon_drag ( num , el , ph , sym , self % el_rta_rates_ibz , & self % ph_response_E , ph_drag_term_E ) call calculate_phonon_drag ( num , el , ph , sym , self % el_rta_rates_ibz , & self % ph_response_T , ph_drag_term_T ) !Iterate electron response all the way do it_el = 1 , num % maxiter !E field: call iterate_bte_el ( crys % T , . True ., num , el , & self % el_rta_rates_ibz , self % el_field_term_E , self % el_response_E , ph_drag_term_E ) !Calculate electron transport coefficients call calculate_transport_coeff ( 'el' , 'E' , crys % T , el % spindeg , el % chempot , & el % ens , el % vels , crys % volume , el % wvmesh , self % el_response_E , sym , & el_alphabyT , el_sigma ) el_alphabyT = el_alphabyT / crys % T !delT field: call iterate_bte_el ( crys % T , . True ., num , el , & self % el_rta_rates_ibz , self % el_field_term_T , self % el_response_T , ph_drag_term_T ) !Enforce Kelvin-Onsager relation: !Fix \"diffusion\" part do icart = 1 , 3 I_diff (:,:, icart ) = ( el % ens (:,:) - el % chempot ) / qe / crys % T * & self % el_response_E (:,:, icart ) end do !Correct \"drag\" part I_drag = self % el_response_T - I_diff call correct_I_drag ( I_drag , trace ( sum ( ph_alphabyT , dim = 1 )) / crys % dim , lambda ) self % el_response_T = I_diff + lambda * I_drag !Calculate electron transport coefficients call calculate_transport_coeff ( 'el' , 'T' , crys % T , el % spindeg , el % chempot , & el % ens , el % vels , crys % volume , el % wvmesh , self % el_response_T , sym , & el_kappa0 , el_sigmaS ) !Calculate electron transport scalars el_kappa0_scalar = trace ( sum ( el_kappa0 , dim = 1 )) / crys % dim el_sigmaS_scalar = trace ( sum ( el_sigmaS , dim = 1 )) / crys % dim el_sigma_scalar = trace ( sum ( el_sigma , dim = 1 )) / crys % dim el_alphabyT_scalar = trace ( sum ( el_alphabyT , dim = 1 )) / crys % dim !Check convergence if ( converged ( el_kappa0_scalar_old , el_kappa0_scalar , num % conv_thres ) . and . & converged ( el_sigmaS_scalar_old , el_sigmaS_scalar , num % conv_thres ) . and . & converged ( el_sigma_scalar_old , el_sigma_scalar , num % conv_thres ) . and . & converged ( el_alphabyT_scalar_old , el_alphabyT_scalar , num % conv_thres )) then exit else el_kappa0_scalar_old = el_kappa0_scalar el_sigmaS_scalar_old = el_sigmaS_scalar el_sigma_scalar_old = el_sigma_scalar el_alphabyT_scalar_old = el_alphabyT_scalar end if end do !Calculate phonon transport scalar ph_kappa_scalar = trace ( sum ( ph_kappa , dim = 1 )) / crys % dim ph_alphabyT_scalar = trace ( sum ( ph_alphabyT , dim = 1 )) / crys % dim if ( it_ph == 1 ) then !Print RTA band/branch resolved response functions ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call write2file_response ( 'partdcpl_I0_' , self % el_response_T , el % bandlist ) !gradT, el call write2file_response ( 'partdcpl_J0_' , self % el_response_E , el % bandlist ) !E, el ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) end if tot_alphabyT_scalar = el_alphabyT_scalar + ph_alphabyT_scalar KO_dev = 10 0.0_r64 * abs (& ( el_sigmaS_scalar - tot_alphabyT_scalar ) / tot_alphabyT_scalar ) if ( this_image () == 1 ) then write ( * , \"(I3, A, 1E16.8, A, 1E16.8, A, 1E16.8, A, 1E16.8, & A, 1E16.8, A, 1E16.8, A, 1F6.3)\" ) it_ph , \"     \" , el_kappa0_scalar , & \"      \" , el_sigmaS_scalar , \"     \" , ph_kappa_scalar , & \"    \" , el_sigma_scalar , \"        \" , el_alphabyT_scalar , & \"         \" , ph_alphabyT_scalar , \"           \" , KO_dev end if !Print out band resolved transport coefficients ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'drag_ph_kappa_' , it_ph , ph_kappa ) call append2file_transport_tensor ( 'drag_ph_alphabyT_' , it_ph , ph_alphabyT ) call append2file_transport_tensor ( 'drag_el_sigmaS_' , it_ph , el_sigmaS , el % bandlist ) call append2file_transport_tensor ( 'drag_el_sigma_' , it_ph , el_sigma , el % bandlist ) call append2file_transport_tensor ( 'drag_el_alphabyT_' , it_ph , el_alphabyT , el % bandlist ) call append2file_transport_tensor ( 'drag_el_kappa0_' , it_ph , el_kappa0 , el % bandlist ) ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) !Check convergence if ( converged ( ph_kappa_scalar_old , ph_kappa_scalar , num % conv_thres ) . and . & converged ( ph_alphabyT_scalar_old , ph_alphabyT_scalar , num % conv_thres )) then !Print converged band/branch resolved response functions ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call write2file_response ( 'drag_F0_' , self % ph_response_T ) !gradT, ph call write2file_response ( 'drag_I0_' , self % el_response_T , el % bandlist ) !gradT, el call write2file_response ( 'drag_G0_' , self % ph_response_E ) !E, ph call write2file_response ( 'drag_J0_' , self % el_response_E , el % bandlist ) !E, el ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) exit else ph_kappa_scalar_old = ph_kappa_scalar ph_alphabyT_scalar_old = ph_alphabyT_scalar end if end do !Don't need these anymore deallocate ( I_drag , I_diff , ph_drag_term_T , ph_drag_term_E ) call t % end_timer ( 'Coupled e-ph BTEs' ) end if !drag if ( num % onlyphbte . or . num % drag ) then !Phonon BTE call t % start_timer ( 'Iterative decoupled ph BTE' ) call print_message ( \"Decoupled phonon transport:\" ) call print_message ( \"---------------------------\" ) !Restart with RTA solution self % ph_response_T = self % ph_field_term_T if ( this_image () == 1 ) then write ( * , * ) \"iter    k_ph[W/m/K]\" end if do it_ph = 1 , num % maxiter call iterate_bte_ph ( crys % T , . False ., num , ph , el , self % ph_rta_rates_ibz , & self % ph_field_term_T , self % ph_response_T ) !Calculate phonon transport coefficients call calculate_transport_coeff ( 'ph' , 'T' , crys % T , 1_i64 , 0.0_r64 , ph % ens , ph % vels , & crys % volume , ph % wvmesh , self % ph_response_T , sym , ph_kappa , dummy ) !Calculate and print phonon transport scalar ph_kappa_scalar = trace ( sum ( ph_kappa , dim = 1 )) / crys % dim if ( this_image () == 1 ) then write ( * , \"(I3, A, 1E16.8)\" ) it_ph , \"    \" , ph_kappa_scalar end if !Print out branch resolved transport coefficients ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'nodrag_ph_kappa_' , it_ph , ph_kappa ) ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) if ( converged ( ph_kappa_scalar_old , ph_kappa_scalar , num % conv_thres )) then !Print converged branch resolved response functions ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call write2file_response ( 'nodrag_F0_' , self % ph_response_T ) !gradT, ph ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) exit else ph_kappa_scalar_old = ph_kappa_scalar end if end do call t % end_timer ( 'Iterative decoupled ph BTE' ) end if if ( num % onlyebte . or . num % drag ) then !Electron BTE call t % start_timer ( 'Iterative decoupled e BTE' ) call print_message ( \"Decoupled electron transport:\" ) call print_message ( \"-----------------------------\" ) !Restart with RTA solution self % el_response_T = self % el_field_term_T self % el_response_E = self % el_field_term_E if ( this_image () == 1 ) then write ( * , * ) \"iter    k0_el[W/m/K]        sigmaS[A/m/K]\" , & \"         sigma[1/Ohm/m]      alpha_el/T[A/m/K]\" end if do it_el = 1 , num % maxiter !E field: call iterate_bte_el ( crys % T , . False ., num , el , & self % el_rta_rates_ibz , self % el_field_term_E , self % el_response_E ) !Calculate electron transport coefficients call calculate_transport_coeff ( 'el' , 'E' , crys % T , el % spindeg , el % chempot , & el % ens , el % vels , crys % volume , el % wvmesh , self % el_response_E , sym , & el_alphabyT , el_sigma ) el_alphabyT = el_alphabyT / crys % T !delT field: call iterate_bte_el ( crys % T , . False ., num , el , & self % el_rta_rates_ibz , self % el_field_term_T , self % el_response_T , self % ph_response_T ) !Enforce Kelvin-Onsager relation do icart = 1 , 3 self % el_response_T (:,:, icart ) = ( el % ens (:,:) - el % chempot ) / qe / crys % T * & self % el_response_E (:,:, icart ) end do call calculate_transport_coeff ( 'el' , 'T' , crys % T , el % spindeg , el % chempot , & el % ens , el % vels , crys % volume , el % wvmesh , self % el_response_T , sym , & el_kappa0 , el_sigmaS ) !Calculate and print electron transport scalars el_kappa0_scalar = trace ( sum ( el_kappa0 , dim = 1 )) / crys % dim el_sigmaS_scalar = trace ( sum ( el_sigmaS , dim = 1 )) / crys % dim el_sigma_scalar = trace ( sum ( el_sigma , dim = 1 )) / crys % dim el_alphabyT_scalar = trace ( sum ( el_alphabyT , dim = 1 )) / crys % dim if ( this_image () == 1 ) then write ( * , \"(I3, A, 1E16.8, A, 1E16.8, A, 1E16.8, A, 1E16.8)\" ) it_el , & \"    \" , el_kappa0_scalar , \"     \" , el_sigmaS_scalar , & \"     \" , el_sigma_scalar , \"     \" , el_alphabyT_scalar end if !Print out band resolved transport coefficients ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call append2file_transport_tensor ( 'nodrag_el_sigmaS_' , it_el , el_sigmaS , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_sigma_' , it_el , el_sigma , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_alphabyT_' , it_el , el_alphabyT , el % bandlist ) call append2file_transport_tensor ( 'nodrag_el_kappa0_' , it_el , el_kappa0 , el % bandlist ) ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) !Check convergence if ( converged ( el_kappa0_scalar_old , el_kappa0_scalar , num % conv_thres ) . and . & converged ( el_sigmaS_scalar_old , el_sigmaS_scalar , num % conv_thres ) . and . & converged ( el_sigma_scalar_old , el_sigma_scalar , num % conv_thres ) . and . & converged ( el_alphabyT_scalar_old , el_alphabyT_scalar , num % conv_thres )) then !Print converged band resolved response functions ! Change to data output directory call chdir ( trim ( adjustl ( Tdir ))) call write2file_response ( 'nodrag_I0_' , self % el_response_T , el % bandlist ) !gradT, el call write2file_response ( 'nodrag_J0_' , self % el_response_E , el % bandlist ) !E, el ! Change back to cwd call chdir ( trim ( adjustl ( num % cwd ))) exit else el_kappa0_scalar_old = el_kappa0_scalar el_sigmaS_scalar_old = el_sigmaS_scalar el_sigma_scalar_old = el_sigma_scalar el_alphabyT_scalar_old = el_alphabyT_scalar end if end do call t % end_timer ( 'Iterative decoupled e BTE' ) end if contains subroutine correct_I_drag ( I_drag , constraint , lambda ) !! Subroutine to find scaling correction to I_drag. real ( r64 ), intent ( in ) :: I_drag (:,:,:), constraint real ( r64 ), intent ( out ) :: lambda !Internal variables integer ( i64 ) :: it , maxiter real ( r64 ) :: a , b , sigmaS ( size ( I_drag ( 1 ,:, 1 )), 3 , 3 ),& thresh , sigmaS_scalar , dummy ( size ( I_drag ( 1 ,:, 1 )), 3 , 3 ) a = 0.0_r64 !lower bound b = 2.0_r64 !upper bound maxiter = 100 thresh = 1.0e-6_r64 do it = 1 , maxiter lambda = 0.5_r64 * ( a + b ) !Calculate electron transport coefficients call calculate_transport_coeff ( 'el' , 'T' , crys % T , el % spindeg , el % chempot , & el % ens , el % vels , crys % volume , el % wvmesh , lambda * I_drag , sym , & dummy , sigmaS ) sigmaS_scalar = trace ( sum ( sigmaS , dim = 1 )) / crys % dim if ( abs ( sigmaS_scalar - constraint ) < thresh ) then exit else if ( abs ( sigmaS_scalar ) < abs ( constraint )) then a = lambda else b = lambda end if end do end subroutine correct_I_drag end subroutine solve_bte subroutine calculate_field_term ( species , field , nequiv , ibz2fbz_map , & T , chempot , ens , vels , rta_rates_ibz , field_term , el_indexlist ) !! Subroutine to calculate the field coupling term of the BTE. !! !! species Type of particle !! field Type of field !! nequiv List of the number of equivalent points for each IBZ wave vector !! ibz2fbz_map Map from an FBZ wave vectors to its IBZ wedge image !! T Temperature in K !! ens FBZ energies !! vels FBZ velocities !! chempot Chemical potential (should be 0 for phonons) !! rta_rates_ibz IBZ RTA scattering rates !! field_term FBZ field-coupling term of the BTE !! el_indexlist [Optional] character ( len = 2 ), intent ( in ) :: species character ( len = 1 ), intent ( in ) :: field integer ( i64 ), intent ( in ) :: nequiv (:), ibz2fbz_map (:,:,:) real ( r64 ), intent ( in ) :: T , chempot , ens (:,:), vels (:,:,:), rta_rates_ibz (:,:) real ( r64 ), allocatable , intent ( out ) :: field_term (:,:,:) integer ( i64 ), intent ( in ), optional :: el_indexlist (:) !Local variables integer ( i64 ) :: ik_ibz , ik_fbz , ieq , ib , nk_ibz , nk , nbands , pow , & chunk , num_active_images , start , end real ( r64 ) :: A logical :: trivial_case !Set constant and power of energy depending on species and field type if ( species == 'ph' ) then A = 1.0_r64 / T pow = 1 if ( chempot /= 0.0_r64 ) then call exit_with_message ( \"Phonon chemical potential non-zero in calculate_field_term. Exiting.\" ) end if else if ( species == 'el' ) then if ( field == 'T' ) then A = 1.0_r64 / T pow = 1 else if ( field == 'E' ) then A = qe pow = 0 else call exit_with_message ( \"Unknown field type in calculate_field_term. Exiting.\" ) end if else call exit_with_message ( \"Unknown particle species in calculate_field_term. Exiting.\" ) end if !Number of IBZ wave vectors nk_ibz = size ( rta_rates_ibz (:, 1 )) !Number of FBZ wave vectors nk = size ( ens (:, 1 )) !Number of bands nbands = size ( ens ( 1 ,:)) !Allocate and initialize field term allocate ( field_term ( nk , nbands , 3 )) field_term (:,:,:) = 0.0_r64 !No field-coupling case trivial_case = species == 'ph' . and . field == 'E' if (. not . trivial_case ) then !Divide IBZ states among images call distribute_points ( nk_ibz , chunk , start , end , num_active_images ) !Work the active images only: do ik_ibz = start , end do ieq = 1 , nequiv ( ik_ibz ) if ( species == 'ph' ) then ik_fbz = ibz2fbz_map ( ieq , ik_ibz , 2 ) else !Find index of electron in indexlist call binsearch ( el_indexlist , ibz2fbz_map ( ieq , ik_ibz , 2 ), ik_fbz ) end if do ib = 1 , nbands if ( rta_rates_ibz ( ik_ibz , ib ) /= 0.0_r64 ) then field_term ( ik_fbz , ib , :) = A * vels ( ik_fbz , ib , :) * & ( ens ( ik_fbz , ib ) - chempot ) ** pow / rta_rates_ibz ( ik_ibz , ib ) end if end do end do end do !Reduce field term !Units: ! nm.eV/K for phonons, gradT-field ! nm.eV/K for electrons, gradT-field ! nm.C for electrons, E-field sync all call co_sum ( field_term ) sync all end if end subroutine calculate_field_term subroutine iterate_bte_ph ( T , drag , num , ph , el , rta_rates_ibz , & field_term , response_ph , response_el ) !! Subroutine to iterate the phonon BTE one step. !! !! T Temperature in K !! drag Is drag included? !! ph Phonon object !! rta_rates_ibz Phonon RTA scattering rates !! field_term Phonon field coupling term !! response_ph Phonon response function !! response_el Electron response function type ( phonon ), intent ( in ) :: ph type ( electron ), intent ( in ) :: el type ( numerics ), intent ( in ) :: num logical , intent ( in ) :: drag real ( r64 ), intent ( in ) :: T , rta_rates_ibz (:,:), field_term (:,:,:) real ( r64 ), intent ( in ), optional :: response_el (:,:,:) real ( r64 ), intent ( inout ) :: response_ph (:,:,:) !Local variables integer ( i64 ) :: nstates_irred , chunk , istate1 , numbranches , s1 , & iq1_ibz , ieq , iq1_sym , iq1_fbz , iproc , iq2 , s2 , iq3 , s3 , nq , & num_active_images , numbands , ik , ikp , m , n , nprocs_phe , aux1 , aux2 , & nprocs_3ph_plus , nprocs_3ph_minus , start , end integer ( i64 ), allocatable :: istate2_plus (:), istate3_plus (:), & istate2_minus (:), istate3_minus (:), istate_el1 (:), istate_el2 (:) real ( r64 ) :: tau_ibz real ( r64 ), allocatable :: Wp (:), Wm (:), Y (:), response_ph_reduce (:,:,:) character ( len = 1024 ) :: filepath_Wm , filepath_Wp , filepath_Y , tag !Set output directory of transition probilities write ( tag , \"(E9.3)\" ) T if ( drag . and . . not . present ( response_el )) then call exit_with_message ( \"For drag in phonon BTE, must provide electron response. Exiting.\" ) end if if ( drag ) then !Number of electron bands numbands = size ( response_el ( 1 ,:, 1 )) end if !Number of phonon branches numbranches = size ( rta_rates_ibz ( 1 ,:)) !Number of FBZ wave vectors nq = size ( field_term (:, 1 , 1 )) !Total number of IBZ states nstates_irred = size ( rta_rates_ibz (:, 1 )) * numbranches !Allocate and initialize response reduction array allocate ( response_ph_reduce ( nq , numbranches , 3 )) response_ph_reduce (:,:,:) = 0.0_r64 !Divide phonon states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) !Run over first phonon IBZ states do istate1 = start , end !Demux state index into branch (s) and wave vector (iq1_ibz) indices call demux_state ( istate1 , numbranches , s1 , iq1_ibz ) !RTA lifetime tau_ibz = 0.0_r64 if ( rta_rates_ibz ( iq1_ibz , s1 ) /= 0.0_r64 ) then tau_ibz = 1.0_r64 / rta_rates_ibz ( iq1_ibz , s1 ) end if !Set W+ filename write ( tag , '(I9)' ) istate1 filepath_Wp = trim ( adjustl ( num % Wdir )) // '/Wp.istate' // trim ( adjustl ( tag )) !Read W+ from file if ( allocated ( Wp )) deallocate ( Wp ) if ( allocated ( istate2_plus )) deallocate ( istate2_plus ) if ( allocated ( istate3_plus )) deallocate ( istate3_plus ) call read_transition_probs_e ( trim ( adjustl ( filepath_Wp )), nprocs_3ph_plus , Wp , & istate2_plus , istate3_plus ) !Set W- filename filepath_Wm = trim ( adjustl ( num % Wdir )) // '/Wm.istate' // trim ( adjustl ( tag )) !Read W- from file if ( allocated ( Wm )) deallocate ( Wm ) if ( allocated ( istate2_minus )) deallocate ( istate2_minus ) if ( allocated ( istate3_minus )) deallocate ( istate3_minus ) call read_transition_probs_e ( trim ( adjustl ( filepath_Wm )), nprocs_3ph_minus , Wm , & istate2_minus , istate3_minus ) if ( drag ) then !Set Y filename filepath_Y = trim ( adjustl ( num % Ydir )) // '/Y.istate' // trim ( adjustl ( tag )) !Read Y from file if ( allocated ( Y )) deallocate ( Y ) if ( allocated ( istate_el1 )) deallocate ( istate_el1 ) if ( allocated ( istate_el2 )) deallocate ( istate_el2 ) call read_transition_probs_e ( trim ( adjustl ( filepath_Y )), nprocs_phe , Y , & istate_el1 , istate_el2 ) end if !Sum over the number of equivalent q-points of the IBZ point do ieq = 1 , ph % nequiv ( iq1_ibz ) iq1_sym = ph % ibz2fbz_map ( ieq , iq1_ibz , 1 ) !symmetry iq1_fbz = ph % ibz2fbz_map ( ieq , iq1_ibz , 2 ) !image due to symmetry !Sum over scattering processes !Self contribution from plus processes: do iproc = 1 , nprocs_3ph_plus !Grab 2nd and 3rd phonons call demux_state ( istate2_plus ( iproc ), numbranches , s2 , iq2 ) call demux_state ( istate3_plus ( iproc ), numbranches , s3 , iq3 ) response_ph_reduce ( iq1_fbz , s1 , :) = response_ph_reduce ( iq1_fbz , s1 , :) + & Wp ( iproc ) * ( response_ph ( ph % equiv_map ( iq1_sym , iq3 ), s3 , :) - & response_ph ( ph % equiv_map ( iq1_sym , iq2 ), s2 , :)) end do !Self contribution from minus processes: do iproc = 1 , nprocs_3ph_minus !Grab 2nd and 3rd phonons call demux_state ( istate2_minus ( iproc ), numbranches , s2 , iq2 ) call demux_state ( istate3_minus ( iproc ), numbranches , s3 , iq3 ) response_ph_reduce ( iq1_fbz , s1 , :) = response_ph_reduce ( iq1_fbz , s1 , :) + & 0.5_r64 * Wm ( iproc ) * ( response_ph ( ph % equiv_map ( iq1_sym , iq3 ), s3 , :) + & response_ph ( ph % equiv_map ( iq1_sym , iq2 ), s2 , :)) end do !Drag contribution: if ( drag ) then do iproc = 1 , nprocs_phe !Grab initial and final electron states call demux_state ( istate_el1 ( iproc ), numbands , m , ik ) call demux_state ( istate_el2 ( iproc ), numbands , n , ikp ) !Find image of electron wave vector due to the current symmetry call binsearch ( el % indexlist , el % equiv_map ( iq1_sym , ik ), aux1 ) call binsearch ( el % indexlist , el % equiv_map ( iq1_sym , ikp ), aux2 ) response_ph_reduce ( iq1_fbz , s1 , :) = response_ph_reduce ( iq1_fbz , s1 , :) + & el % spindeg * Y ( iproc ) * ( response_el ( aux2 , n , :) - response_el ( aux1 , m , :)) end do end if !Iterate BTE response_ph_reduce ( iq1_fbz , s1 , :) = field_term ( iq1_fbz , s1 , :) + & response_ph_reduce ( iq1_fbz , s1 , :) * tau_ibz end do end do !Update the response function sync all call co_sum ( response_ph_reduce ) sync all response_ph = response_ph_reduce !Symmetrize response function do iq1_fbz = 1 , nq response_ph ( iq1_fbz ,:,:) = transpose (& matmul ( ph % symmetrizers (:,:, iq1_fbz ), transpose ( response_ph ( iq1_fbz ,:,:)))) end do end subroutine iterate_bte_ph subroutine iterate_bte_el ( T , drag , num , el , rta_rates_ibz , field_term , & response_el , ph_drag_term ) !! Subroutine to iterate the electron BTE one step. !! !! T Temperature in K !! drag Is drag included? !! el Electron object !! sym Symmetry !! rta_rates_ibz Electron RTA scattering rates !! field_term Electron field coupling term !! response_el Electron response function !! ph_drag_term Phonon drag term type ( electron ), intent ( in ) :: el type ( numerics ), intent ( in ) :: num logical , intent ( in ) :: drag real ( r64 ), intent ( in ) :: T , rta_rates_ibz (:,:), field_term (:,:,:) real ( r64 ), intent ( in ), optional :: ph_drag_term (:,:,:) real ( r64 ), intent ( inout ) :: response_el (:,:,:) !Local variables integer ( i64 ) :: nstates_irred , nprocs , chunk , istate , numbands , numbranches , & ik_ibz , m , ieq , ik_sym , ik_fbz , iproc , ikp , n , nk , num_active_images , aux , & start , end integer ( i64 ), allocatable :: istate_el (:), istate_ph (:) real ( r64 ) :: tau_ibz real ( r64 ), allocatable :: Xplus (:), Xminus (:), response_el_reduce (:,:,:) character ( 1024 ) :: filepath_Xminus , filepath_Xplus , tag !Set output directory of transition probilities write ( tag , \"(E9.3)\" ) T if ( drag . and . . not . present ( ph_drag_term )) then call exit_with_message ( \"For drag in electron BTE, must provide phonon drag term. Exiting.\" ) end if !Number of electron bands numbands = size ( rta_rates_ibz ( 1 ,:)) !Number of in-window FBZ wave vectors nk = size ( field_term (:, 1 , 1 )) !Total number of IBZ states nstates_irred = size ( rta_rates_ibz (:, 1 )) * numbands if ( drag ) then !Number of phonon branches numbranches = size ( ph_drag_term ( 1 ,:, 1 )) end if !Allocate and initialize response reduction array allocate ( response_el_reduce ( nk , numbands , 3 )) response_el_reduce (:,:,:) = 0.0_r64 !Divide electron states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) !Run over electron IBZ states do istate = start , end !Demux state index into band (m) and wave vector (ik_ibz) indices call demux_state ( istate , numbands , m , ik_ibz ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( el % ens_irred ( ik_ibz , m ) - el % enref ) > el % fsthick ) cycle !RTA lifetime tau_ibz = 0.0_r64 if ( rta_rates_ibz ( ik_ibz , m ) /= 0.0_r64 ) then tau_ibz = 1.0_r64 / rta_rates_ibz ( ik_ibz , m ) end if !Set X+ filename write ( tag , '(I9)' ) istate filepath_Xplus = trim ( adjustl ( num % Xdir )) // '/Xplus.istate' // trim ( adjustl ( tag )) !Read X+ from file call read_transition_probs_e ( trim ( adjustl ( filepath_Xplus )), nprocs , Xplus , & istate_el , istate_ph ) !Set X- filename write ( tag , '(I9)' ) istate filepath_Xminus = trim ( adjustl ( num % Xdir )) // '/Xminus.istate' // trim ( adjustl ( tag )) !Read X- from file call read_transition_probs_e ( trim ( adjustl ( filepath_Xminus )), nprocs , Xminus ) !Sum over the number of equivalent k-points of the IBZ point do ieq = 1 , el % nequiv ( ik_ibz ) ik_sym = el % ibz2fbz_map ( ieq , ik_ibz , 1 ) !symmetry call binsearch ( el % indexlist , el % ibz2fbz_map ( ieq , ik_ibz , 2 ), ik_fbz ) !Sum over scattering processes do iproc = 1 , nprocs !Grab the final electron and, if needed, the interacting phonon call demux_state ( istate_el ( iproc ), numbands , n , ikp ) !Self contribution: !Find image of final electron wave vector due to the current symmetry call binsearch ( el % indexlist , el % equiv_map ( ik_sym , ikp ), aux ) response_el_reduce ( ik_fbz , m , :) = response_el_reduce ( ik_fbz , m , :) + & response_el ( aux , n , :) * ( Xplus ( iproc ) + Xminus ( iproc )) end do !Iterate BTE response_el_reduce ( ik_fbz , m , :) = field_term ( ik_fbz , m , :) + & response_el_reduce ( ik_fbz , m , :) * tau_ibz end do end do !Update the response function sync all call co_sum ( response_el_reduce ) sync all response_el = response_el_reduce if ( drag ) then !Drag contribution: response_el (:,:,:) = response_el (:,:,:) + ph_drag_term (:,:,:) end if !Symmetrize response function do ik_fbz = 1 , nk response_el ( ik_fbz ,:,:) = transpose (& matmul ( el % symmetrizers (:,:, ik_fbz ), transpose ( response_el ( ik_fbz ,:,:)))) end do end subroutine iterate_bte_el subroutine calculate_phonon_drag ( num , el , ph , sym , rta_rates_ibz , response_ph , ph_drag_term ) !! Subroutine to calculate the phonon drag term. !! !! num Numerics object !! el Electron object !! ph Phonon object !! sym Symmetry !! rta_rates_ibz Electron RTA scattering rates !! response_ph Phonon response function !! ph_drag_term Phonon drag term type ( electron ), intent ( in ) :: el type ( phonon ), intent ( in ) :: ph type ( numerics ), intent ( in ) :: num type ( symmetry ), intent ( in ) :: sym real ( r64 ), intent ( in ) :: rta_rates_ibz (:,:), response_ph (:,:,:) real ( r64 ), intent ( out ) :: ph_drag_term (:,:,:) !Local variables integer ( i64 ) :: nstates_irred , nprocs , chunk , istate , numbands , numbranches , & ik_ibz , m , ieq , ik_sym , ik_fbz , iproc , iq , s , nk , num_active_images , & ipol , fineq_indvec ( 3 ), start , end integer ( i64 ), allocatable :: istate_el (:), istate_ph (:) real ( r64 ) :: tau_ibz , ForG ( 3 ) real ( r64 ), allocatable :: Xplus (:), Xminus (:), ph_drag_term_reduce (:,:,:) character ( 1024 ) :: filepath_Xminus , filepath_Xplus , tag !Number of electron bands numbands = el % numbands !Number of in-window FBZ wave vectors nk = el % nwv !Total number of IBZ states nstates_irred = el % nwv_irred * numbands !Number of phonon branches numbranches = ph % numbands !Allocate and initialize response reduction array allocate ( ph_drag_term_reduce ( nk , numbands , 3 )) ph_drag_term_reduce (:,:,:) = 0.0_r64 !Divide electron states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) !Run over electron IBZ states do istate = start , end !Demux state index into band (m) and wave vector (ik_ibz) indices call demux_state ( istate , numbands , m , ik_ibz ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( el % ens_irred ( ik_ibz , m ) - el % enref ) > el % fsthick ) cycle !RTA lifetime tau_ibz = 0.0_r64 if ( rta_rates_ibz ( ik_ibz , m ) /= 0.0_r64 ) then tau_ibz = 1.0_r64 / rta_rates_ibz ( ik_ibz , m ) end if !Set X+ filename write ( tag , '(I9)' ) istate filepath_Xplus = trim ( adjustl ( num % Xdir )) // '/Xplus.istate' // trim ( adjustl ( tag )) !Read X+ from file call read_transition_probs_e ( trim ( adjustl ( filepath_Xplus )), nprocs , Xplus , & istate_el , istate_ph ) !Set X- filename write ( tag , '(I9)' ) istate filepath_Xminus = trim ( adjustl ( num % Xdir )) // '/Xminus.istate' // trim ( adjustl ( tag )) !Read X- from file call read_transition_probs_e ( trim ( adjustl ( filepath_Xminus )), nprocs , Xminus ) !Sum over the number of equivalent k-points of the IBZ point do ieq = 1 , el % nequiv ( ik_ibz ) ik_sym = el % ibz2fbz_map ( ieq , ik_ibz , 1 ) !symmetry call binsearch ( el % indexlist , el % ibz2fbz_map ( ieq , ik_ibz , 2 ), ik_fbz ) !Sum over scattering processes do iproc = 1 , nprocs if ( istate_ph ( iproc ) < 0 ) then !This phonon is on the (fine) electron mesh call demux_state ( - istate_ph ( iproc ), numbranches , s , iq ) iq = - iq !Keep the negative tag else !This phonon is on the phonon mesh call demux_state ( istate_ph ( iproc ), numbranches , s , iq ) end if !Drag contribution: if ( iq < 0 ) then !Need to interpolate on this point !Calculate the fine mesh wave vector, 0-based index vector call demux_vector ( - iq , fineq_indvec , el % wvmesh , 0_i64 ) !Find image of phonon wave vector due to the current symmetry fineq_indvec = modulo ( & nint ( matmul ( sym % qrotations (:, :, ik_sym ), fineq_indvec )), el % wvmesh ) !Interpolate response function on this wave vector do ipol = 1 , 3 call interpolate ( ph % wvmesh , el % mesh_ref_array , response_ph (:, s , ipol ), & fineq_indvec , ForG ( ipol )) end do else !F(q) or G(q) ForG (:) = response_ph ( ph % equiv_map ( ik_sym , iq ), s , :) end if !Here we use the fact that F(-q) = -F(q) and G(-q) = -G(q) ph_drag_term_reduce ( ik_fbz , m , :) = ph_drag_term_reduce ( ik_fbz , m , :) - & ForG (:) * ( Xplus ( iproc ) + Xminus ( iproc )) end do !Multiply life time factor ph_drag_term_reduce ( ik_fbz , m , :) = ph_drag_term_reduce ( ik_fbz , m , :) * tau_ibz end do end do !Reduce from all images sync all call co_sum ( ph_drag_term_reduce ) sync all ph_drag_term = ph_drag_term_reduce end subroutine calculate_phonon_drag pure logical function converged ( oldval , newval , thres ) !! Function to check if newval is the same as oldval real ( r64 ), intent ( in ) :: oldval , newval , thres converged = . False . if ( newval == oldval ) then converged = . True . else if ( oldval /= 0.0_r64 ) then if ( abs ( newval - oldval ) / abs ( oldval ) < thres ) converged = . True . end if end function converged subroutine post_process ( self , num , crys , sym , ph , el ) !! Subroutine to post-process results of the BTEs. class ( bte ), intent ( inout ) :: self type ( numerics ), intent ( in ) :: num type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( phonon ), intent ( in ) :: ph type ( electron ), intent ( in ), optional :: el !Local variables real ( r64 ), allocatable :: ph_en_grid (:), el_en_grid (:), ph_kappa (:,:,:,:), dummy (:,:,:,:), & el_kappa0 (:,:,:,:), el_sigmaS (:,:,:,:), el_sigma (:,:,:,:), el_alphabyT (:,:,:,:), & ph_alphabyT (:,:,:,:), ph_scalar_mfps (:, :), ph_mfp_sampling_grid (:), & ph_kappa_cumulative_mfp (:, :, :, :) character ( len = 1024 ) :: tag , Tdir , numcols integer ( i64 ) :: ik , ib !Calculate electron and/or phonon sampling energy grid call linspace ( ph_en_grid , num % ph_en_min , num % ph_en_max , num % ph_en_num ) call linspace ( el_en_grid , num % el_en_min , num % el_en_max , num % el_en_num ) !Write energy grids to file call write2file_rank1_real ( \"ph.en_grid\" , ph_en_grid ) call write2file_rank1_real ( \"el.en_grid\" , el_en_grid ) !Change to T-dependent directory write ( tag , \"(E9.3)\" ) crys % T Tdir = trim ( adjustl ( num % cwd )) // '/T' // trim ( adjustl ( tag )) call chdir ( trim ( adjustl ( Tdir ))) !Decoupled electron BTE if (. not . num % onlyphbte ) then call print_message ( \"Decoupled electron BTE:\" ) call print_message ( \"---------------------\" ) !gradT: call print_message ( \"gradT field:\" ) ! RTA: call print_message ( \" Calculating RTA electron kappa0 and sigmaS...\" ) !  Allocate response function allocate ( self % el_response_T ( el % nwv , el % numbands , 3 )) !  Read response function call readfile_response ( 'RTA_I0_' , self % el_response_T , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_kappa0 ( el % numbands , 3 , 3 , num % el_en_num ), & el_sigmaS ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'T' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , self % el_response_T , el_en_grid , num % tetrahedra , sym , & el_kappa0 , el_sigmaS ) !  Write spectral electron kappa call write2file_spectral_tensor ( 'RTA_el_kappa0_spectral_' , el_kappa0 , el % bandlist ) !  Write spectral electron sigmaS call write2file_spectral_tensor ( 'RTA_el_sigmaS_spectral_' , el_sigmaS , el % bandlist ) !------------------------------------------------------------------! ! Iterated: call print_message ( \" Calculating iterated electron kappa0 and sigmaS...\" ) !  Read response function call readfile_response ( 'nodrag_I0_' , self % el_response_T , el % bandlist ) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'T' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , self % el_response_T , el_en_grid , num % tetrahedra , sym , & el_kappa0 , el_sigmaS ) !  Write spectral electron kappa call write2file_spectral_tensor ( 'nodrag_iterated_el_kappa0_spectral_' , el_kappa0 , el % bandlist ) !  Write spectral electron sigmaS call write2file_spectral_tensor ( 'nodrag_iterated_el_sigmaS_spectral_' , el_sigmaS , el % bandlist ) !  Release memory deallocate ( self % el_response_T , el_kappa0 , el_sigmaS ) !------------------------------------------------------------------! !E: call print_message ( \"E field:\" ) ! RTA: call print_message ( \" Calculating RTA electron sigma and alpha/T...\" ) !  Allocate response function allocate ( self % el_response_E ( el % nwv , el % numbands , 3 )) !  Read response function call readfile_response ( 'RTA_J0_' , self % el_response_E , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_sigma ( el % numbands , 3 , 3 , num % el_en_num ), & el_alphabyT ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'E' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , self % el_response_E , el_en_grid , num % tetrahedra , sym , & el_alphabyT , el_sigma ) !  Write spectral electron alpha/T call write2file_spectral_tensor ( 'RTA_el_alphabyT_spectral_' , el_alphabyT , el % bandlist ) !  Write spectral electron sigma call write2file_spectral_tensor ( 'RTA_el_sigma_spectral_' , el_sigma , el % bandlist ) !------------------------------------------------------------------! ! Iterated: call print_message ( \" Calculating iterated electron sigma and alpha/T...\" ) !  Read response function call readfile_response ( 'nodrag_J0_' , self % el_response_E , el % bandlist ) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'E' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , self % el_response_E , el_en_grid , num % tetrahedra , sym , & el_alphabyT , el_sigma ) !  Write spectral electron alpha/T call write2file_spectral_tensor ( 'nodrag_iterated_el_alphabyT_spectral_' , el_alphabyT , el % bandlist ) !  Write spectral electron sigma call write2file_spectral_tensor ( 'nodrag_iterated_el_sigma_spectral_' , el_sigma , el % bandlist ) !  Release memory deallocate ( self % el_response_E , el_alphabyT , el_sigma ) end if !Decoupled phonon BTE if (. not . num % onlyebte ) then call print_message ( \"Decoupled phonon BTE:\" ) call print_message ( \"---------------------\" ) !gradT: call print_message ( \"gradT field:\" ) ! RTA: call print_message ( \" Calculating RTA phonon kappa...\" ) !  Allocate response function allocate ( self % ph_response_T ( ph % nwv , ph % numbands , 3 )) !  Read response function call readfile_response ( 'RTA_F0_' , self % ph_response_T ) !  Allocate spectral transport coefficients allocate ( ph_kappa ( ph % numbands , 3 , 3 , num % ph_en_num ), & dummy ( ph % numbands , 3 , 3 , num % ph_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( ph , 'T' , crys % T , 1_i64 , 0.0_r64 , ph % ens , ph % vels , & crys % volume , self % ph_response_T , ph_en_grid , num % tetrahedra , sym , ph_kappa , dummy ) !  Write spectral phonon kappa call write2file_spectral_tensor ( 'RTA_ph_kappa_spectral_' , ph_kappa ) !------------------------------------------------------------------! ! Iterated: call print_message ( \" Calculating iterated phonon kappa...\" ) !  Read response function call readfile_response ( 'nodrag_F0_' , self % ph_response_T ) !  Calculate spectral function call calculate_spectral_transport_coeff ( ph , 'T' , crys % T , 1_i64 , 0.0_r64 , ph % ens , ph % vels , & crys % volume , self % ph_response_T , ph_en_grid , num % tetrahedra , sym , ph_kappa , dummy ) !  Write spectral phonon kappa call write2file_spectral_tensor ( 'nodrag_iterated_ph_kappa_spectral_' , ph_kappa ) !  Calculate scalar phonon mean-free-paths(mfps) for the grad-T field [T-dependent quantity] allocate ( ph_scalar_mfps ( ph % nwv , ph % numbands )) do ib = 1 , ph % numbands do ik = 1 , ph % nwv ph_scalar_mfps ( ik , ib ) = & dot_product ( self % ph_response_T ( ik , ib , :), ph % vels ( ik , ib , :)) & / twonorm ( ph % vels ( ik , ib , :)) end do end do ph_scalar_mfps = ph_scalar_mfps / kB !nm ph_scalar_mfps ( 1 , :) = 0.0_r64 !handle gamma point modes !  Print out IBZ mfps if ( this_image () == 1 ) then write ( numcols , \"(I0)\" ) ph % numbands open ( 1 , file = \"nodrag_iterated_ph_mfps_ibz\" , status = \"replace\" ) do ik = 1 , ph % nwv_irred write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & ph_scalar_mfps ( ph % indexlist_irred ( ik ), :) end do close ( 1 ) end if sync all !  Calculate phonon mfp sampling grid [T-dependent quantity] call linspace ( ph_mfp_sampling_grid , 0.0_r64 , maxval ( ph_scalar_mfps ), num % ph_mfp_npts ) !  Write the sampling mfps to file call write2file_rank1_real ( \"nodrag_iterated_ph_mfps_sampling\" , ph_mfp_sampling_grid ) !  Allocate phonon mfp allocate ( ph_kappa_cumulative_mfp ( ph % numbands , 3 , 3 , num % ph_mfp_npts )) !  Calculate culumative phonon kappa vs scalar mean-free-path (mfp) call calculate_mfp_cumulative_transport_coeff ( ph % prefix , 'T' , crys % T , 1_i64 , 0.0_r64 , & ph % ens , ph % vels , ph % wvmesh , crys % volume , self % ph_response_T , ph_mfp_sampling_grid , & ph_scalar_mfps , sym , ph_kappa_cumulative_mfp ) !, dummy) !  Write scalar mfp cumulative phonon kappa call write2file_spectral_tensor ( 'nodrag_iterated_ph_kappa_mfp_cumulative_' , ph_kappa_cumulative_mfp ) !  Release memory deallocate ( self % ph_response_T , ph_kappa , dummy , ph_kappa_cumulative_mfp ) end if !Partially decoupled electron BTE if ( num % drag ) then call print_message ( \"Partially decoupled electron BTE:\" ) call print_message ( \"---------------------\" ) !gradT: call print_message ( \"gradT field:\" ) ! Iterated: call print_message ( \" Calculating iterated electron kappa0 and sigmaS...\" ) !  Allocate response function allocate ( self % el_response_T ( el % nwv , el % numbands , 3 )) !  Read response function call readfile_response ( 'partdcpl_I0_' , self % el_response_T , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_kappa0 ( el % numbands , 3 , 3 , num % el_en_num ), & el_sigmaS ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'T' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , self % el_response_T , el_en_grid , num % tetrahedra , sym , & el_kappa0 , el_sigmaS ) !  Write spectral electron kappa call write2file_spectral_tensor ( 'partdcpl_iterated_el_kappa0_spectral_' , el_kappa0 , el % bandlist ) !  Write spectral electron sigmaS call write2file_spectral_tensor ( 'partdcpl_iterated_el_sigmaS_spectral_' , el_sigmaS , el % bandlist ) !  Release memory deallocate ( self % el_response_T , el_kappa0 , el_sigmaS ) !------------------------------------------------------------------! !E: call print_message ( \"E field:\" ) ! Iterated: call print_message ( \" Calculating iterated electron sigma and alpha/T...\" ) !  Allocate response function allocate ( self % el_response_E ( el % nwv , el % numbands , 3 )) !  Read response function call readfile_response ( 'partdcpl_J0_' , self % el_response_E , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_sigma ( el % numbands , 3 , 3 , num % el_en_num ), & el_alphabyT ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'E' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , self % el_response_E , el_en_grid , num % tetrahedra , sym , & el_alphabyT , el_sigma ) !  Write spectral electron alpha/T call write2file_spectral_tensor ( 'partdcpl_iterated_el_alphabyT_spectral_' , el_alphabyT , el % bandlist ) !  Write spectral electron sigma call write2file_spectral_tensor ( 'partdcpl_iterated_el_sigma_spectral_' , el_sigma , el % bandlist ) !  Release memory deallocate ( self % el_response_E , el_alphabyT , el_sigma ) end if !Coupled electron BTE if ( num % drag ) then call print_message ( \"Coupled electron BTE:\" ) call print_message ( \"---------------------\" ) !gradT: call print_message ( \"gradT field:\" ) ! Iterated: call print_message ( \" Calculating iterated electron kappa0 and sigmaS...\" ) !  Allocate response function allocate ( self % el_response_T ( el % nwv , el % numbands , 3 )) !  Read response function call readfile_response ( 'drag_I0_' , self % el_response_T , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_kappa0 ( el % numbands , 3 , 3 , num % el_en_num ), & el_sigmaS ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'T' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , self % el_response_T , el_en_grid , num % tetrahedra , sym , & el_kappa0 , el_sigmaS ) !  Write spectral electron kappa call write2file_spectral_tensor ( 'drag_iterated_el_kappa0_spectral_' , el_kappa0 , el % bandlist ) !  Write spectral electron sigmaS call write2file_spectral_tensor ( 'drag_iterated_el_sigmaS_spectral_' , el_sigmaS , el % bandlist ) !  Release memory deallocate ( self % el_response_T , el_kappa0 , el_sigmaS ) !------------------------------------------------------------------! !E: call print_message ( \"E field:\" ) ! Iterated: call print_message ( \" Calculating iterated electron sigma and alpha/T...\" ) !  Allocate response function allocate ( self % el_response_E ( el % nwv , el % numbands , 3 )) !  Read response function call readfile_response ( 'drag_J0_' , self % el_response_E , el % bandlist ) !  Allocate spectral transport coefficients allocate ( el_sigma ( el % numbands , 3 , 3 , num % el_en_num ), & el_alphabyT ( el % numbands , 3 , 3 , num % el_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( el , 'E' , crys % T , el % spindeg , el % chempot , el % ens , & el % vels , crys % volume , self % el_response_E , el_en_grid , num % tetrahedra , sym , & el_alphabyT , el_sigma ) !  Write spectral electron alpha/T call write2file_spectral_tensor ( 'drag_iterated_el_alphabyT_spectral_' , el_alphabyT , el % bandlist ) !  Write spectral electron sigma call write2file_spectral_tensor ( 'drag_iterated_el_sigma_spectral_' , el_sigma , el % bandlist ) !  Release memory deallocate ( self % el_response_E , el_alphabyT , el_sigma ) end if !Coupled phonon BTE if ( num % drag ) then call print_message ( \"Coupled phonon BTE:\" ) call print_message ( \"---------------------\" ) !gradT: call print_message ( \"gradT field:\" ) ! Iterated: call print_message ( \" Calculating iterated phonon kappa...\" ) !  Allocate response function allocate ( self % ph_response_T ( ph % nwv , ph % numbands , 3 )) !  Read response function call readfile_response ( 'drag_F0_' , self % ph_response_T ) !  Allocate spectral transport coefficients allocate ( ph_kappa ( ph % numbands , 3 , 3 , num % ph_en_num ), & dummy ( ph % numbands , 3 , 3 , num % ph_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( ph , 'T' , crys % T , 1_i64 , 0.0_r64 , ph % ens , ph % vels , & crys % volume , self % ph_response_T , ph_en_grid , num % tetrahedra , sym , ph_kappa , dummy ) !  Write spectral phonon kappa call write2file_spectral_tensor ( 'drag_iterated_ph_kappa_spectral_' , ph_kappa ) !  Release memory deallocate ( self % ph_response_T , ph_kappa ) !E: call print_message ( \"E field:\" ) ! Iterated: call print_message ( \" Calculating iterated phonon alpha/T...\" ) !  Allocate response function allocate ( self % ph_response_E ( ph % nwv , ph % numbands , 3 )) !  Read response function call readfile_response ( 'drag_G0_' , self % ph_response_E ) !  Allocate spectral transport coefficients allocate ( ph_alphabyT ( ph % numbands , 3 , 3 , num % ph_en_num )) !  Calculate spectral function call calculate_spectral_transport_coeff ( ph , 'E' , crys % T , 1_i64 , 0.0_r64 , ph % ens , ph % vels , & crys % volume , self % ph_response_E , ph_en_grid , num % tetrahedra , sym , ph_alphabyT , dummy ) !  Write spectral phonon kappa call write2file_spectral_tensor ( 'drag_iterated_ph_alphabyT_spectral_' , ph_alphabyT ) !  Release memory deallocate ( self % ph_response_E , ph_alphabyT , dummy ) !------------------------------------------------------------------! end if !Return to working directory call chdir ( trim ( adjustl ( num % cwd ))) sync all end subroutine post_process end module bte_module","tags":"","loc":"sourcefile/bte.f90.html"},{"title":"params.f90 – elphbolt","text":"Contents Modules params Source Code params.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module params !! Module containing various parameters and constants. use iso_fortran_env , only : real64 , int64 implicit none integer , parameter :: r64 = real64 integer , parameter :: i64 = int64 !Physical constants: real ( r64 ), parameter :: qe = 1.602176634e-19_r64 !! Electron charge magnitude (C) real ( r64 ), parameter :: me = 9.1093837015e-31_r64 !! Electron mass (Kg) real ( r64 ), parameter :: amu = 1.66053906660e-27_r64 !! Atomic mass unit (Kg) real ( r64 ), parameter :: hbar = 1.05457172647e-22_r64 !! Reduced Planck's constant (J/THz = J.ps) real ( r64 ), parameter :: hbar_eVps = hbar / qe !! Reduced Planck's constant (eV/THz = eV.ps) real ( r64 ), parameter :: perm0 = 8.854187817e-12_r64 !! Permittivity of free space (F/m) real ( r64 ), parameter :: kB = 1.380649e-23_r64 / qe !! Boltzmann constant (eV/K) real ( r64 ), parameter :: pi = 4.0_r64 * atan ( 1.0_r64 ) !! Value of pi real ( r64 ), parameter :: twopi = 2.0_r64 * pi !! Value of 2pi !Conversion factors: real ( r64 ), parameter :: Hartree2radTHz = 2 7.2116_r64 * qe / hbar !Hartree to rad.THz real ( r64 ), parameter :: Hartree2eV = 2 7.2116_r64 !Hartree to eV real ( r64 ), parameter :: Ryd2radTHz = 0.5_r64 * Hartree2radTHz !Rydberg to rad.THz real ( r64 ), parameter :: Ryd2eV = 0.5_r64 * Hartree2eV !Rydberg to eV real ( r64 ), parameter :: Ryd2meV = Ryd2eV * 1.0e3_r64 !Rydberg to meV real ( r64 ), parameter :: Ryd2amu = 2.0_r64 * me / amu !Rydberg mass to amu real ( r64 ), parameter :: bohr2nm = 0.052917721092_r64 !Bohr to nm !Miscellaneous complex ( r64 ), parameter :: oneI = ( 0.0_r64 , 1.0_r64 ) complex ( r64 ), parameter :: twopiI = twopi * oneI !The code below is adapted from ShengBTE (file data.f90): !Periodic table from ShengBTE character ( len = 3 ), parameter :: periodic_table ( 114 ) = [ character ( len = 3 ) :: & \"H\" , \"He\" , \"Li\" , \"Be\" , \"B\" , \"C\" , \"N\" , \"O\" , & \"F\" , \"Ne\" , \"Na\" , \"Mg\" , \"Al\" , \"Si\" , \"P\" , \"S\" , \"Cl\" , \"Ar\" , \"K\" , \"Ca\" , \"Sc\" , \"Ti\" , \"V\" , & \"Cr\" , \"Mn\" , \"Fe\" , \"Co\" , \"Ni\" , \"Cu\" , \"Zn\" , \"Ga\" , \"Ge\" , \"As\" , \"Se\" , \"Br\" , \"Kr\" , \"Rb\" , & \"Sr\" , \"Y\" , \"Zr\" , \"Nb\" , \"Mo\" , \"Tc\" , \"Ru\" , \"Rh\" , \"Pd\" , \"Ag\" , \"Cd\" , \"In\" , \"Sn\" , \"Sb\" , & \"Te\" , \"I\" , \"Xe\" , \"Cs\" , \"Ba\" , \"La\" , \"Ce\" , \"Pr\" , \"Nd\" , \"Pm\" , \"Sm\" , \"Eu\" , \"Gd\" , \"Tb\" , & \"Dy\" , \"Ho\" , \"Er\" , \"Tm\" , \"Yb\" , \"Lu\" , \"Hf\" , \"Ta\" , \"W\" , \"Re\" , \"Os\" , \"Ir\" , \"Pt\" , \"Au\" , \"Hg\" , & \"Tl\" , \"Pb\" , \"Bi\" , \"Po\" , \"At\" , \"Rn\" , \"Fr\" , \"Ra\" , \"Ac\" , \"Th\" , \"Pa\" , \"U\" , \"Np\" , \"Pu\" , \"Am\" , & \"Cm\" , \"Bk\" , \"Cf\" , \"Es\" , \"Fm\" , \"Md\" , \"No\" , \"Lr\" , \"Rf\" , \"Db\" , \"Sg\" , \"Bh\" , \"Hs\" , \"Mt\" , \"Ds\" ,& \"Rg\" , \"Cn\" , \"Uuq\" , \"Uuh\" ] end module params","tags":"","loc":"sourcefile/params.f90.html"},{"title":"interactions.f90 – elphbolt","text":"Contents Modules interactions Source Code interactions.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module interactions !! Module containing the procedures related to the computation of interactions. use params , only : i64 , r64 , pi , twopi , amu , qe , hbar_eVps , perm0 use misc , only : exit_with_message , print_message , distribute_points , & demux_state , mux_vector , mux_state , expi , Bose , binsearch , Fermi , & twonorm , write2file_rank2_real , demux_vector , interpolate use wannier_module , only : epw_wannier use crystal_module , only : crystal use electron_module , only : electron use phonon_module , only : phonon use numerics_module , only : numerics use delta , only : delta_fn_tetra , delta_fn_triang implicit none private public calculate_gReq , calculate_gkRp , calculate_3ph_interaction , & calculate_ph_rta_rates , read_transition_probs_e , & calculate_eph_interaction_ibzq , calculate_eph_interaction_ibzk , & calculate_echimp_interaction_ibzk , calculate_el_rta_rates , & calculate_bound_scatt_rates , calculate_thinfilm_scatt_rates , & calculate_4ph_rta_rates !external chdir, system contains pure real ( r64 ) function transfac ( v1 , v2 ) !! Calculate the \"transport factor\" that suppresses forward scattering !! v1, v2: vectors in cartesian coordinates real ( r64 ), intent ( in ) :: v1 ( 3 ), v2 ( 3 ) real ( r64 ) :: v1sc , v2sc , thresh thresh = 1.0e-8_r64 transfac = 0.0_r64 v1sc = twonorm ( v1 ) v2sc = twonorm ( v2 ) if ( v1sc /= v2sc . and . v1sc > thresh . and . v2sc > thresh ) then transfac = 1.0_r64 - dot_product ( v1 , v2 ) / v1sc / v2sc end if end function transfac pure real ( r64 ) function qdist ( q , reclattvecs ) !! Function to calculate the smallest wave vector distance in the BZ. !! q is in crystal coordinates. !! qdist will be in nm&#94;-1 real ( r64 ), intent ( in ) :: q ( 3 ), reclattvecs ( 3 , 3 ) real ( r64 ) :: distfromcorners ( 3 ** 3 ) integer ( i64 ) :: i , j , k , count count = 1 do i = - 1 , 1 do j = - 1 , 1 do k = - 1 , 1 distfromcorners ( count ) = twonorm ( matmul ( reclattvecs , q - ( / i , j , k / ))) count = count + 1 end do end do end do qdist = minval ( distfromcorners ) end function qdist pure real ( r64 ) function gchimp2 ( el , crys , q ) !! Function to calculate the squared electron-charged impurity vertex. !! !! This is the Fourier transform of the Yukawa potential, c.f. Eq. 33 !! of RevModPhys.53.745 (1981). type ( crystal ), intent ( in ) :: crys type ( electron ), intent ( in ) :: el real ( r64 ), intent ( in ) :: q gchimp2 = 1.0e-3_r64 / crys % volume / (( perm0 * crys % epsilon0 ) * ( q ** 2 + crys % qTF ** 2 )) ** 2 * & ( el % chimp_conc_n * ( qe * el % Zn ** 2 ) ** 2 + el % chimp_conc_p * ( qe * el % Zp ** 2 ) ** 2 ) !ev&#94;2 end function gchimp2 pure real ( r64 ) function Vm2_3ph ( ev1_s1 , conjg_ev2_s2 , conjg_ev3_s3 , & Index_i , Index_j , Index_k , ifc3 , phases_q2q3 , ntrip , nb ) !! Function to calculate the squared 3-ph interaction vertex |V-|&#94;2. integer ( i64 ), intent ( in ) :: ntrip , Index_i ( ntrip ), Index_j ( ntrip ), Index_k ( ntrip ), nb complex ( r64 ), intent ( in ) :: phases_q2q3 ( ntrip ), ev1_s1 ( nb ), conjg_ev2_s2 ( nb ), conjg_ev3_s3 ( nb ) real ( r64 ), intent ( in ) :: ifc3 ( 3 , 3 , 3 , ntrip ) !Local variables integer ( i64 ) :: it , a , b , c , aind , bind , cind complex ( r64 ) :: aux1 , aux2 , aux3 , V0 aux1 = ( 0.0_r64 , 0.0_r64 ) do it = 1 , ntrip aind = 3 * ( Index_k ( it ) - 1 ) bind = 3 * ( Index_j ( it ) - 1 ) cind = 3 * ( Index_i ( it ) - 1 ) V0 = ( 0.0_r64 , 0.0_r64 ) do a = 1 , 3 aux2 = conjg_ev3_s3 ( a + aind ) do b = 1 , 3 aux3 = aux2 * conjg_ev2_s2 ( b + bind ) do c = 1 , 3 if ( ifc3 ( c , b , a , it ) /= 0.0_r64 ) then V0 = V0 + ifc3 ( c , b , a , it ) * ev1_s1 ( c + cind ) * aux3 end if end do end do end do aux1 = aux1 + V0 * phases_q2q3 ( it ) end do Vm2_3ph = abs ( aux1 ) ** 2 end function Vm2_3ph subroutine calculate_3ph_interaction ( ph , crys , num , key ) !! Parallel driver of the 3-ph vertex calculator for all IBZ phonon wave vectors. !! This subroutine calculates |V-(s1<q1>|s2q2,s3q3)|&#94;2, W-(s1<q1>|s2q2,s3q3), !! and W+(s1<q1>|s2q2,s3q3) for each irreducible phonon and saves the results to disk. !! !! key = 'V', 'W' for vertex, transition probabilitiy calculation, respectively. type ( phonon ), intent ( in ) :: ph type ( crystal ), intent ( in ) :: crys type ( numerics ), intent ( in ) :: num character ( len = 1 ), intent ( in ) :: key !Local variables integer ( i64 ) :: start , end , chunk , istate1 , nstates_irred , & nprocs , s1 , s2 , s3 , iq1_ibz , iq1 , iq2 , iq3_minus , it , & q1_indvec ( 3 ), q2_indvec ( 3 ), q3_minus_indvec ( 3 ), index_minus , index_plus , & neg_iq2 , neg_q2_indvec ( 3 ), num_active_images , plus_count , minus_count real ( r64 ) :: en1 , en2 , en3 , massfac , q1 ( 3 ), q2 ( 3 ), q3_minus ( 3 ), q2_cart ( 3 ), q3_minus_cart ( 3 ), & occup_fac , const , bose2 , bose3 , delta_minus , delta_plus real ( r64 ), allocatable :: Vm2_1 (:), Vm2_2 (:), Wm (:), Wp (:) integer ( i64 ), allocatable :: istate2_plus (:), istate3_plus (:), istate2_minus (:), istate3_minus (:) complex ( r64 ) :: phases_q2q3 ( ph % numtriplets ) character ( len = 1024 ) :: filename , filename_Wm , filename_Wp if ( key /= 'V' . and . key /= 'W' ) then call exit_with_message ( \"Invalid value of key in call to calculate_3ph_interaction. Exiting.\" ) end if if ( key == 'V' ) then call print_message ( \"Calculating 3-ph vertices for all IBZ phonons...\" ) else call print_message ( \"Calculating 3-ph transition probabilities for all IBZ phonons...\" ) end if !Conversion factor in transition probability expression const = pi / 4.0_r64 * hbar_eVps ** 5 * ( qe / amu ) ** 3 * 1.0d-12 !Total number of IBZ blocks states nstates_irred = ph % nwv_irred * ph % numbands !Maximum total number of 3-phonon processes for a given initial phonon state nprocs = ph % nwv * ph % numbands ** 2 !Allocate |V&#94;-|&#94;2 if ( key == 'V' ) allocate ( Vm2_1 ( nprocs ), Vm2_2 ( nprocs )) ! Above, we split the |V-|&#94;2 vertices into two parts: ! 1. that are non-zero when the minus-type processes are energetically allowed ! 2. that are non-zero when the symmetry-related plus-type processes are energetically allowed !Allocate W- and W+ if ( key == 'W' ) then allocate ( Wp ( nprocs ), Wm ( nprocs )) allocate ( istate2_plus ( nprocs ), istate3_plus ( nprocs ),& istate2_minus ( nprocs ), istate3_minus ( nprocs )) end if !Divide phonon states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" #states = \" , nstates_irred write ( * , \"(A, I10)\" ) \" #states/image = \" , chunk end if !Run over first phonon IBZ states do istate1 = start , end !Load |V&#94;-|&#94;2 from disk for scattering rates calculation if ( key == 'W' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % Vdir ))) !Read data in binary format write ( filename , '(I9)' ) istate1 filename = 'Vm2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'old' , access = 'stream' ) read ( 1 ) minus_count if ( allocated ( Vm2_1 )) deallocate ( Vm2_1 ) allocate ( Vm2_1 ( minus_count )) if ( minus_count > 0 ) read ( 1 ) Vm2_1 read ( 1 ) plus_count if ( allocated ( Vm2_2 )) deallocate ( Vm2_2 ) allocate ( Vm2_2 ( plus_count )) if ( plus_count > 0 ) read ( 1 ) Vm2_2 close ( 1 ) !Change back to working directory call chdir ( num % cwd ) !Initialize transition probabilities Wp (:) = 0.0_r64 Wm (:) = 0.0_r64 istate2_plus (:) = 0_i64 istate3_plus (:) = 0_i64 istate2_minus (:) = 0_i64 istate3_minus (:) = 0_i64 end if !Initialize transition probabilities plus_count = 0_i64 minus_count = 0_i64 !Demux state index into branch (s) and wave vector (iq) indices call demux_state ( istate1 , ph % numbands , s1 , iq1_ibz ) !Muxed index of wave vector from the IBZ index list. !This will be used to access IBZ information from the FBZ quantities. iq1 = ph % indexlist_irred ( iq1_ibz ) !Energy of phonon 1 en1 = ph % ens ( iq1 , s1 ) !Initial (IBZ blocks) wave vector (crystal coords.) q1 = ph % wavevecs ( iq1 , :) !Convert from crystal to 0-based index vector q1_indvec = nint ( q1 * ph % wvmesh ) !Run over second (FBZ) phonon wave vectors do iq2 = 1 , ph % nwv !Initial (IBZ blocks) wave vector (crystal coords.) q2 = ph % wavevecs ( iq2 , :) !Convert from crystal to 0-based index vector q2_indvec = nint ( q2 * ph % wvmesh ) !Folded final phonon wave vector q3_minus_indvec = modulo ( q1_indvec - q2_indvec , ph % wvmesh ) !0-based index vector q3_minus = q3_minus_indvec / dble ( ph % wvmesh ) !crystal coords. !Muxed index of q3_minus iq3_minus = mux_vector ( q3_minus_indvec , ph % wvmesh , 0_i64 ) if ( key == 'V' ) then if ( en1 /= 0.0_r64 ) then !Calculate the numtriplet number of mass-normalized phases for this (q2,q3) pair do it = 1 , ph % numtriplets massfac = 1.0_r64 / sqrt (& crys % masses ( crys % atomtypes ( ph % Index_i ( it ))) * & crys % masses ( crys % atomtypes ( ph % Index_j ( it ))) * & crys % masses ( crys % atomtypes ( ph % Index_k ( it )))) q2_cart = matmul ( crys % reclattvecs , q2 ) q3_minus_cart = matmul ( crys % reclattvecs , q3_minus ) phases_q2q3 ( it ) = massfac * & expi ( - dot_product ( q2_cart , ph % R_j (:, it )) - & dot_product ( q3_minus_cart , ph % R_k (:, it ))) end do end if end if !Run over branches of second phonon do s2 = 1 , ph % numbands !Energy of phonon 2 en2 = ph % ens ( iq2 , s2 ) !Get index of -q2 neg_q2_indvec = modulo ( - q2_indvec , ph % wvmesh ) neg_iq2 = mux_vector ( neg_q2_indvec , ph % wvmesh , 0_i64 ) if ( key == 'W' ) then !Bose factor for phonon 2 bose2 = Bose ( en2 , crys % T ) end if !Run over branches of third phonon do s3 = 1 , ph % numbands !Minus process index index_minus = (( iq2 - 1 ) * ph % numbands + ( s2 - 1 )) * ph % numbands + s3 !Energy of phonon 3 en3 = ph % ens ( iq3_minus , s3 ) !Evaluate delta functions if ( num % tetrahedra ) then delta_minus = delta_fn_tetra ( en1 - en3 , iq2 , s2 , ph % wvmesh , ph % tetramap , & ph % tetracount , ph % tetra_evals ) !minus process delta_plus = delta_fn_tetra ( en3 - en1 , neg_iq2 , s2 , ph % wvmesh , ph % tetramap , & ph % tetracount , ph % tetra_evals ) !plus process else delta_minus = delta_fn_triang ( en1 - en3 , iq2 , s2 , ph % wvmesh , ph % triangmap , & ph % triangcount , ph % triang_evals ) !minus process delta_plus = delta_fn_triang ( en3 - en1 , neg_iq2 , s2 , ph % wvmesh , ph % triangmap , & ph % triangcount , ph % triang_evals ) !plus process end if if ( key == 'V' ) then if ( en1 * en2 * en3 == 0.0_r64 ) cycle if ( delta_minus > 0.0_r64 ) then !Increase counter for energetically available minus process minus_count = minus_count + 1 !Save the index of this process !V1_indexlist(minus_count) = index_minus !Calculate and save the minus process vertex Vm2_1 ( minus_count ) = Vm2_3ph ( ph % evecs ( iq1 , s1 , :), & conjg ( ph % evecs ( iq2 , s2 , :)), conjg ( ph % evecs ( iq3_minus , s3 , :)), & ph % Index_i (:), ph % Index_j (:), ph % Index_k (:), ph % ifc3 (:,:,:,:), & phases_q2q3 , ph % numtriplets , ph % numbands ) end if if ( delta_plus > 0.0_r64 ) then !Increase counter for energetically available plus process plus_count = plus_count + 1 !Calculate and save the minus process vertex Vm2_2 ( plus_count ) = Vm2_3ph ( ph % evecs ( iq1 , s1 , :), & conjg ( ph % evecs ( iq2 , s2 , :)), conjg ( ph % evecs ( iq3_minus , s3 , :)), & ph % Index_i (:), ph % Index_j (:), ph % Index_k (:), ph % ifc3 (:,:,:,:), & phases_q2q3 , ph % numtriplets , ph % numbands ) end if end if if ( key == 'W' ) then if ( en1 * en2 * en3 == 0.0_r64 ) cycle !Bose factor for phonon 3 bose3 = Bose ( en3 , crys % T ) !Calculate W-: !Temperature dependent occupation factor !(bose1 + 1)*bose2*bose3/(bose1*(bose1 + 1)) ! = (bose2 + bose3 + 1) occup_fac = ( bose2 + bose3 + 1.0_r64 ) if ( delta_minus > 0.0_r64 ) then !Non-zero process counter minus_count = minus_count + 1 !Save W- !Wm(minus_count) = Vm2(index_minus)*occup_fac*delta_minus/en1/en2/en3 Wm ( minus_count ) = Vm2_1 ( minus_count ) * occup_fac * delta_minus / en1 / en2 / en3 istate2_minus ( minus_count ) = mux_state ( ph % numbands , s2 , iq2 ) istate3_minus ( minus_count ) = mux_state ( ph % numbands , s3 , iq3_minus ) end if !Calculate W+: !Grab index of corresponding plus process using !V-(s1q1|s2q2,s3q3) = V+(s1q1|s2-q2,s3q3) index_plus = (( neg_iq2 - 1 ) * ph % numbands + ( s2 - 1 )) * ph % numbands + s3 !Temperature dependent occupation factor !(bose1 + 1)*(bose2 + 1)*bose3/(bose1*(bose1 + 1)) ! = bose2 - bose3. occup_fac = ( bose2 - bose3 ) if ( delta_plus > 0.0_r64 ) then !Non-zero process counter plus_count = plus_count + 1 !Save W+ Wp ( plus_count ) = Vm2_2 ( plus_count ) * occup_fac * delta_plus / en1 / en2 / en3 istate2_plus ( plus_count ) = mux_state ( ph % numbands , s2 , neg_iq2 ) istate3_plus ( plus_count ) = mux_state ( ph % numbands , s3 , iq3_minus ) end if end if end do !s3 end do !s2 end do !iq2 if ( key == 'V' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % Vdir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate1 filename = 'Vm2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) minus_count write ( 1 ) Vm2_1 ( 1 : minus_count ) write ( 1 ) plus_count write ( 1 ) Vm2_2 ( 1 : plus_count ) close ( 1 ) end if if ( key == 'W' ) then !Multiply constant factor, unit factor, etc. Wm (:) = const * Wm (:) !THz Wp (:) = const * Wp (:) !THz !Write W+ and W- to disk !Change to data output directory call chdir ( trim ( adjustl ( num % Wdir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate1 filename_Wm = 'Wm.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename_Wm ), status = 'replace' , access = 'stream' ) write ( 1 ) minus_count write ( 1 ) Wm ( 1 : minus_count ) write ( 1 ) istate2_minus ( 1 : minus_count ) write ( 1 ) istate3_minus ( 1 : minus_count ) close ( 1 ) filename_Wp = 'Wp.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename_Wp ), status = 'replace' , access = 'stream' ) write ( 1 ) plus_count write ( 1 ) Wp ( 1 : plus_count ) write ( 1 ) istate2_plus ( 1 : plus_count ) write ( 1 ) istate3_plus ( 1 : plus_count ) close ( 1 ) end if !Change back to working directory call chdir ( num % cwd ) end do !istate1 sync all end subroutine calculate_3ph_interaction subroutine calculate_gReq ( wann , ph , num ) !! Parallel driver of gReq_epw over IBZ phonon wave vectors. type ( epw_wannier ), intent ( in ) :: wann type ( phonon ), intent ( in ) :: ph type ( numerics ), intent ( in ) :: num !Local variables integer ( i64 ) :: iq , iqstart , iqend , chunk , num_active_images call print_message ( \"Calculating g(Re,Rp) -> g(Re,q) for all IBZ q...\" ) call distribute_points ( ph % nwv_irred , chunk , iqstart , iqend , num_active_images ) if ( this_image () == 1 ) then print * , \"   #q = \" , ph % nwv_irred print * , \"   #q/image = \" , chunk end if do iq = iqstart , iqend call wann % gReq_epw ( num , iq , ph % wavevecs_irred ( iq , :)) end do sync all end subroutine calculate_gReq subroutine calculate_gkRp ( wann , el , num ) !! Parallel driver of gkRp_epw over IBZ electron wave vectors. type ( epw_wannier ), intent ( in ) :: wann type ( electron ), intent ( in ) :: el type ( numerics ), intent ( in ) :: num !Local variables integer ( i64 ) :: ik , ikstart , ikend , chunk , num_active_images call print_message ( \"Calculating g(Re,Rp) -> g(k,Rp) for all IBZ k...\" ) call distribute_points ( el % nwv_irred , chunk , ikstart , ikend , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" #k = \" , el % nwv_irred write ( * , \"(A, I10)\" ) \" #k/image = \" , chunk end if do ik = ikstart , ikend call wann % gkRp_epw ( num , ik , el % wavevecs_irred ( ik , :)) end do sync all end subroutine calculate_gkRp subroutine calculate_eph_interaction_ibzq ( wann , crys , el , ph , num , key ) !! Parallel driver of g2(q,k) over IBZ phonon states. !! !! This subroutine will calculate the full Bloch rep. matrix elements for !! all the energy window restricted electron-phonon processes for a given !! irreducible initial phonon state = (branch, wave vector). !! This list will be written to disk in files tagged with the muxed state index. !! !! key = 'g', 'Y' for vertex, transition probability calculation, respectively. ! !In the FBZ and IBZ blocks a wave vector was retained when at least one !band belonged within the energy window. Here the bands outside the energy !window will be skipped in the calculation as they are irrelevant for transport. type ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys type ( electron ), intent ( in ) :: el type ( phonon ), intent ( in ) :: ph type ( numerics ), intent ( in ) :: num character ( len = 1 ), intent ( in ) :: key !Local variables integer ( i64 ) :: nstates_irred , istate , m , iq , iq_fbz , n , ik , ikp , s , & ikp_window , start , end , chunk , k_indvec ( 3 ), kp_indvec ( 3 ), & q_indvec ( 3 ), nprocs , count , num_active_images integer ( i64 ), allocatable :: istate1 (:), istate2 (:) real ( r64 ) :: k ( 3 ), q ( 3 ), en_ph , en_el , en_elp , const , delta , & invboseplus1 , fermi1 , fermi2 , occup_fac real ( r64 ), allocatable :: g2_istate (:), Y_istate (:) complex ( r64 ), allocatable :: gReq_iq (:,:,:,:) character ( len = 1024 ) :: filename if ( key /= 'g' . and . key /= 'Y' ) then call exit_with_message (& \"Invalid value of key in call to calculate_eph_interaction_ibzq. Exiting.\" ) end if if ( key == 'g' ) then call print_message ( \"Calculating g(Re,q) -> |g(k,q)|&#94;2 for all IBZ phonons...\" ) else call print_message ( \"Calculating ph-e transition probabilities for all IBZ phonons...\" ) end if !Allocate and initialize gReq_iq and g2_istate if ( key == 'g' ) then allocate ( gReq_iq ( wann % numwannbands , wann % numwannbands , wann % numbranches , wann % nwsk )) !Maximum length of g2_istate nprocs = el % nstates_inwindow * ph % numbands allocate ( g2_istate ( nprocs )) g2_istate (:) = 0.0_r64 end if !Conversion factor in transition probability expression const = twopi / hbar_eVps !Total number of IBZ blocks states nstates_irred = ph % nwv_irred * ph % numbands call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" #states = \" , nstates_irred write ( * , \"(A, I10)\" ) \" #states/image = \" , chunk end if do istate = start , end !over IBZ blocks states !Demux state index into branch (s) and wave vector (iq) indices call demux_state ( istate , ph % numbands , s , iq ) if ( key == 'g' ) then !Load gReq(iq) here for use inside the loops below call chdir ( trim ( adjustl ( num % g2dir ))) write ( filename , '(I6)' ) iq filename = 'gReq.iq' // trim ( adjustl ( filename )) open ( 1 , file = filename , status = \"old\" , access = 'stream' ) read ( 1 ) gReq_iq close ( 1 ) call chdir ( num % cwd ) end if !Get the muxed index of FBZ wave vector from the IBZ blocks index list iq_fbz = ph % indexlist_irred ( iq ) !Energy of phonon en_ph = ph % ens ( iq_fbz , s ) !1/(1 + Bose factor) for phonon if ( key == 'Y' ) then if ( en_ph /= 0.0_r64 ) then invboseplus1 = 1.0_r64 / ( 1.0_r64 + Bose ( en_ph , crys % T )) else invboseplus1 = 0.0_r64 end if end if !Initial (IBZ blocks) wave vector (crystal coords.) q = ph % wavevecs ( iq_fbz , :) !Convert from crystal to 0-based index vector q_indvec = nint ( q * ph % wvmesh ) !Load g2_istate from disk for scattering rates calculation if ( key == 'Y' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Read data in binary format write ( filename , '(I9)' ) istate filename = 'gq2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'old' , access = 'stream' ) read ( 1 ) nprocs if ( allocated ( g2_istate )) deallocate ( g2_istate , Y_istate , istate1 , istate2 ) allocate ( g2_istate ( nprocs )) if ( nprocs > 0 ) read ( 1 ) g2_istate close ( 1 ) !Change back to working directory call chdir ( num % cwd ) !Allocate and initialize quantities related to transition probabilities allocate ( Y_istate ( nprocs )) allocate ( istate1 ( nprocs ), istate2 ( nprocs )) istate1 (:) = - 1_i64 istate2 (:) = - 1_i64 Y_istate (:) = 0.0_r64 end if !Initialize process counter count = 0 !Run over initial (in-window, FBZ blocks) electron wave vectors do ik = 1 , el % nwv !Initial wave vector (crystal coords.) k = el % wavevecs ( ik , :) !Convert from crystal to 0-based index vector k_indvec = nint ( k * el % wvmesh ) !Find final electron wave vector kp_indvec = modulo ( k_indvec + el % mesh_ref_array * q_indvec , el % wvmesh ) !0-based index vector !Muxed index of kp ikp = mux_vector ( kp_indvec , el % wvmesh , 0_i64 ) !Check if final electron wave vector is within energy window call binsearch ( el % indexlist , ikp , ikp_window ) if ( ikp_window < 0 ) cycle !Run over initial electron bands do m = 1 , el % numbands !Energy of initial electron en_el = el % ens ( ik , m ) !Apply energy window to initial electron if ( abs ( en_el - el % enref ) > el % fsthick ) cycle !Fermi factor for initial and final electrons if ( key == 'Y' ) then fermi1 = Fermi ( en_el , el % chempot , crys % T ) fermi2 = Fermi ( en_el + en_ph , el % chempot , crys % T ) end if !Run over final electron bands do n = 1 , el % numbands !Energy of final electron en_elp = el % ens ( ikp_window , n ) !Apply energy window to final electron if ( abs ( en_elp - el % enref ) > el % fsthick ) cycle !Increment g2 process counter count = count + 1 if ( key == 'g' ) then !Calculate |g_mns(k,<q>)|&#94;2 g2_istate ( count ) = wann % g2_epw ( crys , k , q , el % evecs ( ik , m , :), & el % evecs ( ikp_window , n , :), ph % evecs ( iq_fbz , s , :), & ph % ens ( iq_fbz , s ), gReq_iq , 'el' ) end if if ( key == 'Y' ) then !Calculate Y: !Evaluate delta function if ( num % tetrahedra ) then delta = delta_fn_tetra ( en_elp - en_ph , ik , m , el % wvmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( en_elp - en_ph , ik , m , el % wvmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if !Temperature dependent occupation factor occup_fac = fermi1 * ( 1.0_r64 - fermi2 ) * invboseplus1 !Save Y if ( en_ph >= 0.5e-3 ) then !Use a small phonon energy cut-off Y_istate ( count ) = g2_istate ( count ) * occup_fac * delta end if !Save initial and final electron states istate1 ( count ) = mux_state ( el % numbands , m , ik ) istate2 ( count ) = mux_state ( el % numbands , n , ikp_window ) end if end do !n end do !m end do !ik if ( key == 'g' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'gq2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) g2_istate ( 1 : count ) close ( 1 ) end if if ( key == 'Y' ) then !Multiply constant factor, unit factor, etc. Y_istate ( 1 : count ) = const * Y_istate ( 1 : count ) !THz !Change to data output directory call chdir ( trim ( adjustl ( num % Ydir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'Y.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) Y_istate ( 1 : count ) write ( 1 ) istate1 ( 1 : count ) write ( 1 ) istate2 ( 1 : count ) close ( 1 ) end if !Change back to working directory call chdir ( num % cwd ) if ( key == 'Y' ) deallocate ( g2_istate , Y_istate , istate1 , istate2 ) end do sync all if ( key == 'g' ) then !Delete the gReq disk data if ( this_image () == 1 ) then call chdir ( trim ( adjustl ( num % g2dir ))) call system ( 'rm gReq.*' ) call chdir ( num % cwd ) end if end if sync all end subroutine calculate_eph_interaction_ibzq subroutine calculate_eph_interaction_ibzk ( wann , crys , el , ph , num , key ) !! Parallel driver of g2(k,q) over IBZ electron states. !! !! This subroutine will calculate the full Bloch rep. matrix elements for !! all the energy window restricted electron-phonon processes for a given !! irreducible initial electron state = (band, wave vector). !! This list will be written to disk in files tagged with the muxed state index. !! !! key = 'g', 'X' for vertex, transition probability calculation, respectively. ! !In the FBZ and IBZ blocks a wave vector was retained when at least one !band belonged within the energy window. Here the bands outside the energy !window will be skipped in the calculation as they are irrelevant for transport. type ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys type ( electron ), intent ( in ) :: el type ( phonon ), intent ( in ) :: ph type ( numerics ), intent ( in ) :: num character ( len = 1 ), intent ( in ) :: key !Local variables integer ( i64 ) :: nstates_irred , istate , m , ik , n , ikp , s , & iq , start , end , chunk , k_indvec ( 3 ), kp_indvec ( 3 ), & q_indvec ( 3 ), count , nprocs , num_active_images real ( r64 ) :: k ( 3 ), kp ( 3 ), q ( 3 ), ph_ens_iq ( 1 , ph % numbands ), qlist ( 1 , 3 ), & const , bosefac , fermi_minus_fac , fermi_plus_fac , en_ph , en_el , delta , occup_fac real ( r64 ), allocatable :: g2_istate (:), Xplus_istate (:), Xminus_istate (:) integer ( i64 ), allocatable :: istate_el (:), istate_ph (:) complex ( r64 ), allocatable :: gkRp_ik (:, :, :, :) complex ( r64 ) :: ph_evecs_iq ( 1 , ph % numbands , ph % numbands ) character ( len = 1024 ) :: filename logical :: needfinephon if ( key /= 'g' . and . key /= 'X' ) then call exit_with_message (& \"Invalid value of key in call to calculate_eph_interaction_ibzk. Exiting.\" ) end if if ( key == 'g' ) then call print_message ( \"Calculating g(k,Rp) -> |g(k,q)|&#94;2 for all IBZ electrons...\" ) else call print_message ( \"Calculating e-ph transition probabilities for all IBZ electrons...\" ) end if !Allocate and initialize gkRp_ik and g2_istate if ( key == 'g' ) then allocate ( gkRp_ik ( wann % numwannbands , wann % numwannbands , wann % numbranches , wann % nwsq )) !Length of g2_istate nprocs = el % nstates_inwindow * wann % numbranches allocate ( g2_istate ( nprocs )) g2_istate (:) = 0.0_r64 end if !Conversion factor in transition probability expression const = twopi / hbar_eVps !Total number of IBZ blocks states nstates_irred = el % nwv_irred * wann % numwannbands call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" #states = \" , nstates_irred write ( * , \"(A, I10)\" ) \" #states/image = \" , chunk end if do istate = start , end !over IBZ blocks states !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , wann % numwannbands , m , ik ) if ( key == 'g' ) then !Load gkRp(ik) here for use inside the loops below call chdir ( trim ( adjustl ( num % g2dir ))) write ( filename , '(I6)' ) ik filename = 'gkRp.ik' // trim ( adjustl ( filename )) open ( 1 , file = filename , status = \"old\" , access = 'stream' ) read ( 1 ) gkRp_ik close ( 1 ) call chdir ( num % cwd ) end if !Electron energy en_el = el % ens_irred ( ik , m ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( en_el - el % enref ) > el % fsthick ) cycle !Initial (IBZ blocks) wave vector (crystal coords.) k = el % wavevecs_irred ( ik , :) !Convert from crystal to 0-based index vector k_indvec = nint ( k * el % wvmesh ) !Load g2_istate from disk for scattering rates calculation if ( key == 'X' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Read data in binary format write ( filename , '(I9)' ) istate filename = 'gk2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'old' , access = 'stream' ) read ( 1 ) nprocs if ( allocated ( g2_istate )) deallocate ( g2_istate , Xplus_istate , Xminus_istate , & istate_el , istate_ph ) allocate ( g2_istate ( nprocs )) if ( nprocs > 0 ) read ( 1 ) g2_istate close ( 1 ) !Change back to working directory call chdir ( num % cwd ) !Allocate and initialize quantities related to transition probabilities allocate ( Xplus_istate ( nprocs ), Xminus_istate ( nprocs )) allocate ( istate_el ( nprocs ), istate_ph ( nprocs )) istate_el (:) = 0_i64 istate_ph (:) = 0_i64 Xplus_istate (:) = 0.0_r64 Xminus_istate (:) = 0.0_r64 end if !Initialize eligible process counter for this state count = 0 !Run over final (FBZ blocks) electron wave vectors do ikp = 1 , el % nwv !Final wave vector (crystal coords.) kp = el % wavevecs ( ikp , :) !Convert from crystal to 0-based index vector kp_indvec = nint ( kp * el % wvmesh ) !Find interacting phonon wave vector !Note that q, k, and k' are all on the same mesh q_indvec = kp_indvec - k_indvec needfinephon = . false . if ( any ( mod ( q_indvec (:), el % mesh_ref_array ) /= 0_i64 )) then needfinephon = . true . q_indvec = modulo ( q_indvec , el % wvmesh ) !0-based index vector q = q_indvec / dble ( el % wvmesh ) !crystal coords. !Muxed index of q iq = mux_vector ( q_indvec , el % wvmesh , 0_i64 ) !Calculate the fine mesh phonon. qlist ( 1 , :) = q call wann % ph_wann_epw ( crys , 1_i64 , qlist , ph_ens_iq , ph_evecs_iq ) else !Original (coarser) mesh phonon q_indvec = modulo ( q_indvec / el % mesh_ref_array , ph % wvmesh ) !0-based index vector q = q_indvec / dble ( ph % wvmesh ) !crystal coords. !Muxed index of q iq = mux_vector ( q_indvec , ph % wvmesh , 0_i64 ) end if !Run over final electron bands do n = 1 , wann % numwannbands !Apply energy window to final electron if ( abs ( el % ens ( ikp , n ) - el % enref ) > el % fsthick ) cycle !Run over phonon branches do s = 1 , wann % numbranches !Increment g2 processes counter count = count + 1 if ( key == 'g' ) then !Calculate |g_mns(<k>,q)|&#94;2 if ( needfinephon ) then g2_istate ( count ) = wann % g2_epw ( crys , k , q , el % evecs_irred ( ik , m , :), & el % evecs ( ikp , n , :), ph_evecs_iq ( 1 , s , :), & ph_ens_iq ( 1 , s ), gkRp_ik , 'ph' ) else g2_istate ( count ) = wann % g2_epw ( crys , k , q , el % evecs_irred ( ik , m , :), & el % evecs ( ikp , n , :), ph % evecs ( iq , s , :), & ph % ens ( iq , s ), gkRp_ik , 'ph' ) end if end if if ( key == 'X' ) then !Phonon energy if ( needfinephon ) then en_ph = ph_ens_iq ( 1 , s ) else en_ph = ph % ens ( iq , s ) end if !Bose and Fermi factors if ( en_ph /= 0.0_r64 ) then bosefac = Bose ( en_ph , crys % T ) else bosefac = 0.0_r64 end if fermi_plus_fac = Fermi ( en_el + en_ph , el % chempot , crys % T ) fermi_minus_fac = Fermi ( en_el - en_ph , el % chempot , crys % T ) !Calculate X+: !Evaulate delta function if ( num % tetrahedra ) then delta = delta_fn_tetra ( en_el + en_ph , ikp , n , el % wvmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( en_el + en_ph , ikp , n , el % wvmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if !Temperature dependent occupation factor occup_fac = bosefac + fermi_plus_fac !Save X+ if ( en_ph >= 0.5e-3 ) then !Use a small phonon energy cut-off Xplus_istate ( count ) = g2_istate ( count ) * occup_fac * delta end if !Calculate X-: !Evaulate delta function if ( num % tetrahedra ) then delta = delta_fn_tetra ( en_el - en_ph , ikp , n , el % wvmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( en_el - en_ph , ikp , n , el % wvmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if !Temperature dependent occupation factor occup_fac = 1.0_r64 + bosefac - fermi_minus_fac !Save X- if ( en_ph >= 0.5e-3 ) then !Use a small phonon energy cut-off Xminus_istate ( count ) = g2_istate ( count ) * occup_fac * delta end if !Save final electron and interacting phonon states (same for + and -) istate_el ( count ) = mux_state ( el % numbands , n , ikp ) if ( needfinephon ) then !Write fine phonon index as negative so that the iterator !knows to interpolate phonon quantities at this wave vector. istate_ph ( count ) = - mux_state ( ph % numbands , s , iq ) else istate_ph ( count ) = mux_state ( ph % numbands , s , iq ) end if end if end do !s end do !n end do !ikp if ( key == 'g' ) then !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'gk2.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) g2_istate close ( 1 ) end if if ( key == 'X' ) then !Multiply constant factor, unit factor, etc. Xplus_istate ( 1 : count ) = const * Xplus_istate ( 1 : count ) !THz Xminus_istate ( 1 : count ) = const * Xminus_istate ( 1 : count ) !THz !Change to data output directory call chdir ( trim ( adjustl ( num % Xdir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'Xplus.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) Xplus_istate ( 1 : count ) write ( 1 ) istate_el ( 1 : count ) write ( 1 ) istate_ph ( 1 : count ) close ( 1 ) write ( filename , '(I9)' ) istate filename = 'Xminus.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) Xminus_istate ( 1 : count ) write ( 1 ) istate_el ( 1 : count ) write ( 1 ) istate_ph ( 1 : count ) close ( 1 ) end if !Change back to working directory call chdir ( num % cwd ) if ( key == 'X' ) deallocate ( g2_istate , Xplus_istate , Xminus_istate , & istate_el , istate_ph ) end do sync all if ( key == 'g' ) then !Delete the gkRp disk data if ( this_image () == 1 ) then call chdir ( trim ( adjustl ( num % g2dir ))) call system ( 'rm gkRp.*' ) call chdir ( num % cwd ) endif end if sync all end subroutine calculate_eph_interaction_ibzk subroutine calculate_echimp_interaction_ibzk ( crys , el , num ) !! Parallel driver of |g_e-chimp(k,k')|&#94;2 over IBZ electron states. !! ! !In the FBZ and IBZ blocks a wave vector was retained when at least one !band belonged within the energy window. Here the bands outside the energy !window will be skipped in the calculation as they are irrelevant for transport. type ( crystal ), intent ( in ) :: crys type ( electron ), intent ( in ) :: el type ( numerics ), intent ( in ) :: num !Local variables integer ( i64 ) :: nstates_irred , istate , m , ik , n , ikp , & start , end , chunk , k_indvec ( 3 ), kp_indvec ( 3 ), & q_indvec ( 3 ), count , nprocs , num_active_images real ( r64 ) :: k ( 3 ), kp ( 3 ), q_mag , const , en_el , delta , g2 real ( r64 ), allocatable :: Xchimp_istate (:) integer ( i64 ), allocatable :: istate_el (:) character ( len = 1024 ) :: filename call print_message ( \"Calculating e-ch. imp. transition probabilities for all IBZ electrons...\" ) !Conversion factor in transition probability expression const = twopi / hbar_eVps !Number of processes nprocs = el % nstates_inwindow allocate ( Xchimp_istate ( nprocs ), istate_el ( nprocs )) Xchimp_istate (:) = 0.0_r64 istate_el (:) = 0_i64 !Total number of IBZ blocks states nstates_irred = el % nwv_irred * el % numbands call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" #states = \" , nstates_irred write ( * , \"(A, I10)\" ) \" #states/image = \" , chunk end if do istate = start , end !over IBZ blocks states !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , el % numbands , m , ik ) !Electron energy en_el = el % ens_irred ( ik , m ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( en_el - el % enref ) > el % fsthick ) cycle !Initial (IBZ blocks) wave vector (crystal coords.) k = el % wavevecs_irred ( ik , :) !Convert from crystal to 0-based index vector k_indvec = nint ( k * el % wvmesh ) !Initialize eligible process counter for this state count = 0 !Run over final (FBZ blocks) electron wave vectors do ikp = 1 , el % nwv !Final wave vector (crystal coords.) kp = el % wavevecs ( ikp , :) !Convert from crystal to 0-based index vector kp_indvec = nint ( kp * el % wvmesh ) !Find interacting phonon wave vector !Note that q, k, and k' are all on the same mesh q_indvec = kp_indvec - k_indvec !0-based index vector !Calculate length of the wave vector q_mag = qdist ( q_indvec / dble ( el % wvmesh ), crys % reclattvecs ) !Calculate matrix element g2 = gchimp2 ( el , crys , q_mag ) !Run over final electron bands do n = 1 , el % numbands !Apply energy window to final electron if ( abs ( el % ens ( ikp , n ) - el % enref ) > el % fsthick ) cycle !Increment g2 processes counter count = count + 1 !Evaulate delta function if ( num % tetrahedra ) then delta = delta_fn_tetra ( en_el , ikp , n , el % wvmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( en_el , ikp , n , el % wvmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if !Save Xchimp Xchimp_istate ( count ) = g2 * transfac ( matmul ( crys % reclattvecs , k ), & matmul ( crys % reclattvecs , kp )) * delta !Save final electron state istate_el ( count ) = mux_state ( el % numbands , n , ikp ) end do !n end do !ikp !Multiply constant factor, unit factor, etc. Xchimp_istate ( 1 : count ) = const * Xchimp_istate ( 1 : count ) !THz !Change to data output directory call chdir ( trim ( adjustl ( num % Xdir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) istate filename = 'Xchimp.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) count write ( 1 ) Xchimp_istate ( 1 : count ) write ( 1 ) istate_el ( 1 : count ) close ( 1 ) !Change back to working directory call chdir ( num % cwd ) end do sync all end subroutine calculate_echimp_interaction_ibzk subroutine calculate_ph_rta_rates ( rta_rates_3ph , rta_rates_phe , num , crys , ph , el ) !! Subroutine for parallel reading of the 3-ph and ph-e transition probabilities !! from disk and calculating the relaxation time approximation (RTA) !! scattering rates for the 3-ph and ph-e channels. real ( r64 ), allocatable , intent ( out ) :: rta_rates_3ph (:,:) real ( r64 ), allocatable , intent ( out ) :: rta_rates_phe (:,:) type ( numerics ), intent ( in ) :: num type ( crystal ), intent ( in ) :: crys type ( phonon ), intent ( in ) :: ph type ( electron ), intent ( in ), optional :: el !Local variables integer ( i64 ) :: nstates_irred , istate , nprocs_3ph_plus , nprocs_3ph_minus , & nprocs_phe , iproc , chunk , s , iq , num_active_images , start , end real ( r64 ), allocatable :: W (:), Y (:) character ( len = 1024 ) :: filepath_Wm , filepath_Wp , filepath_Y , tag !Set output directory of transition probilities write ( tag , \"(E9.3)\" ) crys % T !Total number of IBZ blocks states nstates_irred = ph % nwv_irred * ph % numbands !Divide phonon states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) !Allocate and initialize scattering rates allocate ( rta_rates_3ph ( ph % nwv_irred , ph % numbands ), rta_rates_phe ( ph % nwv_irred , ph % numbands )) rta_rates_3ph (:, :) = 0.0_r64 rta_rates_phe (:, :) = 0.0_r64 !Run over first phonon IBZ states do istate = start , end !Demux state index into branch (s) and wave vector (iq) indices call demux_state ( istate , ph % numbands , s , iq ) !Set W+ filename write ( tag , '(I9)' ) istate filepath_Wp = trim ( adjustl ( num % Wdir )) // '/Wp.istate' // trim ( adjustl ( tag )) !Read W+ from file if ( allocated ( W )) deallocate ( W ) call read_transition_probs_e ( trim ( adjustl ( filepath_Wp )), nprocs_3ph_plus , W ) do iproc = 1 , nprocs_3ph_plus rta_rates_3ph ( iq , s ) = rta_rates_3ph ( iq , s ) + W ( iproc ) end do !Set W- filename filepath_Wm = trim ( adjustl ( num % Wdir )) // '/Wm.istate' // trim ( adjustl ( tag )) !Read W- from file if ( allocated ( W )) deallocate ( W ) call read_transition_probs_e ( trim ( adjustl ( filepath_Wm )), nprocs_3ph_minus , W ) do iproc = 1 , nprocs_3ph_minus rta_rates_3ph ( iq , s ) = rta_rates_3ph ( iq , s ) + 0.5_r64 * W ( iproc ) end do if ( present ( el )) then !Set Y filename filepath_Y = trim ( adjustl ( num % Ydir )) // '/Y.istate' // trim ( adjustl ( tag )) !Read Y from file if ( allocated ( Y )) deallocate ( Y ) call read_transition_probs_e ( trim ( adjustl ( filepath_Y )), nprocs_phe , Y ) do iproc = 1 , nprocs_phe rta_rates_phe ( iq , s ) = rta_rates_phe ( iq , s ) + el % spindeg * Y ( iproc ) end do end if end do !Reduce partial sums sync all call co_sum ( rta_rates_3ph ) sync all if ( present ( el )) then sync all call co_sum ( rta_rates_phe ) sync all end if end subroutine calculate_ph_rta_rates subroutine calculate_4ph_rta_rates ( rta_rates , num , crys , ph ) !! Subroutine for interporlating 4-ph scattering rates from an !! external coarser mesh calculation. real ( r64 ), allocatable , intent ( out ) :: rta_rates (:,:) type ( numerics ), intent ( in ) :: num type ( crystal ), intent ( in ) :: crys type ( phonon ), intent ( in ) :: ph !Local variables integer ( i64 ) :: chunk , s , iq , coarse_numq_irred , coarse_numq_full , & num_active_images , start , end , fineq_indvec ( 3 ), mesh_ref_array ( 3 ), & coarse_qmesh ( 3 ), fbz2ibz real ( r64 ) :: ignore real ( r64 ), allocatable :: coarse_rta_rates_ibz (:, :), coarse_rta_rates_fbz (:, :) character ( len = 1024 ) :: temp_tag , filename allocate ( rta_rates ( ph % nwv_irred , ph % numbands )) rta_rates = 0.0_r64 if ( num % fourph ) then !Set some internal mesh related variables mesh_ref_array = num % fourph_mesh_ref if ( crys % twod ) mesh_ref_array ( 3 ) = 1 coarse_qmesh = ph % wvmesh / num % fourph_mesh_ref if ( crys % twod ) coarse_qmesh ( 3 ) = 1 write ( temp_tag , \"(E9.3)\" ) crys % T filename = \"FourPhonon_BTE.w_4ph_T\" // trim ( adjustl ( temp_tag )) !Read number of irreducible q-points if ( this_image () == 1 . and . num % fourph ) then open ( 1 , file = filename , status = \"old\" ) read ( 1 , * ) coarse_numq_irred end if sync all call co_broadcast ( coarse_numq_irred , 1 ) sync all allocate ( coarse_rta_rates_ibz ( coarse_numq_irred , ph % numbands )) !Read coarse mesh, IBZ 4-ph scattering rates if ( this_image () == 1 . and . num % fourph ) then open ( 1 , file = filename , status = \"old\" ) do s = 1 , ph % numbands do iq = 1 , coarse_numq_irred read ( 1 , * ) ignore , coarse_rta_rates_ibz ( iq , s ) end do end do close ( 1 ) end if sync all call co_broadcast ( coarse_rta_rates_ibz , 1 ) sync all !Compute FBZ <-> IBZ mapping from BTE.qpoints_full file if ( this_image () == 1 . and . num % fourph ) then open ( 1 , file = \"FourPhonon_BTE.qpoints_full\" , status = \"old\" ) read ( 1 , * ) coarse_numq_full if ( coarse_numq_full /= product ( coarse_qmesh )) then call exit_with_message ( 'Wrong q-mesh in external 4-ph calculation. Exiting.' ) end if end if sync all call co_broadcast ( coarse_numq_full , 1 ) sync all allocate ( coarse_rta_rates_fbz ( coarse_numq_full , ph % numbands )) if ( this_image () == 1 . and . num % fourph ) then do iq = 1 , coarse_numq_full read ( 1 , * ) ignore , fbz2ibz , ignore , ignore , ignore coarse_rta_rates_fbz ( iq , :) = coarse_rta_rates_ibz ( fbz2ibz , :) end do close ( 1 ) end if sync all call co_broadcast ( coarse_rta_rates_fbz , 1 ) sync all !Divide phonon states among images call distribute_points ( ph % nwv_irred , chunk , start , end , num_active_images ) !If needed, parallely interpolate over fine q-mesh if ( num % fourph_mesh_ref > 1 ) then do iq = start , end !Calculate the fine mesh wave vector, 0-based index vector call demux_vector ( ph % indexlist_irred ( iq ), fineq_indvec , ph % wvmesh , 0_i64 ) !Interpolate 4-ph scattering rates on this wave vector do s = 1 , ph % numbands call interpolate ( coarse_qmesh , mesh_ref_array , coarse_rta_rates_fbz (:, s ), & fineq_indvec , rta_rates ( iq , s )) end do end do sync all call co_sum ( rta_rates ) sync all else rta_rates = coarse_rta_rates_ibz end if end if end subroutine calculate_4ph_rta_rates subroutine calculate_el_rta_rates ( rta_rates_eph , rta_rates_echimp , num , crys , el ) !! Subroutine for parallel reading of the e-ph transition probabilities !! from disk and calculating the relaxation time approximation (RTA) !! scattering rates for the e-ph channel. real ( r64 ), allocatable , intent ( out ) :: rta_rates_eph (:,:), rta_rates_echimp (:,:) type ( numerics ), intent ( in ) :: num type ( crystal ), intent ( in ) :: crys type ( electron ), intent ( in ) :: el !Local variables integer ( i64 ) :: nstates_irred , istate , nprocs_eph , & iproc , chunk , m , ik , num_active_images , start , end real ( r64 ), allocatable :: X (:) character ( len = 1024 ) :: filepath_Xp , filepath_Xm , tag !Set output directory of transition probilities write ( tag , \"(E9.3)\" ) crys % T !Total number of IBZ blocks states nstates_irred = el % nwv_irred * el % numbands !Divide phonon states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) !Allocate and initialize scattering rates allocate ( rta_rates_eph ( el % nwv_irred , el % numbands )) rta_rates_eph (:, :) = 0.0_r64 allocate ( rta_rates_echimp ( el % nwv_irred , el % numbands )) rta_rates_echimp (:, :) = 0.0_r64 do istate = start , end !over IBZ blocks states !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , el % numbands , m , ik ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( el % ens_irred ( ik , m ) - el % enref ) > el % fsthick ) cycle !Set X+ filename write ( tag , '(I9)' ) istate filepath_Xp = trim ( adjustl ( num % Xdir )) // '/Xplus.istate' // trim ( adjustl ( tag )) !Read X+ from file if ( allocated ( X )) deallocate ( X ) call read_transition_probs_e ( trim ( adjustl ( filepath_Xp )), nprocs_eph , X ) do iproc = 1 , nprocs_eph rta_rates_eph ( ik , m ) = rta_rates_eph ( ik , m ) + X ( iproc ) end do !Set X- filename write ( tag , '(I9)' ) istate filepath_Xm = trim ( adjustl ( num % Xdir )) // '/Xminus.istate' // trim ( adjustl ( tag )) !Read X- from file if ( allocated ( X )) deallocate ( X ) call read_transition_probs_e ( trim ( adjustl ( filepath_Xm )), nprocs_eph , X ) do iproc = 1 , nprocs_eph rta_rates_eph ( ik , m ) = rta_rates_eph ( ik , m ) + X ( iproc ) end do if ( num % elchimp ) then !Set Xchimp filename write ( tag , '(I9)' ) istate filepath_Xm = trim ( adjustl ( num % Xdir )) // '/Xchimp.istate' // trim ( adjustl ( tag )) !Read Xchimp from file if ( allocated ( X )) deallocate ( X ) call read_transition_probs_e ( trim ( adjustl ( filepath_Xm )), nprocs_eph , X ) do iproc = 1 , nprocs_eph rta_rates_echimp ( ik , m ) = rta_rates_echimp ( ik , m ) + X ( iproc ) end do end if end do !Reduce partial sums sync all call co_sum ( rta_rates_eph ) sync all if ( num % elchimp ) then sync all call co_sum ( rta_rates_echimp ) sync all end if end subroutine calculate_el_rta_rates subroutine read_transition_probs_e ( filepath , N , TP , istate1 , istate2 ) !! Subroutine to read transition probabilities from disk for interaction processes. character ( len = * ), intent ( in ) :: filepath integer ( i64 ), intent ( out ) :: N real ( r64 ), allocatable , intent ( out ) :: TP (:) integer ( i64 ), allocatable , intent ( out ), optional :: istate1 (:), istate2 (:) !Read data open ( 1 , file = trim ( adjustl ( filepath )), status = 'old' , access = 'stream' ) read ( 1 ) N allocate ( TP ( N )) if ( N > 0 ) read ( 1 ) TP if ( present ( istate1 )) then allocate ( istate1 ( N )) if ( N > 0 ) then read ( 1 ) istate1 end if if ( present ( istate2 )) then allocate ( istate2 ( N )) if ( N > 0 ) then read ( 1 ) istate2 end if end if end if close ( 1 ) end subroutine read_transition_probs_e subroutine calculate_bound_scatt_rates ( prefix , finite_crys , length , vels_fbz , & indexlist_irred , scatt_rates ) !! Subroutine to calculate the phonon/electron-boundary scattering rates. !! !! prefix Type of particle !! finite_crys Is the crystal finite? !! length Characteristic boundary scattering length scale in mm !! vels Velocities on the FBZ !! indexlist_irred List of muxed indices of the IBZ wedge. !! scatt_rates Boundary scattering rates on the IBZ character ( len = 2 ), intent ( in ) :: prefix logical , intent ( in ) :: finite_crys real ( r64 ), intent ( in ) :: length real ( r64 ), intent ( in ) :: vels_fbz (:,:,:) integer ( i64 ), intent ( in ) :: indexlist_irred (:) real ( r64 ), allocatable , intent ( out ) :: scatt_rates (:,:) !Local variables integer ( i64 ) :: ik , ib , nk_irred , nb !Number of IBZ wave vectors and bands nk_irred = size ( indexlist_irred (:)) nb = size ( vels_fbz ( 1 ,:, 1 )) !Allocate boundary scattering rates and initialize to infinite crystal values allocate ( scatt_rates ( nk_irred , nb )) scatt_rates = 0.0_r64 !Check finiteness of crystal if ( finite_crys ) then do ik = 1 , nk_irred do ib = 1 , nb scatt_rates ( ik , ib ) = twonorm ( vels_fbz ( indexlist_irred ( ik ), ib , :))& / length * 1.e-6_r64 !THz end do end do end if !Write to file call write2file_rank2_real ( prefix // '.W_rta_' // prefix // 'bound' , scatt_rates ) end subroutine calculate_bound_scatt_rates subroutine calculate_thinfilm_scatt_rates ( prefix , finite_crys , height , normal , vels_fbz , & indexlist_irred , scatt_rates ) !! Subroutine to calculate the phonon/electron-thin-film scattering rates. !! !! prefix Type of particle !! finite_crys Is the crystal finite? !! height Height of thin-film in mm !! normal Normal direction to thin-film !! vels Velocities on the FBZ !! indexlist_irred List of muxed indices of the IBZ wedge. !! scatt_rates Thin-film scattering rates on the IBZ character ( len = 2 ), intent ( in ) :: prefix logical , intent ( in ) :: finite_crys real ( r64 ), intent ( in ) :: height character ( 1 ), intent ( in ) :: normal real ( r64 ), intent ( in ) :: vels_fbz (:,:,:) integer ( i64 ), intent ( in ) :: indexlist_irred (:) real ( r64 ), allocatable , intent ( out ) :: scatt_rates (:,:) !Local variables integer ( i64 ) :: ik , ib , nk_irred , nb , dir !Number of IBZ wave vectors and bands nk_irred = size ( indexlist_irred (:)) nb = size ( vels_fbz ( 1 ,:, 1 )) !Allocate boundary scattering rates and initialize to infinite crystal values allocate ( scatt_rates ( nk_irred , nb )) scatt_rates = 0.0_r64 if ( normal == 'x' ) then dir = 1_i64 else if ( normal == 'y' ) then dir = 2_i64 else if ( normal == 'z' ) then dir = 3_i64 else call exit_with_message ( \"Bad thin-film normal direction in calculate_thinfilm_scattrates. Exiting.\" ) end if !Check finiteness of crystal if ( finite_crys ) then do ik = 1 , nk_irred do ib = 1 , nb scatt_rates ( ik , ib ) = abs ( vels_fbz ( indexlist_irred ( ik ), ib , dir )) & / height * 1.e-6_r64 !THz end do end do end if scatt_rates = 2.0_r64 * scatt_rates !Write to file call write2file_rank2_real ( prefix // '.W_rta_' // prefix // 'thinfilm' , scatt_rates ) end subroutine calculate_thinfilm_scatt_rates !!$  subroutine calculate_defect_scatt_rates(prefix, def_frac, indexlist_ibz, ens_fbz, diagT)!, scatt_rates) !!$    !! Subroutine to calculate the phonon-defect scattering rate given !!$    !! the diagonal of the scattering T-matrix. !!$    !! !!$    !! prefix Particle type label !!$    !! def_frac Elemental fraction of defects !!$    !! ens IBZ energies !!$    !! diagT Diagonal of the IBZ T-matrix !!$    !! scatt_rates IBZ Scattering rates !!$ !!$    character(len = 2), intent(in) :: prefix !!$    real(r64), intent(in) :: def_frac !!$    real(r64), intent(in) :: ens_fbz(:, :) !!$    integer(i64), intent(in) :: indexlist_ibz(:) !!$    complex(r64), intent(in) :: diagT(:, :) !!$    !real(r64), allocatable, intent(out) :: scatt_rates(:, :) !!$ !!$    !Local variables !!$    integer(i64) :: nk_ibz, nbands, ik !!$    real(r64), allocatable :: scatt_rates(:, :) !!$ !!$    nk_ibz = size(diagT, 1) !!$    nbands = size(diagT, 2) !!$ !!$    print*, 'def_frac = ', def_frac !!$ !!$    allocate(scatt_rates(nk_ibz, nbands)) !!$ !!$    do ik = 1, nk_ibz !!$       scatt_rates(ik, :) = imag(diagT(ik, :))/ens_fbz(indexlist_ibz(ik), :) !!$    end do !!$ !!$    scatt_rates = -def_frac*scatt_rates/hbar_eVps !!$ !!$    !Deal with Gamma point acoustic phonons! and zero-velocity optic phonons !!$    scatt_rates(1, 1:3) = 0.0_r64 !!$ !!$    !Write to file !!$    call write2file_rank2_real(prefix // '.W_rta_'//prefix//'defect', scatt_rates) !!$  end subroutine calculate_defect_scatt_rates end module interactions","tags":"","loc":"sourcefile/interactions.f90.html"},{"title":"phonon.f90 – elphbolt","text":"Contents Modules phonon_module Source Code phonon.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. ! ! 20220322 : Added support for reading d3q's sparse files (XC) module phonon_module !! Module containing type and procedures related to the phononic properties. use params , only : r64 , i64 , bohr2nm , pi , twopi , Ryd2eV , oneI use particle_module , only : particle use misc , only : print_message , subtitle , expi , distribute_points , & write2file_rank2_real , exit_with_message use numerics_module , only : numerics use wannier_module , only : epw_wannier use crystal_module , only : crystal , calculate_wavevectors_full use symmetry_module , only : symmetry , find_irred_wedge , create_fbz2ibz_map use delta , only : form_tetrahedra_3d , fill_tetrahedra_3d , form_triangles , & fill_triangles implicit none private public phonon type , extends ( particle ) :: phonon !! Data and procedures related to phonons. character ( len = 2 ) :: prefix = 'ph' !! Prefix idenitfying particle type. integer ( i64 ) :: scell ( 3 ) !! q-mesh used in DFPT or, equivalently, supercell used in finite displencement !! method for calculating the 2nd order force constants. real ( r64 ), allocatable :: ifc2 (:,:,:,:,:,:,:) !! Second order force constants (ifc2) tensor. real ( r64 ), allocatable :: ifc3 (:,:,:,:) !! Third order force constants (ifc3) tensor. integer ( i64 ) :: numtriplets !! Number of triplets in the ifc3 file. real ( r64 ), allocatable :: R_j (:,:), R_k (:,:) !! Position of the 2nd and 3rd unitcell in supercell for an ifc3 triplet. integer ( i64 ), allocatable :: Index_i (:), Index_j (:), Index_k (:) !! Label of primitive cell atoms in the ifc3 triplet. real ( r64 ), allocatable :: tetra_squared_evals (:,:,:) !! Tetrahedra vertices filled with squared eigenvalues. !! This is needed only for the phonon Green's function calculation. !Data read from ifc2 file. These will be used in the phonon calculation. real ( r64 ) :: rws ( 124 , 0 : 3 ), cell_r ( 1 : 3 , 0 : 3 ), cell_g ( 1 : 3 , 0 : 3 ) real ( r64 ), allocatable :: mm (:,:), rr (:,:,:) contains procedure , public :: initialize , deallocate_phonon_quantities procedure , private :: calculate_phonons , read_ifc2 , read_ifc3 , & phonon_espresso end type phonon contains subroutine initialize ( self , crys , sym , num ) !! Initialize the phonon data type, calculate ground state phonon properties, !! and read 3rd order force constants data. class ( phonon ), intent ( out ) :: self type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( numerics ), intent ( in ) :: num call subtitle ( \"Setting up phonons...\" ) !Set phonon branches self % numbands = crys % numatoms * 3 !Set wave vector mesh self % wvmesh = num % qmesh !Set number of phonon wave vectors self % nwv = product ( self % wvmesh (:)) !Read ifc2 and related quantities call read_ifc2 ( self , crys ) !Calculate harmonic properties call calculate_phonons ( self , crys , sym , num ) if (. not . num % onlyebte . and . num % runlevel /= 3 ) then !Read ifc3s and related quantities call read_ifc3 ( self , crys ) end if end subroutine initialize subroutine deallocate_phonon_quantities ( self ) !! Deallocate the electron eigenvectors class ( phonon ), intent ( inout ) :: self if ( allocated ( self % evecs )) deallocate ( self % evecs ) if ( allocated ( self % ifc2 )) deallocate ( self % ifc2 ) if ( allocated ( self % ifc3 )) deallocate ( self % ifc3 ) if ( allocated ( self % Index_i )) deallocate ( self % Index_i ) if ( allocated ( self % Index_j )) deallocate ( self % Index_j ) if ( allocated ( self % Index_k )) deallocate ( self % Index_k ) if ( allocated ( self % mm )) deallocate ( self % mm ) if ( allocated ( self % rr )) deallocate ( self % rr ) sync all end subroutine deallocate_phonon_quantities subroutine calculate_phonons ( self , crys , sym , num ) !! Calculate phonon quantities on the FBZ and IBZ meshes. class ( phonon ), intent ( inout ) :: self type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( numerics ), intent ( in ) :: num !Local variables integer ( i64 ) :: i , iq , ii , jj , kk , l , il , s , ib , im , chunk , & num_active_images integer ( i64 ), allocatable :: start [:], end [:] real ( r64 ), allocatable :: ens_chunk (:,:)[:], vels_chunk (:,:,:)[:], & symmetrizers_chunk (:,:,:)[:] complex ( r64 ), allocatable :: evecs_chunk (:,:,:)[:] !Switch for mesh utilites with or without energy restriction logical :: blocks character ( len = 1024 ) :: numcols blocks = . false . call print_message ( \"Calculating phonon FBZ quantities...\" ) !Allocate start and end coarrays allocate ( start [ * ], end [ * ]) !Divide wave vectors among images call distribute_points ( self % nwv , chunk , start , end , num_active_images ) !Allocate small work variable chunk for each image allocate ( ens_chunk ( chunk , self % numbands )[ * ]) allocate ( vels_chunk ( chunk , self % numbands , 3 )[ * ]) allocate ( evecs_chunk ( chunk , self % numbands , self % numbands )[ * ]) !Calculate FBZ mesh call calculate_wavevectors_full ( self % wvmesh , self % wavevecs , blocks ) !Print phonon FBZ mesh call write2file_rank2_real ( \"ph.wavevecs_fbz\" , self % wavevecs ) !Calculate FBZ phonon quantities call phonon_espresso ( self , crys , chunk , self % wavevecs ( start : end , :), & ens_chunk , evecs_chunk , vels_chunk ) !Gather the chunks from the images and broadcast to all allocate ( self % ens ( self % nwv , self % numbands )) allocate ( self % vels ( self % nwv , self % numbands , 3 )) allocate ( self % evecs ( self % nwv , self % numbands , self % numbands )) sync all if ( this_image () == 1 ) then do im = 1 , num_active_images self % ens ( start [ im ]: end [ im ], :) = ens_chunk (:,:)[ im ] self % vels ( start [ im ]: end [ im ], :, :) = vels_chunk (:,:,:)[ im ] self % evecs ( start [ im ]: end [ im ], :, :) = evecs_chunk (:,:,:)[ im ] end do end if sync all call co_broadcast ( self % ens , 1 ) call co_broadcast ( self % vels , 1 ) call co_broadcast ( self % evecs , 1 ) sync all deallocate ( ens_chunk , vels_chunk , evecs_chunk ) !Calculate IBZ mesh call print_message ( \"Calculating IBZ and IBZ -> FBZ mappings...\" ) call find_irred_wedge ( self % wvmesh , self % nwv_irred , self % wavevecs_irred , & self % indexlist_irred , self % nequiv , sym % nsymm_rot , sym % qrotations , & self % ibz2fbz_map , self % equiv_map , blocks ) !Print phonon IBZ mesh call write2file_rank2_real ( \"ph.wavevecs_ibz\" , self % wavevecs_irred ) !Create symmetrizers of wave vector dependent vectors ShengBTE style allocate ( symmetrizers_chunk ( 3 , 3 , chunk )[ * ]) symmetrizers_chunk = 0.0_r64 do iq = start , end kk = 0 do jj = 1 , sym % nsymm if ( self % equiv_map ( jj , iq ) == iq ) then symmetrizers_chunk (:, :, iq - start + 1 ) = & symmetrizers_chunk (:, :, iq - start + 1 ) + & sym % crotations_orig (:, :, jj ) kk = kk + 1 end if end do if ( kk > 1 ) then symmetrizers_chunk (:, :, iq - start + 1 ) = & symmetrizers_chunk (:, :, iq - start + 1 ) / kk end if end do !Gather from images and broadcast to all allocate ( self % symmetrizers ( 3 , 3 , self % nwv )) sync all if ( this_image () == 1 ) then do im = 1 , num_active_images self % symmetrizers (:, :, start [ im ]: end [ im ]) = symmetrizers_chunk (:,:,:)[ im ] end do end if sync all call co_broadcast ( self % symmetrizers , 1 ) sync all deallocate ( symmetrizers_chunk ) !Symmetrize phonon energies and velocities. do i = 1 , self % nwv_irred !an irreducible point ii = self % indexlist_irred ( i ) self % vels ( ii ,:,:) = transpose (& matmul ( self % symmetrizers (:,:, ii ), transpose ( self % vels ( ii ,:,:)))) do l = 1 , self % nequiv ( i ) !number of equivalent points of i il = self % ibz2fbz_map ( l , i , 2 ) ! (i, l) -> il s = self % ibz2fbz_map ( l , i , 1 ) ! mapping rotation !energy self % ens ( il ,:) = self % ens ( ii ,:) !velocity do ib = 1 , self % numbands !here use real space (Cartesian) rotations self % vels ( il , ib , :) = matmul ( sym % crotations (:, :, s ), self % vels ( ii , ib , :)) end do end do end do !Print out irreducible phonon energies and velocities if ( this_image () == 1 ) then write ( numcols , \"(I0)\" ) self % numbands open ( 1 , file = \"ph.ens_ibz\" , status = \"replace\" ) do iq = 1 , self % nwv_irred write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & self % ens ( self % indexlist_irred ( iq ), :) end do close ( 1 ) write ( numcols , \"(I0)\" ) 3 * self % numbands open ( 1 , file = \"ph.vels_ibz\" , status = \"replace\" ) do iq = 1 , self % nwv_irred write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) & self % vels ( self % indexlist_irred ( iq ), :, :) end do close ( 1 ) end if !Calculate phonon tetrahedra if ( num % tetrahedra ) then call print_message ( \"Calculating phonon mesh tetrahedra...\" ) call form_tetrahedra_3d ( self % nwv , self % wvmesh , self % tetra , self % tetracount , & self % tetramap , . false .) call fill_tetrahedra_3d ( self % tetra , self % ens , self % tetra_evals ) if ( num % phdef_Tmat ) then call fill_tetrahedra_3d ( self % tetra , self % ens ** 2 , self % tetra_squared_evals ) end if else call print_message ( \"Calculating phonon mesh triangles...\" ) call form_triangles ( self % nwv , self % wvmesh , self % triang , self % triangcount , & self % triangmap , . false .) call fill_triangles ( self % triang , self % ens , self % triang_evals ) end if end subroutine calculate_phonons subroutine read_ifc2 ( self , crys ) !! Read the 2nd order force constants from the Quantum Espresso format. !! This is adapted from ShengBTE. class ( phonon ), intent ( inout ) :: self type ( crystal ), intent ( in ) :: crys !Local variables integer ( i64 ) :: qscell ( 3 ), tipo ( crys % numatoms ), t1 , t2 , t3 , i , j , & iat , jat , ibrav , ipol , jpol , m1 , m2 , m3 , ntype , nat , nfc2 real ( r64 ) :: r ( crys % numatoms , 3 ), wscell ( 3 , 0 : 3 ), celldm ( 6 ), at ( 3 , 3 ), & mass ( crys % numelements ), zeff ( crys % numatoms , 3 , 3 ), eps ( 3 , 3 ), & dnrm2 character ( len = 1 ) :: polar_key character ( len = 6 ) :: label ( crys % numelements ) real ( r64 ), parameter :: massfactor = 1.8218779_r64 * 6.022e-4_r64 allocate ( self % mm ( crys % numatoms , crys % numatoms )) allocate ( self % rr ( crys % numatoms , crys % numatoms , 3 )) open ( 1 , file = \"espresso.ifc2\" , status = \"old\" ) !Read some stuff that will not be used in the code. read ( 1 , * ) ntype , nat , ibrav , celldm ( 1 : 6 ) if ( ibrav == 0 ) then read ( 1 , * ) (( at ( i , j ), i = 1 , 3 ), j = 1 , 3 ) end if do i = 1 , ntype read ( 1 , * ) j , label ( i ), mass ( i ) end do mass = crys % masses / massfactor do i = 1 , nat read ( 1 , * ) j , tipo ( i ), r ( i , 1 : 3 ) end do r = transpose ( matmul ( crys % lattvecs , crys % basis )) / bohr2nm read ( 1 , * ) polar_key if ( polar_key == \"T\" ) then do i = 1 , 3 read ( 1 , * ) eps ( i , 1 : 3 ) end do do i = 1 , nat read ( 1 , * ) do j = 1 , 3 read ( 1 , * ) zeff ( i , j , 1 : 3 ) end do end do end if read ( 1 , * ) qscell ( 1 : 3 ) self % scell = qscell !Read the force constants. allocate ( self % ifc2 ( 3 , 3 , nat , nat , self % scell ( 1 ), self % scell ( 2 ), self % scell ( 3 ))) nfc2 = 3 * 3 * nat * nat do i = 1 , nfc2 read ( 1 , * ) ipol , jpol , iat , jat do j = 1 , self % scell ( 1 ) * self % scell ( 2 ) * self % scell ( 3 ) read ( 1 , * ) t1 , t2 , t3 , & self % ifc2 ( ipol , jpol , iat , jat , t1 , t2 , t3 ) end do end do close ( 1 ) !Enforce the conservation of momentum in the simplest way possible. do i = 1 , 3 do j = 1 , 3 do iat = 1 , nat self % ifc2 ( i , j , iat , iat , 1 , 1 , 1 ) = self % ifc2 ( i , j , iat , iat , 1 , 1 , 1 ) - & sum ( self % ifc2 ( i , j , iat , :, :, :, :)) end do end do end do self % cell_r (:, 1 : 3 ) = transpose ( crys % lattvecs ) / bohr2nm do i = 1 , 3 self % cell_r ( i , 0 ) = dnrm2 ( 3 , self % cell_r ( i , 1 : 3 ), 1 ) end do self % cell_g (:, 1 : 3 ) = transpose ( crys % reclattvecs ) * bohr2nm do i = 1 , 3 self % cell_g ( i , 0 ) = dnrm2 ( 3 , self % cell_g ( i , 1 : 3 ), 1 ) end do wscell ( 1 , 1 : 3 ) = self % cell_r ( 1 , 1 : 3 ) * self % scell ( 1 ) wscell ( 2 , 1 : 3 ) = self % cell_r ( 2 , 1 : 3 ) * self % scell ( 2 ) wscell ( 3 , 1 : 3 ) = self % cell_r ( 3 , 1 : 3 ) * self % scell ( 3 ) j = 1 do m1 = - 2 , 2 do m2 = - 2 , 2 do m3 = - 2 , 2 if ( all (( / m1 , m2 , m3 / ). eq . 0 )) then cycle end if do i = 1 , 3 self % rws ( j , i ) = wscell ( 1 , i ) * m1 + wscell ( 2 , i ) * m2 + wscell ( 3 , i ) * m3 end do self % rws ( j , 0 ) = 0.5 * dot_product ( self % rws ( j , 1 : 3 ), self % rws ( j , 1 : 3 )) j = j + 1 end do end do end do do i = 1 , nat self % mm ( i , i ) = mass ( tipo ( i )) self % rr ( i , i , :) = 0 do j = i + 1 , nat self % mm ( i , j ) = sqrt ( mass ( tipo ( i )) * mass ( tipo ( j ))) self % rr ( i , j , 1 : 3 ) = r ( i , 1 : 3 ) - r ( j , 1 : 3 ) self % mm ( j , i ) = self % mm ( i , j ) self % rr ( j , i , 1 : 3 ) = - self % rr ( i , j , 1 : 3 ) end do end do end subroutine read_ifc2 subroutine read_ifc3 ( self , crys ) !! Read the 3rd order force constants in the thirdorder.py format. !! This subroutine is adapted from ShengBTE. class ( phonon ), intent ( inout ) :: self type ( crystal ), intent ( in ) :: crys !Local variables real ( r64 ) :: tmp ( 3 , 3 ), r ( crys % numatoms , 3 ), celldm ( 6 ), at ( 3 , 3 ), & mass ( crys % numelements ), zeff ( crys % numatoms , 3 , 3 ), eps ( 3 , 3 ), fc_ real ( r64 ), allocatable :: fc (:,:,:,:) integer ( i64 ) :: ii , jj , ll , mm , nn , ltem , mtem , ntem , info , P ( 3 ), & na1 , na2 , na3 , j1 , j2 , j3 , na1_ , na2_ , na3_ , j1_ , j2_ , j3_ , & triplet_counter , nR , nR_ , qscell ( 3 ), tipo ( crys % numatoms ), i , j , & ibrav , ntype , nat , jn1 , jn2 , jn3 , ind integer ( i64 ), allocatable :: nind (:), R2tmp (:,:), R3tmp (:,:), & R2 (:,:), R3 (:,:), triplet_map (:,:,:,:) character ( len = 1 ) :: polar_key character ( len = 6 ) :: label ( crys % numelements ), sparse_header logical :: sheng_file_exists , d3q_file_exists , & d3q_sparse_file_exists , save_nR !External procedures external :: dgesv !Check what force constants files have been provided sheng_file_exists = . False . d3q_file_exists = . False . d3q_sparse_file_exists = . False . inquire ( file = 'FORCE_CONSTANTS_3RD' , exist = sheng_file_exists ) inquire ( file = 'mat3R' , exist = d3q_file_exists ) inquire ( file = 'mat3R.sparse' , exist = d3q_sparse_file_exists ) if ( sheng_file_exists . and . (. not . d3q_file_exists ) . and . (. not . d3q_sparse_file_exists )) then call print_message ( 'Reading ShengBTE format third order force constants...' ) else if ( d3q_file_exists . and . (. not . sheng_file_exists ) . and . (. not . d3q_sparse_file_exists )) then call print_message ( 'Reading d3q format third order force constants...' ) else if ( d3q_sparse_file_exists . and . (. not . sheng_file_exists ) . and . (. not . d3q_file_exists )) then call print_message ( 'Reading d3q_sparse format third order force constants...' ) else if ( sheng_file_exists . and . d3q_file_exists . and . (. not . d3q_sparse_file_exists )) then call print_message (& 'Both ShengBTE and d3q format third order force constants provided. Defaulting to ShengBTE format.' ) d3q_file_exists = . False . else if ( sheng_file_exists . and . (. not . d3q_file_exists ) . and . d3q_sparse_file_exists ) then call print_message (& 'Both ShengBTE and d3q_sparse format third order force constants provided. Defaulting to ShengBTE format.' ) d3q_sparse_file_exists = . False . else if ((. not . sheng_file_exists ) . and . d3q_file_exists . and . d3q_sparse_file_exists ) then call print_message (& 'Both d3q and d3q_sparse format third order force constants provided. Defaulting to d3q_sparse format.' ) d3q_file_exists = . False . else if ( sheng_file_exists . and . d3q_file_exists . and . d3q_sparse_file_exists ) then call print_message (& 'All ShengBTE, d3q and d3q_sparse format third order force constants provided. Defaulting to ShengBTE format.' ) d3q_file_exists = . False . d3q_sparse_file_exists = . False . else call exit_with_message ( 'Third order force constant file not provided. Exiting.' ) end if if ( sheng_file_exists ) then !The file is in a simple sparse format, described in detail in !the user documentation. See Doc/ShengBTE.pdf. open ( 1 , file = 'FORCE_CONSTANTS_3RD' , status = \"old\" ) read ( 1 , * ) self % numtriplets allocate ( self % Index_i ( self % numtriplets ), self % Index_j ( self % numtriplets ), & self % Index_k ( self % numtriplets )) allocate ( self % ifc3 ( 3 , 3 , 3 , self % numtriplets ), self % R_j ( 3 , self % numtriplets ), & self % R_k ( 3 , self % numtriplets )) do ii = 1 , self % numtriplets read ( 1 , * ) jj read ( 1 , * ) self % R_j (:, ii ) !Ang read ( 1 , * ) self % R_k (:, ii ) !Ang read ( 1 , * ) self % Index_i ( ii ), self % Index_j ( ii ), self % Index_k ( ii ) do ll = 1 , 3 do mm = 1 , 3 do nn = 1 , 3 read ( 1 , * ) ltem , mtem , ntem , self % ifc3 ( ll , mm , nn , ii ) end do end do end do end do close ( 1 ) !IFC3 units are eV/Ang&#94;3 else if ( d3q_file_exists ) then !See SUBROUTINE read_fc3_grid of fc3_interp.f90 of the d3q code !for more information about the format. open ( 1 , file = 'mat3R' , status = \"old\" ) !Read some stuff that will not be used in the code. read ( 1 , * ) ntype , nat , ibrav , celldm ( 1 : 6 ) if ( ibrav == 0 ) then read ( 1 , * ) (( at ( i , j ), i = 1 , 3 ), j = 1 , 3 ) end if do i = 1 , ntype read ( 1 , * ) j , label ( i ), mass ( i ) end do do i = 1 , nat read ( 1 , * ) j , tipo ( i ), r ( i , 1 : 3 ) end do read ( 1 , * ) polar_key if ( polar_key == \"T\" ) then do i = 1 , 3 read ( 1 , * ) eps ( i , 1 : 3 ) end do do i = 1 , nat read ( 1 , * ) do j = 1 , 3 read ( 1 , * ) zeff ( i , j , 1 : 3 ) end do end do end if read ( 1 , * ) qscell ( 1 : 3 ) save_nR = . true . do na1 = 1 , crys % numatoms do na2 = 1 , crys % numatoms do na3 = 1 , crys % numatoms do j1 = 1 , 3 jn1 = j1 + ( na1 - 1 ) * 3 do j2 = 1 , 3 jn2 = j2 + ( na2 - 1 ) * 3 do j3 = 1 , 3 jn3 = j3 + ( na3 - 1 ) * 3 !Read tensor elements location and triplet atoms. read ( 1 , * ) j1_ , j2_ , j3_ , na1_ , na2_ , na3_ if ( any (( / na1 , na2 , na3 , j1 , j2 , j3 / ) /= & ( / na1_ , na2_ , na3_ , j1_ , j2_ , j3_ / ))) then call exit_with_message (& \"Wrong triplet indices and/or tensor element location in mat3R file. Exiting.\" ) end if !Read number of unit cells in file. read ( 1 , * ) nR_ !Save this number only the first time it is read. !Also, allocate the various quantities. if ( save_nR ) then nR = nR_ allocate ( R2 ( 3 , nR ), R3 ( 3 , nR ), & fc ( self % numbands , self % numbands , self % numbands , nR )) save_nR = . false . end if if ( nR_ /= nR ) call exit_with_message (& \"Wrong number of unit cells in mat3R file. Exiting.\" ) do ii = 1 , nR !R2 and R3 are the same for every nR chunk. read ( 1 , * ) R2 (:, ii ), R3 (:, ii ), fc ( jn1 , jn2 , jn3 , ii ) !At this point the fc units are Ry/Bohr&#94;3 end do end do end do end do end do end do end do !Number of triplets self % numtriplets = nR * crys % numatoms ** 3 !Allocate quantities allocate ( self % Index_i ( self % numtriplets ), self % Index_j ( self % numtriplets ), self % Index_k ( self % numtriplets )) allocate ( self % ifc3 ( 3 , 3 , 3 , self % numtriplets ), self % R_j ( 3 , self % numtriplets ), self % R_k ( 3 , self % numtriplets )) !Convert to the standard format. triplet_counter = 0 do ii = 1 , nR do na1 = 1 , crys % numatoms do na2 = 1 , crys % numatoms do na3 = 1 , crys % numatoms triplet_counter = triplet_counter + 1 !Triplet self % Index_i ( triplet_counter ) = na1 self % Index_j ( triplet_counter ) = na2 self % Index_k ( triplet_counter ) = na3 !Positions of the 2nd and 3rd unitcell in the triplet !converted to Cartesian coordinates (Ang). self % R_j (:, triplet_counter ) = & matmul ( crys % lattvecs , R2 (:, ii ) * 1 0.0_r64 ) !Ang self % R_k (:, triplet_counter ) = & matmul ( crys % lattvecs , R3 (:, ii ) * 1 0.0_r64 ) !Ang do j1 = 1 , 3 jn1 = j1 + ( na1 - 1 ) * 3 do j2 = 1 , 3 jn2 = j2 + ( na2 - 1 ) * 3 do j3 = 1 , 3 jn3 = j3 + ( na3 - 1 ) * 3 self % ifc3 ( j1 , j2 , j3 , triplet_counter ) = fc ( jn1 , jn2 , jn3 , ii ) end do end do end do end do end do end do end do self % ifc3 = self % ifc3 * Ryd2eV / ( bohr2nm * 1 0.0_r64 ) ** 3 !eV/Ang&#94;3 else if ( d3q_sparse_file_exists ) then !See SUBROUTINE read_fc3_sparse of fc3_interp.f90 of the d3q code !for more information about the format. open ( 1 , file = 'mat3R.sparse' , status = \"old\" ) !Check file really in sparse mode read ( 1 , * ) sparse_header if ( sparse_header /= \"sparse\" ) then call exit_with_message ( 'Not really a d3q sparse file. Exiting.' ) end if !Read some stuff that will not be used in the code. read ( 1 , * ) ntype , nat , ibrav , celldm ( 1 : 6 ) if ( ibrav == 0 ) then read ( 1 , * ) (( at ( i , j ), i = 1 , 3 ), j = 1 , 3 ) end if do i = 1 , ntype read ( 1 , * ) j , label ( i ), mass ( i ) end do do i = 1 , nat read ( 1 , * ) j , tipo ( i ), r ( i , 1 : 3 ) end do read ( 1 , * ) polar_key if ( polar_key == \"T\" ) then do i = 1 , 3 read ( 1 , * ) eps ( i , 1 : 3 ) end do do i = 1 , nat read ( 1 , * ) do j = 1 , 3 read ( 1 , * ) zeff ( i , j , 1 : 3 ) end do end do end if read ( 1 , * ) qscell ( 1 : 3 ) !Read number of unit cells in file. read ( 1 , * ) nR !Also, allocate the various quantities. allocate ( nind ( nR ), R2tmp ( 3 , nR ), R3tmp ( 3 , nR )) allocate ( triplet_map ( crys % numatoms , crys % numatoms , crys % numatoms , nR )) do ii = 1 , nR ! Read how many (atom indices + components) at that position, and atom coordinates read ( 1 , * ) nind ( ii ), R2tmp (:, ii ), R3tmp (:, ii ) end do ! Will need to make two passes on the rest of file !  1st pass will give number of triplets !  2nd pass will do the reading proper !Number of triplets triplet_map = 0 self % numtriplets = 0 do ii = 1 , nR do ind = 1 , nind ( ii ) read ( 1 , * ) jn1 , jn2 , jn3 , fc_ ! Unwrap the indices na1 = ( jn1 - 1 ) / 3 + 1 na2 = ( jn2 - 1 ) / 3 + 1 na3 = ( jn3 - 1 ) / 3 + 1 ! Compute atom_indices_visited index if ( triplet_map ( na1 , na2 , na3 , ii ) == 0 ) then self % numtriplets = self % numtriplets + 1 triplet_map ( na1 , na2 , na3 , ii ) = self % numtriplets end if end do read ( 1 , * ) end do !Allocate quantities allocate ( self % Index_i ( self % numtriplets ), self % Index_j ( self % numtriplets ), self % Index_k ( self % numtriplets )) allocate ( self % ifc3 ( 3 , 3 , 3 , self % numtriplets ), self % R_j ( 3 , self % numtriplets ), self % R_k ( 3 , self % numtriplets )) allocate ( R2 ( 3 , self % numtriplets ), R3 ( 3 , self % numtriplets )) ! Read the FC3s proper rewind ( 1 ) read ( 1 , * ) sparse_header !Read some stuff that will not be used in the code. read ( 1 , * ) ntype , nat , ibrav , celldm ( 1 : 6 ) if ( ibrav == 0 ) then read ( 1 , * ) (( at ( i , j ), i = 1 , 3 ), j = 1 , 3 ) end if do i = 1 , ntype read ( 1 , * ) j , label ( i ), mass ( i ) end do do i = 1 , nat read ( 1 , * ) j , tipo ( i ), r ( i , 1 : 3 ) end do read ( 1 , * ) polar_key if ( polar_key == \"T\" ) then do i = 1 , 3 read ( 1 , * ) eps ( i , 1 : 3 ) end do do i = 1 , nat read ( 1 , * ) do j = 1 , 3 read ( 1 , * ) zeff ( i , j , 1 : 3 ) end do end do end if read ( 1 , * ) qscell ( 1 : 3 ) !Read number of unit cells in file. read ( 1 , * ) nR do ii = 1 , nR ! Read how many (atom indices + components) at that position, and atom coordinates read ( 1 , * ) nind ( ii ), tmp (:, 2 ), tmp (:, 3 ) end do self % ifc3 = 0._r64 do ii = 1 , nR do ind = 1 , nind ( ii ) read ( 1 , * ) jn1 , jn2 , jn3 , fc_ ! Unwrap the indices na1 = ( jn1 - 1 ) / 3 + 1 na2 = ( jn2 - 1 ) / 3 + 1 na3 = ( jn3 - 1 ) / 3 + 1 j1 = mod ( jn1 - 1 , 3 ) + 1 j2 = mod ( jn2 - 1 , 3 ) + 1 j3 = mod ( jn3 - 1 , 3 ) + 1 !Triplet triplet_counter = triplet_map ( na1 , na2 , na3 , ii ) self % Index_i ( triplet_counter ) = na1 self % Index_j ( triplet_counter ) = na2 self % Index_k ( triplet_counter ) = na3 self % ifc3 ( j1 , j2 , j3 , triplet_counter ) = fc_ R2 (:, triplet_counter ) = R2tmp (:, ii ) R3 (:, triplet_counter ) = R3tmp (:, ii ) end do read ( 1 , * ) end do ! Finish converting to the standard format. do ii = 1 , self % numtriplets !Positions of the 2nd and 3rd unitcell in the triplet !converted to Cartesian coordinates (Ang). self % R_j (:, ii ) = & matmul ( crys % lattvecs , R2 (:, ii ) * 1 0.0_r64 ) !Ang self % R_k (:, ii ) = & matmul ( crys % lattvecs , R3 (:, ii ) * 1 0.0_r64 ) !Ang end do self % ifc3 = self % ifc3 * Ryd2eV / ( bohr2nm * 1 0.0_r64 ) ** 3 !eV/Ang&#94;3 end if !Each vector is rounded to the nearest lattice vector. tmp = crys % lattvecs call dgesv ( 3 , self % numtriplets , tmp , 3 , P , self % R_j , 3 , info ) self % R_j = matmul ( crys % lattvecs , anint ( self % R_j / 1 0.0_r64 )) !nm tmp = crys % lattvecs call dgesv ( 3 , self % numtriplets , tmp , 3 , P , self % R_k , 3 , info ) self % R_k = matmul ( crys % lattvecs , anint ( self % R_k / 1 0.0_r64 )) !nm if ( this_image () == 1 ) & write ( * , \"(A, I10)\" ) \" Number triplets read in = \" , self % numtriplets end subroutine read_ifc3 subroutine phonon_espresso ( self , crys , nk , kpoints , omegas , eigenvect , velocities ) !! Subroutine to calculate phonons from the 2nd order force constants. ! ! This is adapted from ShengBTE's subroutine of the same name. ! ShengBTE is distributed under GPL v3 or later. class ( phonon ), intent ( in ) :: self type ( crystal ), intent ( in ) :: crys integer ( i64 ), intent ( in ) :: nk real ( r64 ), intent ( in ) :: kpoints ( nk , 3 ) real ( r64 ), intent ( out ) :: omegas ( nk , self % numbands ) real ( r64 ), optional , intent ( out ) :: velocities ( nk , self % numbands , 3 ) complex ( r64 ), optional , intent ( out ) :: eigenvect ( nk , self % numbands , self % numbands ) ! QE's 2nd-order files are in Ryd units. real ( r64 ), parameter :: toTHz = 2067 0.687_r64 ,& massfactor = 1.8218779_r64 * 6.022e-4_r64 integer ( i64 ) :: ir , nreq , ntype , nat , nbranches integer ( i64 ) :: i , j , ipol , jpol , iat , jat , idim , jdim , t1 , t2 , t3 , m1 , m2 , m3 , ik integer ( i64 ) :: ndim , nwork , ncell_g ( 3 ) integer ( i64 ), allocatable :: tipo (:) real ( r64 ) :: weight , total_weight , exp_g , ck real ( r64 ) :: r_ws ( 3 ) real ( r64 ) :: alpha , geg , gmax , kt , gr , volume_r , dnrm2 real ( r64 ) :: zig ( 3 ), zjg ( 3 ), dgeg ( 3 ), t ( 0 : 3 ), g ( 0 : 3 ), g_old ( 0 : 3 ) real ( r64 ), allocatable :: omega2 (:), rwork (:) real ( r64 ), allocatable :: k (:,:), mass (:), eps (:,:) real ( r64 ), allocatable :: eival (:,:), vels (:,:,:), zeff (:,:,:) complex ( r64 ) :: auxi ( 3 ) complex ( r64 ), allocatable :: cauxiliar (:), eigenvectors (:,:), work (:) complex ( r64 ), allocatable :: dyn (:,:), dyn_s (:,:,:), dyn_g (:,:,:) complex ( r64 ), allocatable :: ddyn (:,:,:), ddyn_s (:,:,:,:), ddyn_g (:,:,:,:) !External procedures external :: zheev ! Quantum Espresso's 2nd-order format contains information about ! lattice vectors, atomic positions, Born effective charges and so ! forth in its header. The information is read but completely ! ignored. It is the user's responsibility to ensure that ! it is consistent with the CONTROL file. nwork = 1 ntype = crys % numelements nat = crys % numatoms ndim = 3 * nat nbranches = ndim allocate ( omega2 ( nbranches )) allocate ( work ( nwork )) allocate ( rwork ( max ( 1 , 9 * nat - 2 ))) allocate ( k ( nk , 3 )) allocate ( mass ( ntype )) allocate ( tipo ( nat )) allocate ( eps ( 3 , 3 )) allocate ( zeff ( nat , 3 , 3 )) allocate ( dyn ( ndim , ndim )) allocate ( dyn_s ( nk , ndim , ndim )) allocate ( dyn_g ( nk , ndim , ndim )) allocate ( eival ( ndim , nk )) allocate ( eigenvectors ( ndim , ndim )) allocate ( cauxiliar ( ndim )) if ( present ( velocities )) then allocate ( ddyn ( ndim , ndim , 3 )) allocate ( ddyn_s ( nk , ndim , ndim , 3 )) allocate ( ddyn_g ( nk , ndim , ndim , 3 )) allocate ( vels ( ndim , nk , 3 )) end if mass = crys % masses / massfactor tipo = crys % atomtypes eps = transpose ( crys % epsilon ) do i = 1 , nat zeff ( i , :, :) = transpose ( crys % born (:, :, i )) end do ! Make sure operations are performed in consistent units. do ik = 1 , nk k ( ik , :) = matmul ( crys % reclattvecs , kpoints ( ik , :)) end do k = k * bohr2nm volume_r = crys % volume / bohr2nm ** 3 gmax = 1 4.0_r64 alpha = ( twopi * bohr2nm / dnrm2 ( 3 , crys % lattvecs (:, 1 ), 1 )) ** 2 geg = gmax * 4.0_r64 * alpha ncell_g = int ( sqrt ( geg ) / self % cell_g (:, 0 )) + 1 dyn_s = 0.0_r64 if ( present ( velocities )) ddyn_s = 0.0_r64 do iat = 1 , nat do jat = 1 , nat total_weight = 0.0_r64 do m1 =- 2 * self % scell ( 1 ), 2 * self % scell ( 1 ) do m2 =- 2 * self % scell ( 2 ), 2 * self % scell ( 2 ) do m3 =- 2 * self % scell ( 3 ), 2 * self % scell ( 3 ) do i = 1 , 3 t ( i ) = m1 * self % cell_r ( 1 , i ) + m2 * self % cell_r ( 2 , i ) + m3 * self % cell_r ( 3 , i ) r_ws ( i ) = t ( i ) + self % rr ( iat , jat , i ) end do weight = 0._r64 nreq = 1 j = 0 Do ir = 1 , 124 ck = dot_product ( r_ws , self % rws ( ir , 1 : 3 )) - self % rws ( ir , 0 ) if ( ck . gt . 1e-6_r64 ) then j = 1 cycle end if if ( abs ( ck ). lt . 1e-6_r64 ) then nreq = nreq + 1 end if end do if ( j . eq . 0 ) then weight = 1._r64 / dble ( nreq ) end if if ( weight . gt . 0._r64 ) then t1 = mod ( m1 + 1 , self % scell ( 1 )) if ( t1 . le . 0 ) then t1 = t1 + self % scell ( 1 ) end if t2 = mod ( m2 + 1 , self % scell ( 2 )) if ( t2 . Le . 0 ) then t2 = t2 + self % scell ( 2 ) end if t3 = mod ( m3 + 1 , self % scell ( 3 )) if ( t3 . le . 0 ) then t3 = t3 + self % scell ( 3 ) end if do ik = 1 , nk kt = dot_product ( k ( ik , 1 : 3 ), t ( 1 : 3 )) do ipol = 1 , 3 idim = ( iat - 1 ) * 3 + ipol do jpol = 1 , 3 jdim = ( jat - 1 ) * 3 + jpol dyn_s ( ik , idim , jdim ) = dyn_s ( ik , idim , jdim ) + & self % ifc2 ( ipol , jpol , iat , jat , t1 , t2 , t3 ) * & expi ( - kt ) * weight if ( present ( velocities )) then ddyn_s ( ik , idim , jdim , 1 : 3 ) = ddyn_s ( ik , idim , jdim , 1 : 3 ) - & oneI * t ( 1 : 3 ) * & self % ifc2 ( ipol , jpol , iat , jat , t1 , t2 , t3 ) * & expi ( - kt ) * weight end if end do end do end do end if total_weight = total_weight + weight end do end do end do end do end do !The nonanalytic correction has two components in this approximation. dyn_g = 0.0_r64 if ( present ( velocities )) ddyn_g = 0.0_r64 if ( crys % polar ) then do m1 =- ncell_g ( 1 ), ncell_g ( 1 ) do m2 =- ncell_g ( 2 ), ncell_g ( 2 ) do m3 =- ncell_g ( 3 ), ncell_g ( 3 ) g ( 1 : 3 ) = m1 * self % cell_g ( 1 , 1 : 3 ) + & m2 * self % cell_g ( 2 , 1 : 3 ) + m3 * self % cell_g ( 3 , 1 : 3 ) geg = dot_product ( g ( 1 : 3 ), matmul ( eps , g ( 1 : 3 ))) if ( geg . gt . 0.0_r64 . and . geg / alpha / 4.0_r64 . lt . gmax ) then exp_g = exp ( - geg / alpha / 4.0_r64 ) / geg do iat = 1 , nat zig ( 1 : 3 ) = matmul ( g ( 1 : 3 ), zeff ( iat , 1 : 3 , 1 : 3 )) auxi ( 1 : 3 ) = 0. do jat = 1 , nat gr = dot_product ( g ( 1 : 3 ), self % rr ( iat , jat , 1 : 3 )) zjg ( 1 : 3 ) = matmul ( g ( 1 : 3 ), zeff ( jat , 1 : 3 , 1 : 3 )) auxi ( 1 : 3 ) = auxi ( 1 : 3 ) + zjg ( 1 : 3 ) * expi ( gr ) end do do ipol = 1 , 3 idim = ( iat - 1 ) * 3 + ipol do jpol = 1 , 3 jdim = ( iat - 1 ) * 3 + jpol dyn_g ( 1 : nk , idim , jdim ) = dyn_g ( 1 : nk , idim , jdim ) - & exp_g * zig ( ipol ) * auxi ( jpol ) end do end do end do end if g_old ( 0 : 3 ) = g ( 0 : 3 ) do ik = 1 , nk g ( 1 : 3 ) = g_old ( 1 : 3 ) + k ( ik , 1 : 3 ) geg = dot_product ( g ( 1 : 3 ), matmul ( eps , g ( 1 : 3 ))) if ( geg . gt . 0.0_r64 . and . geg / alpha / 4.0_r64 . lt . gmax ) then exp_g = exp ( - geg / alpha / 4.0_r64 ) / geg dgeg = matmul ( eps + transpose ( eps ), g ( 1 : 3 )) do iat = 1 , nat zig ( 1 : 3 ) = matmul ( g ( 1 : 3 ), zeff ( iat , 1 : 3 , 1 : 3 )) do jat = 1 , nat gr = dot_product ( g ( 1 : 3 ), self % rr ( iat , jat , 1 : 3 )) zjg ( 1 : 3 ) = matmul ( g ( 1 : 3 ), zeff ( jat , 1 : 3 , 1 : 3 )) do ipol = 1 , 3 idim = ( iat - 1 ) * 3 + ipol do jpol = 1 , 3 jdim = ( jat - 1 ) * 3 + jpol dyn_g ( ik , idim , jdim ) = dyn_g ( ik , idim , jdim ) + & exp_g * zig ( ipol ) * zjg ( jpol ) * expi ( gr ) if ( present ( velocities )) then do i = 1 , 3 ddyn_g ( ik , idim , jdim , i ) = ddyn_g ( ik , idim , jdim , i ) + & exp_g * expi ( gr ) * & ( zjg ( jpol ) * zeff ( iat , i , ipol ) + zig ( ipol ) * zeff ( jat , i , jpol ) + & zig ( ipol ) * zjg ( jpol ) * oneI * self % rr ( iat , jat , i ) - & zig ( ipol ) * zjg ( jpol ) * ( dgeg ( i ) / alpha / 4.0 + dgeg ( i ) / geg )) end do end if end do end do end do end do end if end do end do end do end do dyn_g = dyn_g * 8.0_r64 * pi / volume_r if ( present ( velocities )) ddyn_g = ddyn_g * 8.0_r64 * pi / volume_r end if ! Once the dynamical matrix has been built, the frequencies and ! group velocities are extracted exactly like in the previous ! subroutine. do ik = 1 , nk dyn (:,:) = dyn_s ( ik ,:,:) + dyn_g ( ik ,:,:) if ( present ( velocities )) then ddyn (:,:,:) = ddyn_s ( ik ,:,:,:) + ddyn_g ( ik ,:,:,:) end if !Force Hermiticity do ipol = 1 , nbranches do jpol = ipol + 1 , nbranches dyn ( ipol , jpol ) = ( dyn ( ipol , jpol ) + conjg ( dyn ( jpol , ipol ))) * 0.5_r64 dyn ( jpol , ipol ) = dyn ( ipol , jpol ) end do end do do ipol = 1 , 3 do jpol = 1 , 3 do iat = 1 , nat do jat = 1 , nat idim = ( iat - 1 ) * 3 + ipol jdim = ( jat - 1 ) * 3 + jpol dyn ( idim , jdim ) = dyn ( idim , jdim ) / self % mm ( iat , jat ) if ( present ( velocities )) then ddyn ( idim , jdim , 1 : 3 ) = ddyn ( idim , jdim , 1 : 3 ) / self % mm ( iat , jat ) end if end do end do end do end do call zheev ( \"V\" , \"U\" , nbranches , dyn (:,:), nbranches , omega2 , work , - 1_i64 , rwork , i ) if ( real ( work ( 1 )). gt . nwork ) then nwork = nint ( 2 * real ( work ( 1 ))) deallocate ( work ) allocate ( work ( nwork )) end if call zheev ( \"V\" , \"U\" , nbranches , dyn (:,:), nbranches , omega2 , work , nwork , rwork , i ) if ( present ( eigenvect )) then eigenvect ( ik ,:,:) = transpose ( dyn (:,:)) end if omegas ( ik ,:) = sign ( sqrt ( abs ( omega2 )), omega2 ) if ( present ( velocities )) then do i = 1 , nbranches do j = 1 , 3 velocities ( ik , i , j ) = real ( dot_product ( dyn (:, i ),& matmul ( ddyn (:,:, j ), dyn (:, i )))) end do velocities ( ik , i ,:) = velocities ( ik , i ,:) / ( 2.0_r64 * omegas ( ik , i )) end do end if !Take care of gamma point. if ( all ( k ( ik , 1 : 3 ) == 0 )) then omegas ( ik , 1 : 3 ) = 0.0_r64 if ( present ( velocities )) velocities ( ik , :, :) = 0.0_r64 end if end do !Units conversion omegas = omegas * Ryd2eV !eV if ( present ( velocities )) velocities = velocities * toTHz * bohr2nm !Km/s end subroutine phonon_espresso end module phonon_module","tags":"","loc":"sourcefile/phonon.f90.html"},{"title":"particle.f90 – elphbolt","text":"Contents Modules particle_module Source Code particle.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module particle_module !! Module containing the particle abstract data type. use params , only : r64 , i64 implicit none private public particle type particle !! Data related to generic particle properties. integer ( i64 ) :: numbands !! Total number of energy dispersion bands. integer ( i64 ) :: wvmesh ( 3 ) !! Particle wave vector mesh. integer ( i64 ) :: nwv !! Number of particle wave vectors in the full Brillouin zone (FBZ). integer ( i64 ) :: nwv_irred !! Number of particle wave vectors in the irreducible wedge of Brillouin zone (IBZ). real ( r64 ), allocatable :: wavevecs (:,:) !! List of all particle wave vectors (crystal coordinates). real ( r64 ), allocatable :: wavevecs_irred (:,:) !! List of irreducible particle wave vectors (crystal coordinates). integer ( i64 ), allocatable :: indexlist (:) !! List of muxed indices of the FBZ wave vectors. integer ( i64 ), allocatable :: indexlist_irred (:) !! List of muxed indices of the IBZ wedge. integer ( i64 ), allocatable :: nequiv (:) !! List of the number of equivalent points for each IBZ point. integer ( i64 ), allocatable :: ibz2fbz_map (:,:,:) !! Map from an IBZ particle wave vector point to its images. !! The third axis contains the pair (symmetry index, image). integer ( i64 ), allocatable :: fbz2ibz_map (:) !! Map from an FBZ particle wave vector point to its IBZ wedge image. integer ( i64 ), allocatable :: equiv_map (:,:) !! Map of equivalent points under rotations. !! Axis 1 runs over rotations. !! Axis 2 runs over wave vectors. real ( r64 ), allocatable :: symmetrizers (:,:,:) !! Symmetrizers of wave vector dependent vectors. integer ( i64 ), allocatable :: tetra (:,:) !! List of all the wave vector mesh tetrahedra vertices. !! First axis list tetraheda and the second axis list the vertices. integer ( i64 ), allocatable :: tetracount (:) !! The number of tetrahedra in which a wave vector belongs. integer ( i64 ), allocatable :: tetramap (:,:,:) !! Mapping from a wave vector to the (tetrahedron, vertex) where it belongs. real ( r64 ), allocatable :: tetra_evals (:,:,:) !! Tetrahedra vertices filled with eigenvalues. integer ( i64 ), allocatable :: triang (:,:) !! List of all the wave vector mesh triangles vertices. !! First axis lists triangles and the second axis lists the vertices. integer ( i64 ), allocatable :: triangcount (:) !! The number of triangles in which a wave vector belongs. integer ( i64 ), allocatable :: triangmap (:,:,:) !! Mapping from a wave vector to the (triangle, vertex) where it belongs. real ( r64 ), allocatable :: triang_evals (:,:,:) !! Triangles vertices filled with eigenvalues. real ( r64 ), allocatable :: ens (:,:) !! List of particle energies on FBZ. real ( r64 ), allocatable :: ens_irred (:,:) !! List of particle energies on IBZ. real ( r64 ), allocatable :: vels (:,:,:) !! List of particle velocities on FBZ. real ( r64 ), allocatable :: vels_irred (:,:,:) !! List of particle velocites on IBZ. complex ( r64 ), allocatable :: evecs (:,:,:) !! List of all particle eigenvectors. complex ( r64 ), allocatable :: evecs_irred (:,:,:) !! List of IBZ wedge particle eigenvectors. real ( r64 ), allocatable :: dos (:,:) !! Band resolved density of states. end type particle end module particle_module","tags":"","loc":"sourcefile/particle.f90.html"},{"title":"supersweet.f90 – elphbolt","text":"Contents Programs supersweet Source Code supersweet.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. program supersweet !! Author: Nakib Haider Protik !! Summary: Main driver program. !! Version: 1.0.1 !! !! supersweet is the superconductivity suite of elphbolt. !! This is a solver for the Migdal-Eliashberg equations as described in !! E. R. Margine and F. Giustino, Phys. Rev. B 87, 024505 (2013). use params , only : r64 !for debug use misc , only : print_message , subtitle , timer !TODO, supersweet_welcome use numerics_module , only : numerics use crystal_module , only : crystal use symmetry_module , only : symmetry use electron_module , only : electron use phonon_module , only : phonon use wannier_module , only : epw_wannier use MigEl_sc_module , only : migel_sc use bz_sums , only : calculate_el_dos_fermi , calculate_el_Ws use interactions , only : calculate_gkRp , calculate_eph_interaction_ibzk use eliashberg , only : calculate_a2F implicit none type ( numerics ) :: num type ( crystal ) :: crys type ( symmetry ) :: sym type ( epw_wannier ) :: wann type ( electron ) :: el type ( phonon ) :: ph type ( MigEl_sc ) :: migel type ( timer ) :: t_all , t_event !TODO call supersweet_welcome call t_all % start_timer ( 'elphbolt->supersweet' ) call t_event % start_timer ( 'Initialization' ) !Set up crystal call crys % initialize !Set up numerics data call num % initialize ( crys ) !Calculate crystal and BZ symmetries call sym % calculate_symmetries ( crys , num % qmesh ) !Read EPW Wannier data call wann % read ( num ) !Calculate electrons call el % initialize ( wann , crys , sym , num ) call t_event % end_timer ( 'Initialization' ) call t_event % start_timer ( 'Phonons' ) !Calculate phonons call ph % initialize ( crys , sym , num ) call t_event % end_timer ( 'Phonons' ) call t_event % start_timer ( 'Migdal-Eliashberg setup' ) call migel % initialize ( maxval ( ph % ens (:,:))) !!$  !DEBUG For now calling with a random value of temperature !!$  call migel%generate_matsubara_meshes(300.0_r64, maxval(ph%ens(:,:))) call t_event % end_timer ( 'Migdal-Eliashberg setup' ) call t_event % start_timer ( 'Density of states' ) call subtitle ( \"Calculating density of states...\" ) !Calculate electron density of states at the Fermi level call calculate_el_dos_Fermi ( el , num % tetrahedra ) !Calculate the scaled electron delta functions call calculate_el_Ws ( el , num % tetrahedra ) !!$  !Calculate phonon density of states !!$  call calculate_dos(ph, num%tetrahedra, crys%gfactors, crys%subs_gfactors, & !!$       crys%atomtypes) call t_event % end_timer ( 'Density of states' ) if (. not . num % read_gk2 ) then call t_event % start_timer ( 'IBZ k e-ph interactions' ) !Calculate mixed Bloch-Wannier space e-ph vertex g(k,Rp) call calculate_gkRp ( wann , el , num ) !Calculate Bloch space e-ph vertex g(k,q) for IBZ k call calculate_eph_interaction_ibzk ( wann , crys , el , ph , num , 'g' ) call t_event % end_timer ( 'IBZ k e-ph interactions' ) end if !Deallocate Wannier quantities call wann % deallocate_wannier ( num ) !After this point the electron eigenvectors are not needed call el % deallocate_eigenvecs !TODO I need to generalize the subroutine phonon/deallocate_phonon_quantities !to use the following !!$  !After this point the phonon eigenvectors and other quantities are not needed !!$  call ph%deallocate_phonon_quantities !Calculate a2F !call calculate_a2F(wann, el, ph, num, migel%omegas, el%spinnormed_dos_fermi) call calculate_a2F ( wann , el , ph , num , migel % omegas , migel % iso_lambda0 , migel % omegalog ) !!$  call calculate_lambda(wann, el, num, migel%omegas, migel%iso_lambda0, migel%omegalog, migel%bose_matsubara_ens, migel%isotropic) call migel % calculate_MAD_theory !TODO migel%solve(...) call migel % calculate_MigEl_theory ( el , wann , num , maxval ( ph % ens (:,:))) call t_all % end_timer ( 'elphbolt->supersweet' ) call print_message ( '______________________Thanks for using elphbolt->supersweet. Bye!______________________' ) end program supersweet","tags":"","loc":"sourcefile/supersweet.f90.html"},{"title":"electron.f90 – elphbolt","text":"Contents Modules electron_module Source Code electron.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module electron_module !! Module containing types and procedures related to the electronic properties. use params , only : r64 , i64 use particle_module , only : particle use misc , only : exit_with_message , print_message , demux_state , sort , & binsearch , subtitle , Fermi , write2file_rank2_real , write2file_rank3_real use numerics_module , only : numerics use wannier_module , only : epw_wannier use crystal_module , only : crystal , calculate_wavevectors_full use symmetry_module , only : symmetry , find_irred_wedge , create_fbz2ibz_map use delta , only : form_tetrahedra_3d , fill_tetrahedra_3d , form_triangles , & fill_triangles implicit none private public electron !external chdir type , extends ( particle ) :: electron !! Data and procedures related to the electronic properties. character ( len = 2 ) :: prefix = 'el' !! Prefix idenitfying particle type. integer ( i64 ) :: spindeg !! Spin degeneracy. integer ( i64 ) :: numtransbands !! Total number of transport active bands. integer ( i64 ) :: indlowband !! Lowest transport band index. integer ( i64 ) :: indhighband !! Highest transport band index. integer ( i64 ) :: indlowconduction !! Lowest conduction band index. integer ( i64 ) :: indhighvalence !! Highest valence band index. integer ( i64 ), allocatable :: bandlist (:) !! List of transport active band indices. integer ( i64 ) :: mesh_ref !! Electron mesh refinement factor compared to the phonon mesh. integer ( i64 ) :: mesh_ref_array ( 3 ) !! The same as above, but in array form. This is useful for 3d vs 2d cases. integer ( i64 ) :: nstates_inwindow !! Number of electron wave vectors within transport window. integer ( i64 ) :: nstates_irred_inwindow !! Number of IBZ wedge electron wave vectors within transport window. integer ( i64 ), allocatable :: IBZ_inwindow_states (:,:) !! List of irreducible wedge states within transport window. real ( r64 ) :: enref !! Electron reference energy (eV). !! This is the center of the transport energy window. real ( r64 ) :: fsthick !! Fermi surface thickness (eV). real ( r64 ) :: chempot !! Chemical potential in (eV). real ( r64 ), allocatable :: conc (:) !! Band resolved carrier concentration. real ( r64 ) :: conc_el !! Total electron carrier concentration. real ( r64 ) :: conc_hole !! Total hole carrier concentration. real ( r64 ) :: chimp_conc_n !! Concentration of donor impurities. real ( r64 ) :: chimp_conc_p !! Concentration of acceptor impurities. real ( r64 ) :: Zn !! Ionization number of donor dopant. real ( r64 ) :: Zp !! Ionization number of acceptor dopant. real ( r64 ), allocatable :: scissor (:) !! Scissor operator (eV) logical :: metallic !! Is the system metallic? character ( len = 1 ) :: dopingtype !! Type of doping. This is needed for runlevel 0 only. integer ( i64 ) :: numconc !! Number of concentration points. This is needed for runlevel 0 only. real ( r64 ), allocatable :: conclist (:) !! List of concentrations. This is needed for runlevel 0 only. integer ( i64 ) :: numT !! Number of temperature points. This is needed for runlevel 0 only. real ( r64 ), allocatable :: Tlist (:) !! List of temperatures. This is needed for runlevel 0 only. real ( r64 ) :: spinnormed_dos_fermi !! Spin-normalized density of states at the Fermi level real ( r64 ), allocatable :: Ws_irred (:, :), Ws (:, :) !! Electron delta functions normalized by spinnormed_dos_fermi contains procedure , public :: initialize => read_input_and_setup , deallocate_eigenvecs procedure , private :: calculate_electrons , calculate_carrier_conc , & calculate_chempot end type electron contains subroutine read_input_and_setup ( self , wann , crys , sym , num ) !! Read input file and setup groundstate electronic system. class ( electron ), intent ( out ) :: self type ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( numerics ), intent ( in ) :: num !Local variables real ( r64 ) :: enref , Zn , Zp , chempot , scissor real ( r64 ), allocatable :: Tlist (:), conclist (:) integer ( i64 ) :: ib , spindeg , numbands , indlowband , indhighband , & indlowconduction , indhighvalence , numT , numconc logical :: metallic character ( len = 6 ) :: concunits character ( len = 1 ) :: dopingtype namelist / electrons / enref , spindeg , numbands , & indlowband , indhighband , metallic , chempot , Zn , Zp , & indlowconduction , indhighvalence , dopingtype , numT , numconc , & Tlist , conclist , scissor call subtitle ( \"Setting up electrons...\" ) !Open input file open ( 1 , file = 'input.nml' , status = 'old' ) !Read electrons information spindeg = 2 !Default calculation is non-spin polarized numbands = 0 indlowband = 0 indhighband = 0 indlowconduction = 0 indhighvalence = 0 metallic = . false . Zn = 0.0_r64 Zp = 0.0_r64 scissor = 0.0_r64 chempot = - 99999 9.99999_r64 !Something crazy enref = - 99999 9.99999_r64 !Something crazy numT = 100 !Something crazy big numconc = 100 !Something crazy big dopingtype = 'x' allocate ( Tlist ( nuMT ), conclist ( numconc )) Tlist = - 1.0_r64 !Something crazy conclist = 0.0_r64 read ( 1 , nml = electrons ) if ( spindeg < 1 . or . spindeg > 2 ) then call exit_with_message ( 'spindeg can be 1 or 2.' ) end if if ( numbands < 1 ) then call exit_with_message ( 'numbands should be > 0.' ) end if if ( indlowband < 1 ) then call exit_with_message ( 'indlowband should be > 0.' ) end if if ( indhighband < 1 ) then call exit_with_message ( 'indhighband should be > 0.' ) end if if (. not . metallic ) then if ( indlowconduction < 1 . and . indhighvalence < 1 ) then call exit_with_message (& 'For non-metals, must provide lowest conduction or highest valence band.' ) end if end if if ( metallic . and . scissor . ne . 0.0_r64 ) then call exit_with_message (& 'Scissor operator cannot be applied to metals.' ) end if if ( metallic . and . scissor . lt . 0.0_r64 ) then call exit_with_message (& 'Scissor operator must be positive.' ) end if if ( numbands . ne . wann % numwannbands ) then call exit_with_message (& 'Number of wannier bands is not correct.' ) end if if ( num % runlevel == 0 ) then if ( numT <= 0 . or . numconc <= 0 ) then call exit_with_message ( 'numT or numconc should be > 0.' ) end if if ( numT > 100 . or . numconc > 100 ) then call exit_with_message ( 'numT or numconc > 1000 is not supported.' ) end if if ( any ( Tlist ( 1 : numT ) <= 0.0_r64 )) then call exit_with_message ( 'Unphysical Tlist provided.' ) end if if ( dopingtype /= 'n' . and . dopingtype /= 'p' ) then print * , dopingtype , len ( dopingtype ) call exit_with_message ( \"dopingtype must be 'n' or 'p'.\" ) end if end if self % spindeg = spindeg self % numbands = numbands self % indlowband = indlowband self % indhighband = indhighband self % numtransbands = self % indhighband - self % indlowband + 1 allocate ( self % bandlist ( self % numtransbands )) do ib = 1 , self % numtransbands self % bandlist ( ib ) = indlowband + ib - 1 end do self % metallic = metallic self % indlowconduction = indlowconduction self % indhighvalence = indhighvalence !Define all cases even when one of them is not defined if (. not . metallic . and . indlowconduction < 1 ) then self % indlowconduction = indhighvalence + 1 end if if (. not . metallic . and . indhighvalence < 1 ) then self % indhighvalence = indlowconduction - 1 end if self % enref = enref self % chempot = chempot self % Zn = Zn self % Zp = Zp if ( self % metallic ) then self % Zn = 0 self % Zp = 0 end if if ( num % runlevel == 0 ) then self % numT = numT self % numconc = numconc allocate ( self % Tlist ( self % numT ), self % conclist ( self % numconc )) self % Tlist (:) = Tlist ( 1 : numT ) self % conclist (:) = conclist ( 1 : numconc ) self % dopingtype = dopingtype end if !Close input file close ( 1 ) !Set some electronic properties from the numerics object self % mesh_ref = num % mesh_ref self % mesh_ref_array = ( / num % mesh_ref , num % mesh_ref , num % mesh_ref / ) if ( crys % twod ) then self % wvmesh ( 3 ) = 1_i64 self % mesh_ref_array ( 3 ) = 1_i64 end if self % wvmesh = self % mesh_ref_array * num % qmesh self % fsthick = num % fsthick !Computing the shift in energy due to scissor operator allocate ( self % scissor ( wann % numwannbands )) self % scissor (:) = 0.0_r64 if (. not . metallic ) then self % scissor ( self % indlowconduction : wann % numwannbands ) = scissor end if !Print out information. if ( this_image () == 1 ) then write ( * , \"(A, I1)\" ) \"Spin degeneracy = \" , self % spindeg write ( * , \"(A, I5)\" ) \"Number of Wannier electronic bands = \" , self % numbands write ( * , \"(A, I5)\" ) \"Number of transport active electronic bands = \" , self % numtransbands write ( * , \"(A, I5, I5)\" ) \"Lowest and highest transport active electronic bands = \" , & self % bandlist ( 1 ), self % bandlist ( self % numtransbands ) write ( * , \"(A, 1E16.8, A)\" ) \"Reference electron energy = \" , self % enref , ' eV' write ( * , \"(A, L)\" ) \"System is metallic: \" , self % metallic if ( indlowconduction > 0 ) then write ( * , \"(A, I5)\" ) \"Lowest conduction band index = \" , self % indlowconduction end if if ( indhighvalence > 0 ) then write ( * , \"(A, I5)\" ) \"Highest valence band index = \" , self % indhighvalence end if if ( scissor . ne . 0.0_r64 ) then write ( * , \"(A, 1E16.8, A)\" ) \"Scissor operator = \" , & self % scissor ( self % indlowconduction ) , \" eV\" end if end if !Calculate electrons call calculate_electrons ( self , wann , crys , sym , num ) !Set total number of charged impurities if (. not . self % metallic ) then self % chimp_conc_n = 0.0_r64 self % chimp_conc_p = 0.0_r64 if ( self % Zn > 0 ) self % chimp_conc_n = self % chimp_conc_n + self % conc_el / self % Zn if ( self % Zp > 0 ) self % chimp_conc_p = self % chimp_conc_p + self % conc_hole / self % Zp end if !Print out information. call print_message ( \"Electron calculations summary:\" ) call print_message ( \"------------------------------\" ) if ( this_image () == 1 ) then if ( crys % twod ) then concunits = ' cm&#94;-2' else concunits = ' cm&#94;-3' end if write ( * , \"(A, 1E16.8, A)\" ) \"Chemical potential = \" , self % chempot , ' eV' if (. not . self % metallic ) then write ( * , \"(A, 1E16.8)\" ) 'Band resolved carrier concentration (+/- = hole/electron):' do ib = self % indlowband , self % indhighband write ( * , \"(A, I5, A, 1E16.8, A)\" ) ' Band: ' , ib , ', concentration: ' , & self % conc ( ib ), concunits end do write ( * , \"(A, 1E16.8, A)\" ) \"Absolute total electron concentration = \" , self % conc_el , & concunits write ( * , \"(A, 1E16.8, A)\" ) \"Absolute total hole concentration = \" , self % conc_hole , & concunits write ( * , \"(A, 1E16.8)\" ) \"Ionization of donor impurity = \" , self % Zn write ( * , \"(A, 1E16.8)\" ) \"Ionization of acceptor impurity = \" , self % Zp write ( * , \"(A, 1E16.8, A)\" ) \"Donor impurity concentration = \" , self % chimp_conc_n , & concunits write ( * , \"(A, 1E16.8, A)\" ) \"Acceptor impurity concentration = \" , self % chimp_conc_p , & concunits end if end if end subroutine read_input_and_setup subroutine calculate_electrons ( self , wann , crys , sym , num ) !! Calculate electron energy window restricted wave vector meshes !! and the electronic properties on them class ( electron ), intent ( inout ) :: self type ( epw_wannier ), intent ( in ) :: wann type ( crystal ), intent ( in ) :: crys type ( symmetry ), intent ( in ) :: sym type ( numerics ), intent ( in ) :: num !Some utitlity variables integer ( i64 ) :: i , l , s , il , ii , jj , kk , ib , count , istate , aux real ( r64 ), allocatable :: el_ens_tmp (:, :), el_vels_tmp (:, :, :) !Switch for mesh utilites with or without energy restriction logical :: blocks !I/O related character ( len = 1024 ) :: filename , numcols call print_message ( \"Energy unrestricted calculation:\" ) call print_message ( \"--------------------------------\" ) !Set initial FBZ total number of wave vectors self % nwv = product ( self % wvmesh ) !The electronic mesh setup proceeds in multiple steps: ! 1. Calculate full electron wave vector mesh call print_message ( \"Calculating FBZ...\" ) blocks = . false . call calculate_wavevectors_full ( self % wvmesh , self % wavevecs , blocks ) ! 2. Calculate the IBZ call print_message ( \"Calculating IBZ and IBZ -> FBZ mappings...\" ) call find_irred_wedge ( self % wvmesh , self % nwv_irred , self % wavevecs_irred , & self % indexlist_irred , self % nequiv , sym % nsymm_rot , sym % qrotations , & self % ibz2fbz_map , self % equiv_map , blocks ) ! 3. Calculate IBZ quantities call print_message ( \"Calculating IBZ energies...\" ) allocate ( self % ens_irred ( self % nwv_irred , wann % numwannbands ), & self % vels_irred ( self % nwv_irred , wann % numwannbands , 3 ), & self % evecs_irred ( self % nwv_irred , wann % numwannbands , wann % numwannbands )) call wann % el_wann_epw ( crys , self % nwv_irred , self % wavevecs_irred , self % ens_irred , & self % vels_irred , self % evecs_irred , self % scissor ) ! 4. Map out FBZ quantities from IBZ ones call print_message ( \"Mapping out FBZ energies...\" ) allocate ( self % indexlist ( self % nwv ), self % ens ( self % nwv , wann % numwannbands ), & self % vels ( self % nwv , wann % numwannbands , 3 )) do i = 1 , self % nwv_irred !an irreducible point do l = 1 , self % nequiv ( i ) !number of equivalent points of i il = self % ibz2fbz_map ( l , i , 2 ) ! (i, l) -> il s = self % ibz2fbz_map ( l , i , 1 ) ! mapping rotation !index list self % indexlist ( il ) = il !energy self % ens ( il ,:) = self % ens_irred ( i ,:) !velocity do ib = 1 , self % numtransbands !wann%numwannbands !here use real space (Cartesian) rotations self % vels ( il , ib , :) = matmul ( sym % crotations (:, :, s ), self % vels_irred ( i , ib , :)) end do end do end do if (. not . self % metallic ) then if ( num % runlevel == 0 ) then !Calculate chemical potentials for !the given temperatures and concentrations if ( crys % twod ) then call calculate_chempot ( self , crys % volume , self % dopingtype , self % Tlist , self % conclist , & crys % thickness ) else call calculate_chempot ( self , crys % volume , self % dopingtype , self % Tlist , self % conclist ) end if call exit_with_message ( \"Chemical potentials calculated. Runlevel 0 finished. Exiting.\" ) else !Calculate carrier concentration for non-metals call print_message ( \"Calculating carrier concentrations...\" ) if ( crys % twod ) then call calculate_carrier_conc ( self , crys % T , crys % volume , crys % thickness ) else call calculate_carrier_conc ( self , crys % T , crys % volume ) end if end if end if call print_message ( \"Transport energy window restricted calculation:\" ) call print_message ( \"-----------------------------------------------\" ) ! 5. Find energy window restricted FBZ blocks. !    After this step, self%nwv, self%indexlist will refer !    to the energy restricted mesh. call print_message ( \"Calculating Fermi window restricted FBZ blocks...\" ) call apply_energy_window ( self % nwv , self % indexlist , self % ens , self % enref , self % fsthick ) ! 6. Sort index list and related quanties of FBZ blocks call print_message ( \"Sorting FBZ blocks index list...\" ) call sort ( self % indexlist ) ! 7. Get FBZ blocks wave vectors, energies, velocities and eigenvectors. !    After this step, self%wavevecs, self%ens, self%vels, and self%evecs !    will refer to the energy restricted mesh. call print_message ( \"Calcutating FBZ blocks quantities...\" ) !wave vectors deallocate ( self % wavevecs ) blocks = . true . call calculate_wavevectors_full ( self % wvmesh , self % wavevecs , blocks , self % indexlist ) !wave vectors !Print electron FBZ mesh call write2file_rank2_real ( \"el.wavevecs_fbz\" , self % wavevecs ) !energies and velocities call fbz_blocks_quantities ( self % indexlist , self % ens , self % vels ) !Get FBZ blocks eigenvectors from direct calculations since we are !not getting these from IBZ quantities via symmetry rotations allocate ( self % evecs ( self % nwv , wann % numwannbands , wann % numwannbands )) allocate ( el_ens_tmp ( self % nwv , wann % numwannbands ), el_vels_tmp ( self % nwv , wann % numwannbands , 3 )) call wann % el_wann_epw ( crys , self % nwv , self % wavevecs , el_ens_tmp , el_vels_tmp , & self % evecs , self % scissor ) deallocate ( el_ens_tmp , el_vels_tmp ) !free up memory ! 8. Find IBZ of energy window restricted blocks !    After this step, self%nwv_irred, self%indexlist_irred, !    self%wavevecs_irred, self%nequiv, and self%ibz2fbz_map !    will refer to the energy restricted mesh call print_message ( \"Calculating IBZ blocks...\" ) deallocate ( self % wavevecs_irred , self % indexlist_irred , self % nequiv , & self % ibz2fbz_map , self % equiv_map ) blocks = . true . call find_irred_wedge ( self % wvmesh , self % nwv_irred , self % wavevecs_irred , & self % indexlist_irred , self % nequiv , sym % nsymm_rot , sym % qrotations , & self % ibz2fbz_map , self % equiv_map , blocks , self % indexlist ) !Print electron IBZ mesh call write2file_rank2_real ( \"el.wavevecs_ibz\" , self % wavevecs_irred ) !Create symmetrizers of wave vector dependent vectors ShengBTE style allocate ( self % symmetrizers ( 3 , 3 , self % nwv )) self % symmetrizers = 0.0_r64 do i = 1 , self % nwv ii = self % indexlist ( i ) kk = 0 do jj = 1 , sym % nsymm if ( self % equiv_map ( jj , i ) == ii ) then self % symmetrizers (:, :, i ) = self % symmetrizers (:, :, i ) + & sym % crotations_orig (:, :, jj ) kk = kk + 1 end if end do if ( kk > 1 ) then self % symmetrizers (:, :, i ) = self % symmetrizers (:, :, i ) / kk end if end do ! 9. Get IBZ blocks energies, velocities, and eigen vectors. call print_message ( \"Calcutating IBZ blocks quantities...\" ) deallocate ( self % ens_irred , self % vels_irred , self % evecs_irred ) allocate ( self % ens_irred ( self % nwv_irred , wann % numwannbands ), & self % vels_irred ( self % nwv_irred , wann % numwannbands , 3 ), & self % evecs_irred ( self % nwv_irred , wann % numwannbands , wann % numwannbands )) call wann % el_wann_epw ( crys , self % nwv_irred , self % wavevecs_irred , self % ens_irred , & self % vels_irred , self % evecs_irred , self % scissor ) ! 10. Calculate the number of FBZ blocks electronic states !     available for scattering self % nstates_inwindow = 0 do i = 1 , self % nwv !over FBZ blocks do ib = 1 , wann % numwannbands !bands if ( abs ( self % ens ( i , ib ) - self % enref ) <= self % fsthick ) & self % nstates_inwindow = self % nstates_inwindow + 1 end do end do if ( this_image () == 1 ) write ( * , \"(A, I10)\" ) & \" Number of energy restricted FBZ blocks states = \" , self % nstates_inwindow ! 11. Create FBZ blocks to IBZ blocks map call print_message ( \"Calculating FBZ -> IBZ mappings...\" ) call create_fbz2ibz_map ( self % fbz2ibz_map , self % nwv , self % nwv_irred , & self % indexlist , self % nequiv , self % ibz2fbz_map ) do i = 1 , self % nwv_irred !IBZ do l = 1 , self % nequiv ( i ) !number of equivalent points of i il = self % ibz2fbz_map ( l , i , 2 ) ! (i, l) -> il s = self % ibz2fbz_map ( l , i , 1 ) ! symmetry call binsearch ( self % indexlist , il , aux ) !energy self % ens ( aux ,:) = self % ens_irred ( i ,:) !velocity do ib = 1 , wann % numwannbands !here use real space (Cartesian) rotations self % vels ( aux , ib , :) = matmul ( sym % crotations (:, :, s ), self % vels_irred ( i , ib , :)) end do self % vels ( aux ,:,:) = transpose (& matmul ( self % symmetrizers (:,:, aux ), transpose ( self % vels ( aux ,:,:)))) end do end do ! 12. Calculate the number of IBZ electronic states available for scattering self % nstates_irred_inwindow = 0 do istate = 1 , self % nwv_irred * wann % numwannbands !Demux state index into band (ib) and wave vector (i) indices call demux_state ( istate , wann % numwannbands , ib , i ) if ( abs ( self % ens_irred ( i , ib ) - self % enref ) <= self % fsthick ) then self % nstates_irred_inwindow = self % nstates_irred_inwindow + 1 end if end do if ( this_image () == 1 ) write ( * , \"(A, I10)\" ) \" Number of energy restricted IBZ blocks states = \" , & self % nstates_irred_inwindow !Calculate list of IBZ in-window states = (wave vector index, band index) allocate ( self % IBZ_inwindow_states ( self % nstates_irred_inwindow , 2 )) count = 0 do istate = 1 , self % nwv_irred * wann % numwannbands !Demux state index into band (ib) and wave vector (i) indices call demux_state ( istate , wann % numwannbands , ib , i ) if ( abs ( self % ens_irred ( i , ib ) - self % enref ) <= self % fsthick ) then count = count + 1 self % IBZ_inwindow_states ( count ,:) = [ i , ib ] end if end do !Write IBZ in-window states as text data to file if ( this_image () == 1 ) then call chdir ( num % cwd ) filename = 'el.inwindow_states_ibz' write ( numcols , \"(I0)\" ) 2 open ( 1 , file = trim ( filename ), status = 'replace' ) write ( 1 , * ) \"#k-vec index     band index\" do i = 1 , self % nstates_irred_inwindow write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"I10)\" ) self % IBZ_inwindow_states ( i ,:) end do close ( 1 ) end if !Deallocating this here since this is not used later in the program deallocate ( self % IBZ_inwindow_states ) !Print out irreducible electron energies and velocities call write2file_rank2_real ( \"el.ens_ibz\" , self % ens_irred ) call write2file_rank3_real ( \"el.vels_ibz\" , self % vels_irred ) !Calculate electron tetrahedra if ( num % tetrahedra ) then call print_message ( \"Calculating electron mesh tetrahedra...\" ) call form_tetrahedra_3d ( self % nwv , self % wvmesh , self % tetra , self % tetracount , & self % tetramap , . true ., self % indexlist ) call fill_tetrahedra_3d ( self % tetra , self % ens , self % tetra_evals ) else call print_message ( \"Calculating electron mesh triangles...\" ) call form_triangles ( self % nwv , self % wvmesh , self % triang , self % triangcount , & self % triangmap , . true ., self % indexlist ) call fill_triangles ( self % triang , self % ens , self % triang_evals ) end if end subroutine calculate_electrons subroutine apply_energy_window ( nk , indexlist , energies , enref , fsthick ) !! Subroutine to find the Fermi window restricted blocks of BZ. !! This could be used for FBZ and IBZ. !! !! nk is the number of mesh points - will be updated to !! the number of mesh points in energy restricted blocks !! !! indexlist is the list of wave vector indices - will be updated !! to the list of indices in the blocks integer ( i64 ), intent ( inout ) :: nk integer ( i64 ), allocatable , intent ( inout ) :: indexlist (:) real ( r64 ), intent ( in ) :: energies (:,:), enref , fsthick integer ( i64 ) :: ik , count , numbands , inwindow ( nk ) real ( r64 ), allocatable :: aux (:) numbands = size ( energies ( 1 ,:)) allocate ( aux ( numbands )) count = 0 do ik = 1 , nk aux = energies ( ik , :) !Check if any band energy is within the Fermi window if ( any ( abs ( aux (:) - enref ) <= fsthick )) then count = count + 1 inwindow ( count ) = ik !save index of in-window points end if end do if ( count == 0 ) call exit_with_message ( \"No states found within Fermi window.\" ) !Update index list deallocate ( indexlist ) allocate ( indexlist ( count )) indexlist ( 1 : count ) = inwindow ( 1 : count ) !Update number of irreducible points nk = count end subroutine apply_energy_window subroutine fbz_blocks_quantities ( indexlist , energies , velocities ) !! Subroutine to find FBZ quanties the lie within the Fermi window. integer ( i64 ), intent ( in ) :: indexlist (:) real ( r64 ), allocatable , intent ( inout ) :: energies (:,:), velocities (:,:,:) integer ( i64 ) :: i , nk , numbands real ( r64 ), allocatable :: energies_tmp (:,:), velocities_tmp (:,:,:) nk = size ( indexlist ) numbands = size ( energies ( 1 ,:)) allocate ( energies_tmp ( nk , numbands ), velocities_tmp ( nk , numbands , 3 )) do i = 1 , nk energies_tmp ( i ,:) = energies ( indexlist ( i ),:) velocities_tmp ( i ,:,:) = velocities ( indexlist ( i ),:,:) end do deallocate ( energies , velocities ) allocate ( energies ( nk , numbands ), velocities ( nk , numbands , 3 )) energies ( 1 : nk , :) = energies_tmp ( 1 : nk , :) velocities ( 1 : nk , :, :) = velocities_tmp ( 1 : nk , :, :) end subroutine fbz_blocks_quantities subroutine calculate_carrier_conc ( self , T , vol , h ) !! Subroutine to calculate the band resolved carrier concentration !! for a given chemical potential and temperature. class ( electron ), intent ( inout ) :: self real ( r64 ), intent ( in ) :: T , vol real ( r64 ), intent ( in ), optional :: h !Local variables real ( r64 ) :: const integer ( i64 ) :: ib , ik !Allocate conc allocate ( self % conc ( self % numbands )) self % conc = 0.0_r64 self % conc_el = 0.0_r64 self % conc_hole = 0.0_r64 !Normalization and units factor const = self % spindeg / dble ( product ( self % wvmesh )) / vol / ( 1.0e-21_r64 ) do ik = 1 , self % nwv !Electron concentration !By convention, the electron carrier concentration will have a negative sign. if ( self % indlowconduction > 0 ) then !Calculation includes conduction bands do ib = self % indlowconduction , self % indhighband !Conduction bands manifold self % conc ( ib ) = self % conc ( ib ) - Fermi ( self % ens ( ik , ib ), self % chempot , T ) end do !Total electron concentration self % conc_el = abs ( sum ( self % conc ( self % indlowconduction : self % indhighband ))) end if !Hole concentration !By convention, the hole carrier concentration will have a positive sign. if ( self % indhighvalence > 0 ) then !Calculation includes valence bands do ib = self % indlowband , self % indhighvalence !Valence bands manifold self % conc ( ib ) = self % conc ( ib ) + ( 1.0_r64 - Fermi ( self % ens ( ik , ib ), self % chempot , T )) end do !Total hole concentration self % conc_hole = sum ( self % conc ( self % indlowband : self % indhighvalence )) end if end do self % conc = self % conc * const !cm&#94;-3 self % conc_el = self % conc_el * const !cm&#94;-3 self % conc_hole = self % conc_hole * const !cm&#94;-3 !If h is present that means the system is 2d if ( present ( h )) then self % conc = self % conc * h * 1.0e-7_r64 !cm&#94;-2 self % conc_el = self % conc_el * h * 1.0e-7_r64 !cm&#94;-2 self % conc_hole = self % conc_hole * h * 1.0e-7_r64 !cm&#94;-2 end if end subroutine calculate_carrier_conc subroutine calculate_chempot ( self , vol , dopingtype , Tlist , conclist , h ) !! Subroutine to calculate the chemical potential for a !! given carrier concentration. class ( electron ), intent ( in ) :: self real ( r64 ), intent ( in ) :: vol , Tlist (:), conclist (:) character ( len = 1 ), intent ( in ) :: dopingtype real ( r64 ), intent ( in ), optional :: h !Local variables integer ( i64 ) :: ib , ik , it , ngrid , maxiter , itemp , iconc , & high , low , numtemp , numconc real ( r64 ) :: a , b , aux , const , mu , thresh real ( r64 ), allocatable :: chempot (:,:) call print_message ( \"Calculating chemical potential...\" ) !Number of temperature points numtemp = size ( Tlist ) !Number of cocentration points numconc = size ( conclist ) !Allocate chemical potential array allocate ( chempot ( numtemp , numconc )) chempot = - 9 9.99_r64 !Total number of points in full mesh ngrid = product ( self % wvmesh ) !Normalization and units factor const = self % spindeg / dble ( ngrid ) / vol / ( 1.0e-21_r64 ) if ( present ( h )) then !2d system const = const * h * 1.0e-7_r64 end if !Maximum number of iterations maxiter = 5000 !Convergence threshold thresh = 1.0e-12_r64 !Check doping type if ( dopingtype == 'n' ) then low = self % indlowconduction high = self % indhighband else low = self % indlowband high = self % indhighvalence end if if ( this_image () == 1 . and . (. not . self % metallic ) ) then write ( * , \"(A, 1E16.8, A)\" ) 'Maximum energy valence band = ' , & maxval ( self % ens_irred (:, self % indlowconduction - 1 )) , ' eV' write ( * , \"(A, 1E16.8, A)\" ) 'Minimum energy conduction band = ' , & minval ( self % ens_irred (:, self % indlowconduction )), ' eV' if ( any ( self % scissor . ne . 0.0_r64 )) then write ( * , \"(A, 1E16.8,A)\" ) 'Scissor operator applied at CBs = ' , maxval ( self % scissor ), 'eV' write ( * , \"(A, 1E16.8, A)\" ) 'Minimum uncorrected energy conduction band = ' , & minval ( self % ens_irred (:, self % indlowconduction )) - self % scissor , ' eV' end if write ( * , \"(A, 1E16.8, A)\" ) 'Band gap = ' , & minval ( self % ens_irred (:, self % indlowconduction )) - & maxval ( self % ens_irred (:, self % indlowconduction - 1 )) , ' eV' end if !Loop over temperatures do itemp = 1 , numtemp if ( this_image () == 1 ) then write ( * , \"(A, F7.2, A)\" ) 'Crystal temperature = ' , Tlist ( itemp ), ' K:' if ( present ( h )) then !2d system write ( * , \"(A)\" ) 'Carrier conc. [cm&#94;-2]    Chemical potential [eV]' else write ( * , \"(A)\" ) 'Carrier conc. [cm&#94;-3]    Chemical potential [eV]' end if end if !Loop over concentrations do iconc = 1 , numconc if ( dopingtype == 'n' ) then a = self % enref - 1 2.0_r64 !guess lower bound b = self % enref + 1 2.0_r64 !guess upper bound else a = self % enref + 1 2.0_r64 !guess lower bound b = self % enref - 1 2.0_r64 !guess upper bound end if do it = 1 , maxiter mu = 0.5_r64 * ( a + b ) aux = 0.0_r64 do ib = low , high do ik = 1 , self % nwv if ( dopingtype == 'n' ) then aux = aux + Fermi ( self % ens ( ik , ib ), mu , Tlist ( itemp )) else aux = aux + 1.0_r64 - Fermi ( self % ens ( ik , ib ), mu , Tlist ( itemp )) end if end do end do aux = aux * const !cm&#94;-3 for 3d, cm&#94;-2 for 2d if ( abs ( aux - conclist ( iconc )) / conclist ( iconc ) < thresh ) then exit else if ( aux < conclist ( iconc )) then a = mu else b = mu end if end do chempot ( itemp , iconc ) = mu if ( abs ( aux - conclist ( iconc )) / conclist ( iconc ) > thresh ) then call exit_with_message (& \"Could not converge to correct chemical potential. Exiting.\" ) end if if ( this_image () == 1 ) then write ( * , \"(1E16.8, A, 1E16.8)\" ) conclist ( iconc ), '         ' , chempot ( itemp , iconc ) end if end do end do end subroutine calculate_chempot subroutine deallocate_eigenvecs ( self ) !! Deallocate the electron eigenvectors class ( electron ), intent ( inout ) :: self deallocate ( self % evecs , self % evecs_irred ) sync all end subroutine deallocate_eigenvecs end module electron_module","tags":"","loc":"sourcefile/electron.f90.html"},{"title":"green.f90 – elphbolt","text":"Contents Modules Green_function Source Code green.f90 Source Code ! Copyright (C) 2022- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module Green_function !! Module containing Green's function related procedures. use params , only : i64 , r64 , pi , oneI , twopi , hbar_eVps use electron_module , only : electron use phonon_module , only : phonon use crystal_module , only : crystal use delta , only : delta_fn_tetra , real_tetra use misc , only : exit_with_message , distribute_points , expi , demux_state , invert , & write2file_rank2_real , kronecker , mux_state implicit none private public calculate_retarded_phonon_D0 contains complex ( r64 ) function resolvent ( species , ib , iwv , sampling_point ) !! Calculate the resolvant !!   electron: 1/[z - E(k)], lim z -> E + i0&#94;{+}. !!   phonon:   1/[z - omega&#94;2(q)], lim z -> omega&#94;2 + i0&#94;{+}. !! !! species Object of particle type !! ib, iwv Band, wave vector indices !! sampling_point Sampling energy (or energy squared) in eV (or eV&#94;2), depending on particle type. class ( * ), intent ( in ) :: species integer ( i64 ), intent ( in ) :: ib , iwv real ( r64 ), intent ( in ) :: sampling_point !Local variables real ( r64 ) :: Im_resolvent , Re_resolvent select type ( species ) class is ( phonon ) !Imaginary part of resolvent Im_resolvent = - pi * delta_fn_tetra ( sampling_point , iwv , ib , species % wvmesh , species % tetramap , & species % tetracount , species % tetra_squared_evals ) !Real part of resolvent Re_resolvent = real_tetra ( sampling_point , iwv , ib , species % wvmesh , species % tetramap , & species % tetracount , species % tetra_squared_evals ) class is ( electron ) !Imaginary part of resolvent Im_resolvent = - pi * delta_fn_tetra ( sampling_point , iwv , ib , species % wvmesh , species % tetramap , & species % tetracount , species % tetra_evals ) !Real part of resolvent Re_resolvent = real_tetra ( sampling_point , iwv , ib , species % wvmesh , species % tetramap , & species % tetracount , species % tetra_evals ) class default call exit_with_message (& \"Unknown particle species in resolvent. Exiting.\" ) end select resolvent = Re_resolvent + oneI * Im_resolvent end function resolvent subroutine calculate_retarded_phonon_D0 ( ph , crys , def_supercell_cell_pos_intvec , & pcell_atom_label , D0 , dimp_cell_pos_intvec , pcell_atom_dof ) !! Parallel driver of the retarded, bare phonon Green's function, D0, over !! the IBZ states. !! !! ph Phonon object !! crys Crystal object !! def_supercell_cell_pos_intvec Positions of unitcells (integer 3 vector) in the defective supercell !! pcell_atom_label Primitive cell equivalence of atom labels in the defective supercell !! D0 Green's function type ( phonon ), intent ( in ) :: ph type ( crystal ), intent ( in ) :: crys integer ( i64 ), intent ( in ) :: def_supercell_cell_pos_intvec (:, :) integer ( i64 ), intent ( in ) :: pcell_atom_label (:) integer ( i64 ), intent ( in ) :: dimp_cell_pos_intvec (:, :), pcell_atom_dof (:) complex ( r64 ), allocatable , intent ( out ) :: D0 (:, :, :) !Local variables integer ( i64 ) :: nstates_irred , chunk , start , end , num_active_images , & istate1 , s1 , iq1_ibz , iq1 , s2 , iq2 , i , j , num_dof_def , a , dof_counter , iq , & tau_sc , tau_uc , def_numatoms , def_numcells , atom , cell real ( r64 ) :: en1_sq , q_cart ( 3 ) complex ( r64 ) :: d0_istate , phase , ev ( ph % numbands , ph % numbands ), dos ( ph % nwv_irred , ph % numbands ) complex ( r64 ), allocatable :: phi (:, :, :), phi_internal (:) !Total number of atoms in the defective block of the supercell def_numatoms = size ( pcell_atom_label ) !Total number of IBZ blocks states nstates_irred = ph % nwv_irred * ph % numbands !Total number of degrees of freedom in defective supercell num_dof_def = def_numatoms * 3 !Number of primitive unit cells in the defective supercell def_numcells = num_dof_def / crys % numatoms / 3 allocate ( phi ( num_dof_def , ph % numbands , ph % nwv ), phi_internal ( num_dof_def ), & D0 ( num_dof_def , num_dof_def , nstates_irred )) !Precompute the defective supercell eigenfunctions do iq = 1 , ph % nwv !This phonon eigenvector ev = ph % evecs ( iq , :, :) do dof_counter = 1 , num_dof_def phase = expi ( & twopi * dot_product ( ph % wavevecs ( iq , :), & dimp_cell_pos_intvec (:, dof_counter )) ) phi ( dof_counter , :, iq ) = & phase * ev (:, pcell_atom_dof ( dof_counter )) end do end do !Divide phonon states among images call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) !Initialize D0 D0 = 0.0_r64 !Run over first (IBZ) phonon states do istate1 = start , end !Demux state index into branch (s) and wave vector (iq) indices call demux_state ( istate1 , ph % numbands , s1 , iq1_ibz ) !Muxed index of wave vector from the IBZ index list. !This will be used to access IBZ information from the FBZ quantities. !Recall that for the phonons, unlike for the electrons, we don't save these IBZ info separately. iq1 = ph % indexlist_irred ( iq1_ibz ) !Squared energy of phonon 1 en1_sq = ph % ens ( iq1 , s1 ) ** 2 !Sum over internal (FBZ) phonon wave vectors do iq2 = 1 , ph % nwv !Sum over internal phonon bands do s2 = 1 , ph % numbands phi_internal (:) = phi (:, s2 , iq2 ) d0_istate = resolvent ( ph , s2 , iq2 , en1_sq ) do j = 1 , num_dof_def D0 (:, j , istate1 ) = D0 (:, j , istate1 ) + & d0_istate * phi_internal (:) * conjg ( phi_internal ( j )) end do end do end do end do !Reduce D0 sync all call co_sum ( D0 ) sync all !!$    !Sanity check: print DOS !!$    dos = 0.0_r64 !!$    do istate1 = start, end !!$       !Demux state index into branch (s) and wave vector (iq) indices !!$       call demux_state(istate1, ph%numbands, s1, iq1_ibz) !!$ !!$       iq1 = ph%indexlist_irred(iq1_ibz) !!$ !!$       do i = 1, num_dof_def !!$          dos(iq1_ibz, s1) = dos(iq1_ibz, s1) + & !!$               D0(i, i, istate1) !!$       end do !!$ !!$       dos(iq1_ibz, s1) = dos(iq1_ibz, s1)*ph%ens(iq1, s1) !!$    end do !!$ !!$    !Reduce dos !!$    sync all !!$    call co_sum(dos) !!$    sync all !!$ !!$    call write2file_rank2_real(ph%prefix // '.D0test_'//ph%prefix//'dos', imag(-2.0/pi*dos)) !!$    sync all !!$    !! end subroutine calculate_retarded_phonon_D0 end module Green_function","tags":"","loc":"sourcefile/green.f90.html"},{"title":"phonon_defect.f90 – elphbolt","text":"Contents Modules phonon_defect_module Source Code phonon_defect.f90 Source Code ! Copyright (C) 2022- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module phonon_defect_module !! Module containing phonon defect related data type and procedures. use params , only : i64 , r64 , hbar_eVps , twopi , pi use misc , only : exit_with_message , subtitle , demux_vector , twonorm , write2file_rank2_real , & kronecker , expi , demux_state , invert , distribute_points , mux_state use crystal_module , only : crystal use phonon_module , only : phonon implicit none private public phonon_defect type :: phonon_defect !! Data and procedures related to phonon defects. real ( r64 ) :: range !! Radius of the defect in nm. This defines a block of cells in the defective supercell. integer ( i64 ) :: numcells !! Number of cells in the defective supercell block. integer ( i64 ) :: numhosts !! Number of host sites in the unit cell. This can't exceed the number of unique elements. integer ( i64 ), allocatable :: cell_pos_intvec (:, :), dimp_cell_pos_intvec (:, :) !! Unitcell positions as 0-based integer triplets in the defective supercell block. integer ( i64 ), allocatable :: pcell_atom_label (:) !! Primitive cell equivalence (integer label) of atoms in the defective supercell block. integer ( i64 ), allocatable :: pcell_atom_dof (:) !! Primitive cell equivalent atomic degree of freedom. real ( r64 ), allocatable :: V_mass (:) !! On-site mass defect potential. real ( r64 ), allocatable :: V_bond (:, :) !! General space-dependent, pairwise defect potential. complex ( r64 ), allocatable :: D0 (:, :, :) !! Retarded, bare Green's function defined on the defect space. logical mass_defect !! Choose if mass defect is going to be used. character ( len = 100 ) :: approx !! Approximation of scattering T-matrix. contains procedure , public :: initialize , calculate_phonon_Tmatrix procedure , private :: calculate_phonon_Tmatrix_host end type phonon_defect contains subroutine initialize ( self , ph , crys ) !! Initialize the phonon defect data type. class ( phonon_defect ), intent ( out ) :: self type ( phonon ), intent ( in ) :: ph type ( crystal ), intent ( in ) :: crys !Local variables real ( r64 ) :: range logical :: mass_defect integer ( i64 ) :: cell , atom , cell_count , cell_intvec ( 3 ), & supercell_numatoms , atom_count , supercell_cell_pos_intvec ( 3 , product ( ph % scell )), & uc_dof_count , sc_dof_count , a character ( len = 100 ) :: approx namelist / phonon_defect / mass_defect , range , approx call subtitle ( \"Setting up phonon defect...\" ) mass_defect = . false . range = 0.0_r64 approx = 'full Born' !Read defect input open ( 1 , file = 'input.nml' , status = 'old' ) read ( 1 , nml = phonon_defect ) if ( mass_defect . and . range < 0 ) then call exit_with_message ( \"Must provide non-zero range (in nm) of defect.\" ) end if if (. not . ( approx . eq . 'lowest order' . or . & approx . eq . '1st Born' . or . & approx . eq . 'full Born' ) ) then call exit_with_message (& \"T-matrix approximation must be either 'lowest order', '1st Born', or 'full Born.'\" ) end if self % mass_defect = mass_defect self % range = range !nm self % approx = approx !Apply defect radius cell_count = 0 do cell = 1 , product ( ph % scell ) !Demultiplex cell index into an 0-based integer triplet !giving the coordinates of a cell in the supercell. call demux_vector ( cell , cell_intvec , ph % scell , 0_i64 ) !cell_intvec = cell_intvec - ph%scell/2 !If position of cell is within range, then keep it. if ( distance_from_origin ( cell_intvec , ph % scell , crys % lattvecs ) <= range ) then cell_count = cell_count + 1 supercell_cell_pos_intvec (:, cell_count ) = cell_intvec end if end do self % numcells = cell_count allocate ( self % cell_pos_intvec ( 3 , self % numcells )) self % cell_pos_intvec (:, 1 : self % numcells ) = & supercell_cell_pos_intvec (:, 1 : self % numcells ) !Number of atoms in the defective block of the supercell supercell_numatoms = self % numcells * crys % numatoms !Calculate defective supercell block atomic positions and !primitive cell equivalent atom labels. allocate ( self % pcell_atom_label ( supercell_numatoms )) allocate ( self % pcell_atom_dof ( supercell_numatoms * 3 )) allocate ( self % dimp_cell_pos_intvec ( 3 , supercell_numatoms * 3 )) atom_count = 0 sc_dof_count = 0 do cell = 1 , self % numcells uc_dof_count = 0 do atom = 1 , crys % numatoms atom_count = atom_count + 1 self % pcell_atom_label ( atom_count ) = atom do a = 1 , 3 uc_dof_count = uc_dof_count + 1 sc_dof_count = sc_dof_count + 1 self % pcell_atom_dof ( sc_dof_count ) = uc_dof_count self % dimp_cell_pos_intvec (:, sc_dof_count ) = self % cell_pos_intvec (:, cell ) end do end do end do if ( this_image () == 1 ) then write ( * , \"(A, A)\" ) 'T-matrix approximation level: ' , self % approx write ( * , \"(A, F7.2, A)\" ) 'Defect range = ' , self % range , ' nm' if ( self % mass_defect ) write ( * , \"(A)\" ) 'On-site mass-defect scattering will be used.' end if end subroutine initialize pure real ( r64 ) function distance_from_origin ( cell_intvec , scell , lattvecs ) !! Function to calculate the minimum distance (nm) of a vector measured from !! the origin of a supercell. integer ( i64 ), intent ( in ) :: cell_intvec ( 3 ), scell ( 3 ) real ( r64 ), intent ( in ) :: lattvecs ( 3 , 3 ) !Local variables real ( r64 ) :: distance_from_origins ( 5 ** 3 ), supercell_lattvecs ( 3 , 3 ) integer ( i64 ) :: i , j , k , count !Calculate supercell lattice vectors do i = 1 , 3 supercell_lattvecs (:, i ) = scell ( i ) * lattvecs (:, i ) end do !Calculate the distance in the images of the central supercell count = 0 do i = - 2 , 2 do j = - 2 , 2 do k = - 2 , 2 count = count + 1 distance_from_origins ( count ) = twonorm (& matmul ( supercell_lattvecs , cell_intvec / dble ( scell ) - [ i , j , k ])) end do end do end do !Return the minimum distance distance_from_origin = minval ( distance_from_origins ) end function distance_from_origin subroutine calculate_phonon_Tmatrix ( self , ph , crys ) class ( phonon_defect ), intent ( inout ) :: self type ( phonon ), intent ( in ) :: ph type ( crystal ), intent ( in ) :: crys integer ( i64 ) :: host , ik , i , j , dopant , atom real ( r64 ) :: def_frac real ( r64 ), allocatable :: scatt_rates (:, :), renorm_ens (:, :), lineshifts (:, :) complex ( r64 ), allocatable :: irred_diagT (:, :, :) real ( r64 ) :: V_mass_iso ( crys % numelements ) integer ( i64 ) :: num_atomtypes ( crys % numelements ) num_atomtypes (:) = 0_i64 do i = 1 , crys % numelements do j = 1 , crys % numatoms if ( crys % atomtypes ( j ) == i ) num_atomtypes ( i ) = num_atomtypes ( i ) + 1 end do end do allocate ( irred_diagT ( ph % nwv_irred , ph % numbands , crys % numelements )) allocate ( scatt_rates ( ph % nwv_irred , ph % numbands ), & lineshifts ( ph % nwv_irred , ph % numbands ), renorm_ens ( ph % nwv_irred , ph % numbands )) scatt_rates = 0.0_r64 lineshifts = 0.0_r64 if ( self % mass_defect ) then do host = 1 , crys % numelements do dopant = 1 , crys % numdopants_types ( host ) !dopants of this host atom V_mass_iso = 0.0_r64 V_mass_iso ( host ) = 1.0_r64 - crys % dopant_masses ( dopant , host ) / crys % masses ( host ) call self % calculate_phonon_Tmatrix_host ( ph , crys , host , & irred_diagT (:, :, host ), V_mass_iso ) def_frac = crys % dopant_conc ( dopant , host ) * ( 1.0e-21_r64 * crys % volume ) / num_atomtypes ( host ) do ik = 1 , ph % nwv_irred scatt_rates ( ik , :) = scatt_rates ( ik , :) + & def_frac * imag ( irred_diagT ( ik , :, host )) / ph % ens ( ph % indexlist_irred ( ik ), :) lineshifts ( ik , :) = lineshifts ( ik , :) + & + def_frac * real ( irred_diagT ( ik , :, host )) end do end do end do end if scatt_rates = - scatt_rates / hbar_eVps do ik = 1 , ph % nwv_irred renorm_ens ( ik , :) = sqrt ( ph % ens ( ph % indexlist_irred ( ik ), :) ** 2 + & + lineshifts ( ik , :)) end do !Deal with Gamma point acoustic phonons scatt_rates ( 1 , 1 : 3 ) = 0.0_r64 !Write to file call write2file_rank2_real ( ph % prefix // '.W_rta_' // ph % prefix // 'defect' , scatt_rates ) !call write2file_rank2_real(ph%prefix // '.lineshifts_ibz_'//ph%prefix//'defect', lineshifts) call write2file_rank2_real ( ph % prefix // '.ens_renorm_ibz_' // ph % prefix // 'defect' , renorm_ens ) end subroutine calculate_phonon_Tmatrix subroutine calculate_phonon_Tmatrix_host ( self , ph , crys , host_atom_type , diagT , V_mass ) !! Parallel calculator of the scattering T-matrix for phonons for a given approximation. !! !! D0 Retarded, bare Green's function in real space !! V_mass On-site scattering potential in real space !! diagT Diagonoal of the scattering T-matrix in reciprocal space !! approx Approximation for the scattering theory class ( phonon_defect ), intent ( in ) :: self type ( phonon ), intent ( in ) :: ph type ( crystal ), intent ( in ) :: crys complex ( r64 ), intent ( out ) :: diagT (:, :) real ( r64 ), intent ( in ) :: V_mass ( crys % numelements ) integer ( i64 ), intent ( in ) :: host_atom_type !Local variables integer ( i64 ) :: num_dof_def , numstates_irred , istate , & chunk , start , end , num_active_images , i , a , def_numatoms , & dof_counter , iq , s , cell , atom complex ( r64 ), allocatable :: inv_one_minus_VD0 (:, :), T (:, :, :), phi (:) real ( r64 ), allocatable :: V (:, :), identity (:, :) complex ( r64 ) :: phase , ev ( ph % numbands ) real ( r64 ) :: en_sq , val !Displacement degrees of freedom in the defective supercell num_dof_def = size ( self % D0 , 1 ) !Number of atoms in the defective block of the supercell def_numatoms = num_dof_def / 3 !Number of irreducible phonon states numstates_irred = ph % nwv_irred * ph % numbands allocate ( T ( num_dof_def , num_dof_def , numstates_irred )) allocate ( V ( num_dof_def , num_dof_def )) T = 0.0_r64 V = 0.0_r64 allocate ( identity ( num_dof_def , num_dof_def )) identity = 0.0_r64 do i = 1 , num_dof_def identity ( i , i ) = 1.0_r64 end do if ( self % approx == 'full Born' ) allocate ( inv_one_minus_VD0 ( num_dof_def , num_dof_def )) !Divide phonon states among images call distribute_points ( numstates_irred , chunk , start , end , num_active_images ) do istate = start , end !Demux state index into branch (s) and wave vector (iq) indices call demux_state ( istate , ph % numbands , s , iq ) !Squared energy of phonon 1 en_sq = ph % ens ( ph % indexlist_irred ( iq ), s ) ** 2 !Scale the mass perturbation with squared energy. dof_counter = 0 do cell = 1 , self % numcells do atom = 1 , crys % numatoms !Number of atoms in the unit cell val = en_sq * V_mass ( crys % atomtypes ( atom )) do a = 1 , 3 !Cartesian directions dof_counter = dof_counter + 1 !Since on-site mass perturbation is forced to be in the central unit cell, !only these elements of V get a non-zero contribution. if ( all ( self % cell_pos_intvec (:, cell ) == 0 )) then V ( dof_counter , dof_counter ) = val end if end do end do end do select case ( self % approx ) case ( 'lowest order' ) ! Lowest order: ! T = V ! !    * !    | !  V | !    | ! T (:, :, istate ) = V case ( '1st Born' ) ! 1st Born approximation: ! T = V + V.D0.V ! !    *             * !    |            / \\ !  V |     +     /   \\ !    |          /_____\\ !                 D0 ! T (:, :, istate ) = V + matmul ( V , matmul ( self % D0 (:, :, istate ), V )) case ( 'full Born' ) ! Full Born approximation: ! T = V + V.D0.T = [I - VD0]&#94;-1 . V !                              _                                      _ !    *             *          |    *         *            *            | !    |            /           |    |        / \\          /|\\           | !  V |     +     /       x    |    |   +   /   \\   +    / | \\  +  ...  | !    |          /_____        |_   |      /_____\\      /__|__\\        _| !                 D0 ! inv_one_minus_VD0 = identity - matmul ( V , self % D0 (:, :, istate )) call invert ( inv_one_minus_VD0 ) T (:, :, istate ) = matmul ( inv_one_minus_VD0 , V ) case default call exit_with_message ( \"T-matrix approximation not recognized.\" ) end select end do !Reduce T sync all call co_sum ( T ) sync all !Release some memory deallocate ( V , identity ) if ( allocated ( inv_one_minus_VD0 )) deallocate ( inv_one_minus_VD0 ) !Calculate diagonal T in reciprocal space. allocate ( phi ( num_dof_def )) diagT = 0.0_r64 !Optical theorem do istate = start , end !Demux state index into branch (s) and wave vector (iq) indices call demux_state ( istate , ph % numbands , s , iq ) !This phonon eigenvector ev = ph % evecs ( ph % indexlist_irred ( iq ), s , :) do dof_counter = 1 , num_dof_def phase = expi ( & twopi * dot_product ( ph % wavevecs_irred ( iq , :), & self % dimp_cell_pos_intvec (:, dof_counter )) ) phi ( dof_counter ) = phase * ev ( self % pcell_atom_dof ( dof_counter )) end do !<i|T|j> --> <sq|T|sq> diagT ( iq , s ) = dot_product ( phi , matmul ( T (:, :, istate ), phi )) end do !Reduce T sync all call co_sum ( diagT ) sync all end subroutine calculate_phonon_Tmatrix_host end module phonon_defect_module","tags":"","loc":"sourcefile/phonon_defect.f90.html"},{"title":"delta.f90 – elphbolt","text":"Contents Modules delta Source Code delta.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module delta !! Module containing the procedures related to delta function evaulation. use params , only : r64 , i64 use misc , only : exit_with_message , print_message , demux_vector , mux_vector , & binsearch , sort implicit none private public form_tetrahedra_3d , fill_tetrahedra_3d , delta_fn_tetra , & form_triangles , fill_triangles , delta_fn_triang , real_tetra contains pure real ( r64 ) function delta_fn_tetra ( e , ik , ib , mesh , tetramap , tetracount , tetra_evals ) !! Calculate delta function using the tetraheron method. !! !! e Sample energy !! ik Wave vector index !! ib Band index !! mesh Wave vector grid !! tetramap Wave vector to (tetrahedron, vertex) mapping !! tetracount Number of tetrahedra in which a wave vector belongs !! tetra_evals Tetrahedra populated with the eigenvalues real ( r64 ), intent ( in ) :: e integer ( i64 ), intent ( in ) :: ik , ib integer ( i64 ), intent ( in ) :: mesh ( 3 ), tetramap (:,:,:), tetracount (:) real ( r64 ), intent ( in ) :: tetra_evals (:,:,:) !Local variables integer ( i64 ) :: iv , it , itk , num , numtetra logical :: c1 , c2 , c3 real ( r64 ) :: e1 , e2 , e3 , e4 , e1e , e2e , e3e , e4e , & e21 , e31 , e41 , e32 , e42 , e43 , tmp ! eji \\equiv ej - ei tmp = 0.0_r64 delta_fn_tetra = 0.0_r64 !Total number of tetrahedra in the system numtetra = product ( mesh ) * 6 !Grab number of tetrahedra in which wave vector belongs num = tetracount ( ik ) do itk = 1 , num !Run over tetrahedra it = tetramap ( 1 , ik , itk ) !Grab tetrahedron iv = tetramap ( 2 , ik , itk ) !Grab vertex !Grab vertex energies e1 = tetra_evals ( it , ib , 1 ) e2 = tetra_evals ( it , ib , 2 ) e3 = tetra_evals ( it , ib , 3 ) e4 = tetra_evals ( it , ib , 4 ) !Define the energy differences e1e = e1 - e e2e = e2 - e e3e = e3 - e e4e = e4 - e e21 = e2 - e1 e31 = e3 - e1 e41 = e4 - e1 e32 = e3 - e2 e42 = e4 - e2 e43 = e4 - e3 !Evaluate the three cases c1 = e1 <= e . and . e <= e2 c2 = e2 <= e . and . e <= e3 c3 = e3 <= e . and . e <= e4 if (. not . ( e < e1 . or . e > e4 )) then !Evaluate the expressions for the three cases select case ( iv ) case ( 1 ) if ( c1 ) then tmp = ( e2e / e21 + e3e / e31 + e4e / e41 ) * ( e1e ** 2 ) / e41 / e31 / e21 if ( e1 == e2 ) then tmp = 0.0_r64 end if else if ( c2 ) then tmp = - 0.5_r64 * ( e3e / ( e31 ** 2 ) * ( e3e * e2e / e42 / e32 + e4e * e1e / e41 / e42 + e3e * e1e / e32 / e41 ) & + e4e / ( e41 ** 2 ) * ( e4e * e1e / e42 / e31 + e4e * e2e / e42 / e32 + e3e * e1e / e31 / e32 )) if ( e2 == e3 ) then tmp = - 0.5_r64 * ( e4e * e1e / e41 / e42 + e1e / e41 & + e4e / ( e41 ** 2 ) * ( e4e * e1e / e42 / e31 + e4e / e42 + e1e / e31 )) end if else if ( c3 ) then tmp = ( e4e ** 3 ) / ( e41 ** 2 ) / e42 / e43 if ( e3 == e4 ) then tmp = ( e4e ** 2 ) / ( e41 ** 2 ) / e42 end if end if case ( 2 ) if ( c1 ) then tmp = - ( e1e ** 3 ) / ( e21 ** 2 ) / e31 / e41 if ( e1 == e2 ) then tmp = 0.0_r64 end if else if ( c2 ) then tmp = - 0.5_r64 * ( e3e / ( e32 ** 2 ) * ( e3e * e2e / e42 / e31 + e4e * e2e / e42 / e41 + e3e * e1e / e31 / e41 ) & + e4e / ( e42 ** 2 ) * ( e3e * e2e / e32 / e31 + e4e * e1e / e41 / e31 + e4e * e2e / e32 / e41 )) if ( e2 == e3 ) then tmp = - 0.5_r64 * ( 0.0 + e4e / e42 / e41 + 0.0 & + e4e / ( e42 ** 2 ) * ( 0.0 + e4e * e1e / e41 / e31 + 1.0 )) end if else if ( c3 ) then tmp = ( e4e ** 3 ) / e41 / ( e42 ** 2 ) / e43 if ( e3 == e4 ) then tmp = 0.0_r64 end if end if case ( 3 ) if ( c1 ) then tmp = - ( e1e ** 3 ) / e21 / ( e31 ** 2 ) / e41 if ( e1 == e2 ) then tmp = 0.0_r64 end if else if ( c2 ) then tmp = 0.5_r64 * ( e2e / ( e32 ** 2 ) * ( e3e * e2e / e42 / e31 + e4e * e2e / e42 / e41 + e3e * e1e / e31 / e41 ) & + e1e / ( e31 ** 2 ) * ( e3e * e2e / e42 / e32 + e4e * e1e / e41 / e42 + e3e * e1e / e32 / e41 )) if ( e2 == e3 ) then tmp = 0.5_r64 * ( 0.0 + e4e / e42 / e41 + e1e / e31 / e41 & + e1e / ( e31 ** 2 ) * ( 0.0 + e4e * e1e / e41 / e42 + e1e / e41 )) end if else if ( c3 ) then tmp = ( e4e ** 3 ) / e41 / e42 / ( e43 ** 2 ) if ( e3 == e4 ) then tmp = 0.0_r64 end if end if case ( 4 ) if ( c1 ) then tmp = - ( e1e ** 3 ) / e21 / e31 / ( e41 ** 2 ) if ( e1 == e2 ) then tmp = 0.0_r64 end if else if ( c2 ) then tmp = 0.5_r64 * ( e2e / ( e42 ** 2 ) * ( e3e * e2e / e32 / e31 + e4e * e1e / e41 / e31 + e4e * e2e / e32 / e41 ) & + e1e / ( e41 ** 2 ) * ( e4e * e1e / e42 / e31 + e4e * e2e / e42 / e32 + e3e * e1e / e31 / e32 )) if ( e2 == e3 ) then tmp = 0.5_r64 * ( 0.0 & + e1e / ( e41 ** 2 ) * ( e4e * e1e / e42 / e31 + e4e / e42 + e1e / e31 )) end if else if ( c3 ) then tmp = - ( e3e / e43 + e2e / e42 + e1e / e41 ) * ( e4e ** 2 ) / e41 / e42 / e43 if ( e3 == e4 ) then tmp = 0.0_r64 end if end if end select if (( e1 == e2 ) . and . ( e1 == e3 ) . and . ( e1 == e4 ) . and . ( e == e1 )) then tmp = 0.25_r64 end if delta_fn_tetra = delta_fn_tetra + tmp end if ! .not. (e <= e1 .or. e >= e4) end do !itk if ( delta_fn_tetra < 1.0e-12_r64 ) delta_fn_tetra = 0.0_r64 !Normalize with the total number of tetrahedra delta_fn_tetra = delta_fn_tetra / numtetra end function delta_fn_tetra pure real ( r64 ) function real_tetra ( e , ik , ib , mesh , tetramap , tetracount , tetra_evals ) !! Calculate the real part of the matrix elements of the resolvent operator !! using the analytic tetraheron method. !! Lambin and Vigneron Phys. Rev. B 29 6 1984 Eqs. A3-A6 !! Note that typos in Eqs. A4 and A5 have been corrected. !! Here we use the expressions given in !! V. Eyert The Augmented Spherical Wave Method DOI 10.1007/978-3-642-25864-0. !! !! e Sample energy !! ik Wave vector index !! ib Band index !! mesh Wave vector grid !! tetramap Wave vector to (tetrahedron, vertex) mapping !! tetracount Number of tetrahedra in which a wave vector belongs !! tetra_evals Tetrahedra populated with the eigenvalues real ( r64 ), intent ( in ) :: e integer ( i64 ), intent ( in ) :: ik , ib integer ( i64 ), intent ( in ) :: mesh ( 3 ), tetramap (:,:,:), tetracount (:) real ( r64 ), intent ( in ) :: tetra_evals (:,:,:) !Local variables integer ( i64 ) :: iv , it , itk , num , numtetra logical :: c1 , c2 , c3 , c4 , c5 , c6 , c7 real ( r64 ) :: e0 , e1 , e2 , e3 , & ee0 , ee1 , ee2 , ee3 , & logabs_ee0 , logabs_ee1 , logabs_ee2 , logabs_ee3 , & e01 , e02 , e03 , e12 , e13 , e23 , tmp tmp = 0.0_r64 real_tetra = 0.0_r64 !Total number of tetrahedra in the system numtetra = product ( mesh ) * 6 !Grab number of tetrahedra in which wave vector belongs num = tetracount ( ik ) do itk = 1 , num !Run over tetrahedra it = tetramap ( 1 , ik , itk ) !Grab tetrahedron iv = tetramap ( 2 , ik , itk ) !Grab vertex !Grab vertex energies e0 = tetra_evals ( it , ib , 1 ) e1 = tetra_evals ( it , ib , 2 ) e2 = tetra_evals ( it , ib , 3 ) e3 = tetra_evals ( it , ib , 4 ) !Define the energy differences ee0 = e - e0 ee1 = e - e1 ee2 = e - e2 ee3 = e - e3 e01 = e0 - e1 e02 = e0 - e2 e03 = e0 - e3 e12 = e1 - e2 e13 = e1 - e3 e23 = e2 - e3 !Precalculate all the log(abs(e - e_vertex)) logabs_ee0 = 0.0_r64 if ( ee0 /= 0.0_r64 ) logabs_ee0 = log ( abs ( ee0 )) logabs_ee1 = 0.0_r64 if ( ee1 /= 0.0_r64 ) logabs_ee1 = log ( abs ( ee1 )) logabs_ee2 = 0.0_r64 if ( ee2 /= 0.0_r64 ) logabs_ee2 = log ( abs ( ee2 )) logabs_ee3 = 0.0_r64 if ( ee3 /= 0.0_r64 ) logabs_ee3 = log ( abs ( ee3 )) !Evaluate the seven cases c1 = e0 < e1 . and . e1 < e2 . and . e2 < e3 c2 = e0 == e1 . and . e1 < e2 . and . e2 < e3 c3 = e0 < e1 . and . e1 == e2 . and . e2 < e3 c4 = e0 < e1 . and . e1 < e2 . and . e2 == e3 c5 = e0 == e1 . and . e1 == e2 . and . e2 < e3 c6 = e0 == e1 . and . e1 < e2 . and . e2 == e3 c7 = e0 < e1 . and . e1 == e2 . and . e2 == e3 !Evaluate the expressions for the seven cases select case ( iv ) !tetrahedron vertex number case ( 1 ) if ( c1 ) then !Eq. 9.5.124 [x] tmp = - ee0 ** 2 / ( e01 * e02 * e03 ) & * ( 1.0_r64 + ( ee1 / e01 + ee2 / e02 + ee3 / e03 ) * logabs_ee0 ) & + ee1 ** 3 / ( e01 ** 2 * e12 * e13 ) * logabs_ee1 & - ee2 ** 3 / ( e02 ** 2 * e12 * e23 ) * logabs_ee2 & + ee3 ** 3 / ( e03 ** 2 * e13 * e23 ) * logabs_ee3 else if ( c2 ) then !Eq. 9.5.130 [x] tmp = eval_Eq9_5_130 () else if ( c3 ) then !Eq. 9.5.133 [x] tmp = - ee0 ** 2 / ( e01 ** 2 * e03 ) * ( 1.0_r64 + ( 2.0_r64 * ee1 / e01 + ee3 / e03 ) * logabs_ee0 ) & - ee1 ** 2 / ( e01 ** 2 * e13 ) * ( 1.0_r64 + ( - 2.0_r64 * ee0 / e01 + ee3 / e13 ) * logabs_ee1 ) & + ee3 ** 3 / ( e03 * e13 ) ** 2 * logabs_ee3 else if ( c4 ) then !Eq. 9.5.136 [x] tmp = - ee0 ** 2 / ( e02 ** 2 * e01 ) * ( 1.0_r64 + ( 2.0_r64 * ee2 / e02 + ee1 / e01 ) * logabs_ee0 ) & + ee2 ** 2 / ( e02 ** 2 * e12 ) * ( 1.0_r64 - ( 2.0_r64 * ee0 / e02 + ee1 / e12 ) * logabs_ee2 ) & + ee1 ** 3 / ( e01 * e12 ) ** 2 * logabs_ee1 else if ( c5 ) then !Eq. 9.5.139 [x] tmp = eval_Eq9_5_139 () else if ( c6 ) then !Eq. 9.5.141 [x] tmp = eval_Eq9_5_141 () else if ( c7 ) then !Eq. 9.5.143 [x] tmp = 3.0_r64 * ee0 ** 2 * ee1 / e01 ** 4 * ( logabs_ee1 - logabs_ee0 ) & - 1.5_r64 * ee1 * ( 2.0_r64 * ee0 - e01 ) / e01 ** 3 & - 1.0_r64 / e01 end if case ( 2 ) if ( c1 ) then !Eq. 9.5.125 [x] tmp = ee1 ** 2 / ( e01 * e12 * e13 ) & * ( 1.0_r64 + ( - ee0 / e01 + ee2 / e12 + ee3 / e13 ) * logabs_ee1 ) & + ee0 ** 3 / ( e01 ** 2 * e02 * e03 ) * logabs_ee0 & - ee2 ** 3 / ( e02 * e12 ** 2 * e23 ) * logabs_ee2 & + ee3 ** 3 / ( e03 * e13 ** 2 * e23 ) * logabs_ee3 else if ( c2 ) then !Eq. 9.5.130 [x] tmp = eval_Eq9_5_130 () else if ( c3 ) then !Eq. 9.5.134 [x] tmp = eval_Eq9_5_134 () else if ( c4 ) then !Eq. 9.5.137 [x] tmp = ee1 ** 2 / ( e12 ** 2 * e01 ) * ( 1.0_r64 + ( 2.0_r64 * ee2 / e12 - ee0 / e01 ) * logabs_ee1 ) & + ee2 ** 2 / ( e12 ** 2 * e02 ) * ( 1.0_r64 - ( 2.0_r64 * ee1 / e12 + ee0 / e02 ) * logabs_ee2 ) & + ee0 ** 3 / ( e01 * e02 ) ** 2 * logabs_ee0 else if ( c5 ) then !Eq. 9.5.139 [x] tmp = eval_Eq9_5_139 () else if ( c6 ) then !Eq. 9.5.141 [x] tmp = eval_Eq9_5_141 () else if ( c7 ) then !Eq. 9.5.144 [x] tmp = eval_Eq9_5_144 () end if case ( 3 ) if ( c1 ) then !Eq. 9.5.126 [x] tmp = - ee2 ** 2 / ( e02 * e12 * e23 ) & * ( 1.0_r64 + ( - ee0 / e02 - ee1 / e12 + ee3 / e23 ) * logabs_ee2 ) & + ee0 ** 3 / ( e01 * e02 ** 2 * e03 ) * logabs_ee0 & - ee1 ** 3 / ( e01 * e12 ** 2 * e13 ) * logabs_ee1 & + ee3 ** 3 / ( e03 * e13 * e23 ** 2 ) * logabs_ee3 else if ( c2 ) then !Eq. 9.5.131 [x] tmp = - ee2 ** 2 / ( e02 ** 2 * e23 ) * ( 1.0_r64 + ( - 2.0_r64 * ee0 / e02 + ee3 / e23 ) * logabs_ee2 ) & - ee0 ** 2 / ( e02 ** 2 * e03 ) * ( 1.0_r64 + ( 2.0_r64 * ee2 / e02 + ee3 / e03 ) * logabs_ee0 ) & + ee3 ** 3 / ( e23 * e03 ) ** 2 * logabs_ee3 else if ( c3 ) then !Eq. 9.5.134 [x] tmp = eval_Eq9_5_134 () else if ( c4 ) then !Eq. 9.5.138 [x] tmp = eval_Eq9_5_138 () else if ( c5 ) then !Eq. 9.5.139 [x] tmp = eval_Eq9_5_139 () else if ( c6 ) then !Eq. 9.5.142 [x] tmp = eval_Eq9_5_142 () else if ( c7 ) then !Eq. 9.5.144 [x] tmp = eval_Eq9_5_144 () end if case ( 4 ) if ( c1 ) then !Eq. 9.5.127 [x] tmp = ee3 ** 2 / ( e03 * e13 * e23 ) & * ( 1.0_r64 + ( - ee0 / e03 - ee1 / e13 - ee2 / e23 ) * logabs_ee3 ) & + ee0 ** 3 / ( e01 * e02 * e03 ** 2 ) * logabs_ee0 & - ee1 ** 3 / ( e01 * e12 * e13 ** 2 ) * logabs_ee1 & + ee2 ** 3 / ( e02 * e12 * e23 ** 2 ) * logabs_ee2 else if ( c2 ) then !Eq. 9.5.132 [x] tmp = ee3 ** 2 / ( e03 ** 2 * e23 ) * ( 1.0_r64 - ( 2.0_r64 * ee0 / e03 + ee2 / e23 ) * logabs_ee3 ) & - ee0 ** 2 / ( e03 ** 2 * e02 ) * ( 1.0_r64 + ( 2.0_r64 * ee3 / e03 + ee2 / e02 ) * logabs_ee0 ) & + ee2 ** 3 / ( e23 * e02 ) ** 2 * logabs_ee2 else if ( c3 ) then !Eq. 9.5.135 [x] tmp = ee3 ** 2 / ( e13 ** 2 * e03 ) * ( 1.0_r64 - ( 2.0_r64 * ee1 / e13 + ee0 / e03 ) * logabs_ee3 ) & + ee1 ** 2 / ( e13 ** 2 * e01 ) * ( 1.0_r64 + ( 2.0_r64 * ee3 / e13 - ee0 / e01 ) * logabs_ee1 ) & + ee0 ** 3 / ( e03 * e01 ) ** 2 * logabs_ee0 else if ( c4 ) then !Eq. 9.5. 138 [x] tmp = eval_Eq9_5_138 () else if ( c5 ) then !Eq. 9.5. 140 [x] tmp = 3.0_r64 * ee0 * ee3 ** 2 / e03 ** 4 * ( logabs_ee0 - logabs_ee3 ) & + 1.5_r64 * ee0 * ( 2.0_r64 * ee3 + e03 ) / e03 ** 3 & + 1.0_r64 / e03 else if ( c6 ) then !Eq. 9.5.142 [x] tmp = eval_Eq9_5_142 () else if ( c7 ) then !Eq. 9.5.144 [x] tmp = eval_Eq9_5_144 () end if end select if ( e0 == e1 . and . e1 == e2 . and . e2 == e3 ) tmp = 0.25_r64 / ee0 real_tetra = real_tetra + tmp end do !itk if ( real_tetra < 1.0e-12_r64 ) real_tetra = 0.0_r64 !Normalize with the total number of tetrahedra real_tetra = real_tetra / numtetra contains ![x] pure real ( r64 ) function eval_Eq9_5_130 () !! Right hand side of Eq. 9.5.130 of !! V. Eyert The Augmented Spherical Wave Method DOI 10.1007/978-3-642-25864-0. eval_Eq9_5_130 = - ee2 ** 3 / ( e23 * e02 ** 3 ) * logabs_ee2 & + ee3 ** 3 / ( e23 * e03 ** 3 ) * logabs_ee3 & + ee0 / ( e02 * e03 ) * ( 0.5_r64 + ee2 / e02 + ee3 / e03 & + (( ee2 / e02 ) ** 2 + ( ee3 / e03 ) ** 2 + ee2 * ee3 / ( e02 * e03 )) * logabs_ee0 ) end function eval_Eq9_5_130 ![x] pure real ( r64 ) function eval_Eq9_5_134 () !! Right hand side of Eq. 9.5.134 of !! V. Eyert The Augmented Spherical Wave Method DOI 10.1007/978-3-642-25864-0. eval_Eq9_5_134 = ee0 ** 3 / ( e03 * e01 ** 3 ) * logabs_ee0 & + ee3 ** 3 / ( e03 * e13 ** 3 ) * logabs_ee3 & - ee1 / ( e01 * e13 ) * ( 0.5_r64 - ee0 / e01 + ee3 / e13 + & (( ee0 / e01 ) ** 2 + ( ee3 / e13 ) ** 2 - ee0 * ee3 / ( e01 * e13 )) * logabs_ee1 ) end function eval_Eq9_5_134 ![x] pure real ( r64 ) function eval_Eq9_5_138 () !! Right hand side of Eq. 9.5.138 of !! V. Eyert The Augmented Spherical Wave Method DOI 10.1007/978-3-642-25864-0. eval_Eq9_5_138 = ee0 ** 3 / ( e01 * e02 ** 3 ) * logabs_ee0 & - ee1 ** 3 / ( e01 * e12 ** 3 ) * logabs_ee1 & + ee2 / ( e02 * e12 ) * ( 0.5_r64 - ee0 / e02 - ee1 / e12 + & (( ee0 / e02 ) ** 2 + ( ee1 / e12 ) ** 2 + ee0 * ee1 / ( e02 * e12 )) * logabs_ee2 ) end function eval_Eq9_5_138 ![x] pure real ( r64 ) function eval_Eq9_5_139 () !! Right hand side of Eq. 9.5.139 of !! V. Eyert The Augmented Spherical Wave Method DOI 10.1007/978-3-642-25864-0. eval_Eq9_5_139 = ee3 ** 3 / e03 ** 4 * ( logabs_ee3 - logabs_ee0 ) & - ( ee3 ** 2 + 0.5_r64 * ee3 * e03 + e03 ** 2 / 3.0_r64 ) / e03 ** 3 end function eval_Eq9_5_139 ![x] pure real ( r64 ) function eval_Eq9_5_141 () !! Right hand side of Eq. 9.5.141 of !! V. Eyert The Augmented Spherical Wave Method DOI 10.1007/978-3-642-25864-0. eval_Eq9_5_141 = 3.0_r64 * ee0 * ee2 ** 2 / e02 ** 4 * ( logabs_ee0 - logabs_ee2 ) & + 1.5_r64 * ee0 * ( 2.0_r64 * ee2 + e02 ) / e02 ** 3 & + 1.0_r64 / e02 end function eval_Eq9_5_141 ![x] pure real ( r64 ) function eval_Eq9_5_142 () !! Right hand side of Eq. 9.5.142 of !! V. Eyert The Augmented Spherical Wave Method DOI 10.1007/978-3-642-25864-0. eval_Eq9_5_142 = 3.0_r64 * ee0 ** 2 * ee2 / e02 ** 4 * ( logabs_ee2 - logabs_ee0 ) & - 1.5_r64 * ee2 * ( 2.0_r64 * ee0 - e02 ) / e02 ** 3 & - 1.0_r64 / e02 end function eval_Eq9_5_142 ![x] pure real ( r64 ) function eval_Eq9_5_144 () !! Right hand side of Eq. 9.5.144 of !! V. Eyert The Augmented Spherical Wave Method DOI 10.1007/978-3-642-25864-0. eval_Eq9_5_144 = ee0 ** 3 / e01 ** 4 * ( logabs_ee0 - logabs_ee1 ) & + ( ee0 ** 2 - 0.5_r64 * ee0 * e01 + e01 ** 2 / 3.0_r64 ) / e01 ** 3 end function eval_Eq9_5_144 end function real_tetra subroutine form_tetrahedra_3d ( nk , mesh , tetra , tetracount , tetramap , & blocks , indexlist ) !! Form all the tetrahedra of a 3d FBZ mesh. !! !! nk Number of points in the list of FBZ wave vectors !! mesh Wave vector grid !! tetra List of the tetrahedra vertices !! tetracount Number of tetrahedra in which a wave vector belongs !! tetramap Wave vector to (tetrahedron, vertex) mapping !! blocks Is the FBZ wave vector list full or energy restricted? !! indexlist List of muxed indices of the FBZ wave vectors integer ( i64 ), intent ( in ) :: nk , mesh ( 3 ) integer ( i64 ), intent ( out ), allocatable :: tetra (:,:), tetracount (:), tetramap (:,:,:) logical , intent ( in ) :: blocks integer ( i64 ), optional , intent ( in ) :: indexlist (:) !Local variables integer ( i64 ) :: ik , i , j , k , ijk ( 3 ), ii , jj , kk , tk , tl , aux , count integer ( i64 ) :: ip1 , jp1 , kp1 , n1 , n2 , n3 , tmp integer ( i64 ) :: tetra_vertices_labels ( 6 , 4 ) integer ( i64 ) :: scvol_vertices ( 8 , 3 ) ! subcell volume vertices n1 = mesh ( 1 ) n2 = mesh ( 2 ) n3 = mesh ( 3 ) !Label of the vertices of the tetrahedra for a given subcell tetra_vertices_labels = reshape (( / & 1 , 2 , 3 , 6 , & 1 , 3 , 5 , 6 , & 3 , 5 , 6 , 7 , & 3 , 6 , 7 , 8 , & 3 , 4 , 6 , 8 , & 2 , 3 , 4 , 6 / ), & shape ( tetra_vertices_labels ), order = ( / 2 , 1 / )) !Allocate tetrahedra related variables allocate ( tetra ( 6 * nk , 4 ), tetracount ( nk ), tetramap ( 2 , nk , 24 )) tetra (:,:) = 0 tetracount (:) = 0 tetramap (:,:,:) = 0 count = 1 !tetrahedron counter do ik = 1 , nk !Run over all wave vectors in FBZ if ( blocks ) then !For energy window restricted FBZ call demux_vector ( indexlist ( ik ), ijk , mesh , 1_i64 ) else !For unrestristed FBZ call demux_vector ( ik , ijk , mesh , 1_i64 ) end if i = ijk ( 1 ) j = ijk ( 2 ) k = ijk ( 3 ) !Apply periodic boundary condition if ( i == n1 ) then ip1 = 1 else ip1 = i + 1 end if if ( j == n2 ) then jp1 = 1 else jp1 = j + 1 end if if ( k == n3 ) then kp1 = 1 else kp1 = k + 1 end if !For each subcell save the vertices scvol_vertices = reshape (( / & i , j , k , & ip1 , j , k , & i , jp1 , k , & ip1 , jp1 , k , & i , j , kp1 , & ip1 , j , kp1 , & i , jp1 , kp1 , & ip1 , jp1 , kp1 / ), & shape ( scvol_vertices ), order = ( / 2 , 1 / )) do tk = 1 , 6 !Run over 6 tetrahedra do tl = 1 , 4 !Run over the labels of the vertices that !make up each tetrahedron aux = tetra_vertices_labels ( tk , tl ) ii = scvol_vertices ( aux , 1 ) jj = scvol_vertices ( aux , 2 ) kk = scvol_vertices ( aux , 3 ) aux = mux_vector (( / ii , jj , kk / ), mesh , 1_i64 ) tmp = aux !Guaranteed to be > 0 if ( blocks ) then !Which point in indexlist does aux correspond to? call binsearch ( indexlist , aux , tmp ) !tmp < 0 if search fails. end if tetra ( count , tl ) = tmp if ( tmp > 0 ) then !Save the mapping of a wave vector index to a (tetrahedron, vertex) tetracount ( tmp ) = tetracount ( tmp ) + 1 tetramap ( 1 , tmp , tetracount ( tmp )) = count tetramap ( 2 , tmp , tetracount ( tmp )) = tl end if end do count = count + 1 end do end do end subroutine form_tetrahedra_3d subroutine fill_tetrahedra_3d ( tetra , evals , tetra_evals ) !! Populate the (sorted along the vertices) eigenvalues on all the vertices of the tetrahedra !! !! tetra List of the tetrahedra vertices !! evals List of eigenvalues !! tetra_evals Tetrahedra populated with the eigenvalues integer ( i64 ), intent ( in ) :: tetra (:,:) real ( r64 ), intent ( in ) :: evals (:,:) real ( r64 ), allocatable , intent ( out ) :: tetra_evals (:,:,:) !Local variables integer ( i64 ) :: iv , it , ib , numbands , aux , numtetra numtetra = size ( tetra (:, 1 )) numbands = size ( evals ( 1 , :)) allocate ( tetra_evals ( numtetra , numbands , 4 )) !Note: Eigenvalues outside the transport active window is taken to be zero. !      As such, close to the transport window boundary, this method is inaccurate. !      A large enough transport window must be chosen to obtain accurate transport coefficients. tetra_evals (:,:,:) = 0.0_r64 do it = 1 , numtetra !Run over tetrahedra do ib = 1 , numbands !Run over bands do iv = 1 , 4 !Run over vertices aux = tetra ( it , iv ) if ( aux > 0 ) then !Only eigenvalues inside transport active region tetra_evals ( it , ib , iv ) = evals ( aux , ib ) end if end do call sort ( tetra_evals ( it , ib , :)) end do end do end subroutine fill_tetrahedra_3d subroutine form_triangles ( nk , mesh , triang , triangcount , triangmap , & blocks , indexlist ) !! Form all the triangles of a 3d FBZ mesh for each z component. !! !! nk Number of points in the list of FBZ wave vectors !! mesh Wave vector grid !! triang List of the triangle vertices !! triangcount Number of triangles in which a wave vector belongs !! triangmap Wave vector to (triangle, vertex) mapping !! blocks Is the FBZ wave vector list full or energy restricted? !! indexlist List of muxed indices of the FBZ wave vectors integer ( i64 ), intent ( in ) :: nk , mesh ( 3 ) integer ( i64 ), intent ( out ), allocatable :: triang (:,:), triangcount (:), triangmap (:,:,:) logical , intent ( in ) :: blocks integer ( i64 ), optional , intent ( in ) :: indexlist (:) !Local variables integer ( i64 ) :: ik , i , j , k , ijk ( 3 ), ii , jj , kk , tk , tl , aux , count integer ( i64 ) :: ip1 , jp1 , n1 , n2 , n3 , tmp integer ( i64 ) :: triang_vertices_labels ( 2 , 3 ) integer ( i64 ) :: scvol_vertices ( 4 , 3 ) !subcell vertices n1 = mesh ( 1 ) n2 = mesh ( 2 ) n3 = mesh ( 3 ) !Label of the vertices of the triangles for a given subcell triang_vertices_labels = reshape (( / & 1 , 2 , 3 ,& 1 , 3 , 4 / ), & shape ( triang_vertices_labels ), order = ( / 2 , 1 / )) !Allocate triangles related variables allocate ( triang ( 2 * nk , 3 ), triangcount ( nk ), triangmap ( 2 , nk , 6 )) triang (:,:) = 0 triangcount (:) = 0 triangmap (:,:,:) = 0 count = 1 !triangles counter do ik = 1 , nk !Run over all wave vectors in FBZ if ( blocks ) then !For energy window restricted FBZ call demux_vector ( indexlist ( ik ), ijk , mesh , 1_i64 ) else !For unrestristed FBZ call demux_vector ( ik , ijk , mesh , 1_i64 ) end if i = ijk ( 1 ) j = ijk ( 2 ) k = ijk ( 3 ) !Apply periodic boundary condition if ( i == n1 ) then ip1 = 1 else ip1 = i + 1 end if if ( j == n2 ) then jp1 = 1 else jp1 = j + 1 end if !For each subcell save the vertices scvol_vertices = reshape (( / & i , j , k , & ip1 , j , k , & i , jp1 , k , & ip1 , jp1 , k / ), & shape ( scvol_vertices ), order = ( / 2 , 1 / )) !Run over the 2 triangles do tk = 1 , 2 !Run over the labels of the vertices that !make up each triangle do tl = 1 , 3 aux = triang_vertices_labels ( tk , tl ) ii = scvol_vertices ( aux , 1 ) jj = scvol_vertices ( aux , 2 ) kk = scvol_vertices ( aux , 3 ) aux = mux_vector (( / ii , jj , kk / ), mesh , 1_i64 ) tmp = aux !Guaranteed to be > 0 if ( blocks ) then !Which point in indexlist does aux correspond to? call binsearch ( indexlist , aux , tmp ) !tmp < 0 if search fails. end if triang ( count , tl ) = tmp if ( tmp > 0 ) then !Save the mapping of a wave vector index to a (triangle, vertex) triangcount ( tmp ) = triangcount ( tmp ) + 1 triangmap ( 1 , tmp , triangcount ( tmp )) = count triangmap ( 2 , tmp , triangcount ( tmp )) = tl end if end do count = count + 1 end do end do end subroutine form_triangles subroutine fill_triangles ( triang , evals , triang_evals ) !! Populate the (sorted along the vertices) eigenvalues on all the vertices of the triangles !! !! triang List of the triangle vertices !! evals List of eigenvalues !! triang_evals Triangles populated with the eigenvalues integer ( i64 ), intent ( in ) :: triang (:,:) real ( r64 ), intent ( in ) :: evals (:,:) real ( r64 ), allocatable , intent ( out ) :: triang_evals (:,:,:) !Local variables integer ( i64 ) :: iv , it , ib , numbands , aux , numtriangs , numvertices numtriangs = size ( triang (:, 1 )) numbands = size ( evals ( 1 , :)) numvertices = 3 allocate ( triang_evals ( numtriangs , numbands , numvertices )) !Note: Eigenvalues outside the transport active window is taken to be zero. !      As such, close to the transport window boundary, this method is inaccurate. !      A large enough transport window must be chosen to obtain accurate transport coefficients. triang_evals (:,:,:) = 0.0_r64 do it = 1 , numtriangs !Run over triangles do ib = 1 , numbands !Run over bands do iv = 1 , numvertices !Run over vertices aux = triang ( it , iv ) if ( aux > 0 ) then !Only eigenvalues inside transport active region triang_evals ( it , ib , iv ) = evals ( aux , ib ) end if end do call sort ( triang_evals ( it , ib , :)) end do end do end subroutine fill_triangles pure real ( r64 ) function delta_fn_triang ( e , ik , ib , mesh , triangmap , triangcount , triang_evals ) !! Calculate delta function using the triangle method a la !! Kurganskii et al. Phys. Stat. Sol.(b) 129, 293 (1985) !! !! e Sample energy !! ik Wave vector index !! ib Band index !! mesh Wave vector grid !! triangmap Wave vector to (triangle, vertex) mapping !! triangcount Number of triangles in which a wave vector belongs !! triang_evals Triangles populated with the eigenvalues real ( r64 ), intent ( in ) :: e integer ( i64 ), intent ( in ) :: ik , ib integer ( i64 ), intent ( in ) :: mesh ( 3 ), triangmap (:,:,:), triangcount (:) real ( r64 ), intent ( in ) :: triang_evals (:,:,:) !Local variables integer ( i64 ) :: iv , it , itk , num , numtriangs logical :: c1 , c2 , c3 , c4 real ( r64 ) :: e1 , e2 , e3 , E12 , E21 , E13 , E31 , E23 , E32 , tmp tmp = 0.0_r64 delta_fn_triang = 0.0_r64 !Total number of triangles in the system numtriangs = product ( mesh ) * 2 !Grab number of triangles in which wave vector belongs num = triangcount ( ik ) do itk = 1 , num !Run over triangles it = triangmap ( 1 , ik , itk ) !Grab triangle iv = triangmap ( 2 , ik , itk ) !Grab vertex !Grab vertex energies e1 = triang_evals ( it , ib , 1 ) e2 = triang_evals ( it , ib , 2 ) e3 = triang_evals ( it , ib , 3 ) !Evaluate the four possible cases c1 = e <= e1 c2 = e1 < e . and . e <= e2 c3 = e2 < e . and . e <= e3 c4 = e3 < e tmp = 0.0_r64 if ( c1 . or . c4 ) cycle !Define Eij ! Note that at this stage the quantities below might ! be ill defined due to degeneracies. But the conditionals ! that will follow will take this into account. E12 = ( e - e2 ) / ( e1 - e2 ) E21 = ( e - e1 ) / ( e2 - e1 ) E13 = ( e - e3 ) / ( e1 - e3 ) E31 = ( e - e1 ) / ( e3 - e1 ) E23 = ( e - e3 ) / ( e2 - e3 ) E32 = ( e - e2 ) / ( e3 - e2 ) select case ( iv ) case ( 1 ) if ( c2 ) then tmp = E21 * ( E12 + E13 ) / ( e3 - e1 ) else if ( c3 ) then tmp = E23 * E13 / ( e3 - e1 ) end if case ( 2 ) if ( c2 ) then tmp = E21 * E21 / ( e3 - e1 ) else if ( c3 ) then tmp = E23 * E23 / ( e3 - e1 ) end if case ( 3 ) if ( c2 ) then tmp = E21 * E31 / ( e3 - e1 ) else if ( c3 ) then tmp = E23 * ( E31 + E32 ) / ( e3 - e1 ) end if end select delta_fn_triang = delta_fn_triang + tmp end do !itk if ( delta_fn_triang < 1.0e-12_r64 ) delta_fn_triang = 0.0_r64 !Normalize with the total number of triangles delta_fn_triang = delta_fn_triang / numtriangs end function delta_fn_triang end module delta","tags":"","loc":"sourcefile/delta.f90.html"},{"title":"migel_sc.f90 – elphbolt","text":"Contents Modules MigEl_sc_module Source Code migel_sc.f90 Source Code ! Copyright (C) 2022- Nakib Haider Protik <nakib.haider.protik@gmail.com> ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module MigEl_sc_module !! Module containing types and procedures related to the !! Migdal-Eliashberg (MigEl) solver environment. use params , only : r64 , i64 , pi , kB , oneI use misc , only : subtitle , print_message , exit_with_message , write2file_rank1_real , & twonorm , distribute_points , Pade_continued , demux_state , mux_state use numerics_module , only : numerics use electron_module , only : electron use wannier_module , only : epw_wannier use eliashberg , only : calculate_iso_Matsubara_lambda , calculate_aniso_Matsubara_lambda implicit none !external chdir private public MigEl_sc type MigEl_sc !! Data and procedures related to the Migdal-Eliashberg equations solver environment. integer ( i64 ) :: numqp !! Number of point on quasiparticle energy grid real ( r64 ), allocatable :: qp_ens (:) !! Uniform quasiparticle energy mesh integer ( i64 ) :: qp_cutoff !! Quasiparticle energy cutoff (factor that multiplies the highest phonon energy) integer ( i64 ) :: nummatsubara !! Number of points on Matsubara mesh integer ( i64 ) :: nummatsubara_upper !! Number of points on upper plane Matsubara mesh integer ( i64 ) :: matsubara_cutoff !! Matsubara energy cutoff (factor of highest phonon energy) real ( r64 ), allocatable :: bose_matsubara_ens (:) !! Uniform Bosonic Matsubara mesh real ( r64 ), allocatable :: fermi_matsubara_ens (:) !! Number of point on phonon energy grid real ( r64 ), allocatable :: omegas (:) !! Uniform Fermionic Matsubara mesh integer ( i64 ) :: numomega !! Uniform phonon energy mesh real ( r64 ) :: omegalog !! Logarithmic average of phonon energy real ( r64 ) :: iso_lambda0 !! Standard, isotropic e-ph coupling real ( r64 ) :: domega !! Uniform bosonic mesh energy difference real ( r64 ) :: Tstart , Tend , dT !! Temperature sweep: start, end, difference real ( r64 ) :: mustar !! Dimensionless Coulomb pseudopotential parameter real ( r64 ) :: MAD_Tc !! Superconducting transition temperature in the McMillan-Allen-Dynes (MAD) theory real ( r64 ) :: BCS_delta !! Superconducting gap from the BCS theory using the MAD Tc logical :: isotropic !! Use isotropic approximation? logical :: use_external_eps !! Use user generated |epsilon|&#94;2 to screen a2F? contains procedure , public :: initialize , calculate_MAD_theory , calculate_MigEl_theory procedure , private :: generate_real_ens_meshes , generate_matsubara_meshes end type MigEl_sc contains subroutine initialize ( self , max_ph_en ) !! Read input file and setup the T-independent part of the MigEl environment. class ( MigEl_sc ), intent ( out ) :: self real ( r64 ), intent ( in ) :: max_ph_en !Local variables real ( r64 ) :: domega , Tstart , Tend , & dT , mustar , qp_cutoff , matsubara_cutoff logical ( r64 ) :: isotropic , use_external_eps namelist / superconductivity / domega , matsubara_cutoff , qp_cutoff , & Tstart , Tend , dT , mustar , isotropic , use_external_eps call subtitle ( \"Setting up Migdal-Eliashberg solver environment...\" ) !Open input file open ( 1 , file = 'input.nml' , status = 'old' ) !Read superconductivity-related information qp_cutoff = 0_r64 matsubara_cutoff = 0_r64 domega = 0.0_r64 Tstart = 0.0_r64 Tend = 0.0_r64 dT = 0.0_r64 mustar = 0.0_r64 isotropic = . false . use_external_eps = . false . read ( 1 , nml = superconductivity ) if ( domega * qp_cutoff * matsubara_cutoff * Tstart * & Tend * dT == 0 ) then call exit_with_message ( 'Bad input(s) provided for superconductivity solver.' ) end if self % qp_cutoff = nint ( qp_cutoff ) self % matsubara_cutoff = nint ( matsubara_cutoff ) self % domega = domega self % Tstart = Tstart self % Tend = Tend self % dT = dT self % mustar = mustar self % isotropic = isotropic self % use_external_eps = use_external_eps if (. not . self % isotropic . and . self % use_external_eps ) & call exit_with_message ( 'External screening for the anisotropic case is not supported. Exiting.' ) !Set up meshes call generate_real_ens_meshes ( self , max_ph_en ) !Print out information. if ( this_image () == 1 ) then write ( * , \"(A, 1E16.8, A)\" ) \"Matsubara energy cut-off = \" , self % matsubara_cutoff * max_ph_en , \" eV\" write ( * , \"(A, 1E16.8, A)\" ) \"Quasiparticle energy cut-off = \" , self % qp_cutoff * max_ph_en , \" eV\" write ( * , \"(A, 1E16.8, A)\" ) \"Bosonic energy mesh spacing = \" , self % domega , \" eV\" write ( * , \"(A, 1E16.8, A)\" ) \"First temperature = \" , self % Tstart , \" K\" write ( * , \"(A, 1E16.8, A)\" ) \"Last temperature = \" , self % Tend , \" K\" write ( * , \"(A, 1E16.8, A)\" ) \"Temperature step = \" , self % dT , \" K\" write ( * , \"(A, 1E16.8)\" ) \"Coulomb pseudopotential parameter = \" , self % mustar write ( * , \"(A, L)\" ) \"Use isotropic Migdal-Eliashberg theory: \" , self % isotropic write ( * , \"(A, L)\" ) \"Use user generated |epsilon|&#94;2 to screen a2F: \" , self % use_external_eps end if sync all end subroutine initialize subroutine calculate_MAD_theory ( self ) !! Calculate the supercondting gap and transition temperature !! using the McMillan-Allen-Dynes (MAD) theory. !! P. B. Allen and R. C. Dynes Phys. Rev. B 12, 905 (1975). class ( MigEl_sc ), intent ( inout ) :: self !McMillan-Allen-Dynes Tc self % MAD_Tc = self % omegalog / 1.2_r64 * exp ( - 1.04_r64 * ( 1.0_r64 + self % iso_lambda0 ) / & ( self % iso_lambda0 - self % mustar * ( 1.0_r64 + 0.62_r64 * self % iso_lambda0 ))) / kB !BCS gap in the weak-coupling limit from the MAD Tc self % BCS_Delta = 1.72_r64 * kB * self % MAD_Tc if ( this_image () == 1 ) then write ( * , \"(A, (1E16.8, x), A)\" ) 'McMillan-Allen-Dynes Tc =' , & self % MAD_Tc , ' K' write ( * , \"(A, (1E16.8, x), A)\" ) 'BCS gap =' , & self % BCS_delta * 1.0e3_r64 , ' meV' end if end subroutine calculate_MAD_theory subroutine calculate_MigEl_theory ( self , el , wann , num , max_ph_en ) !! Solve the Migdal-Eliashberg equations. class ( MigEl_sc ), intent ( inout ) :: self type ( electron ), intent ( in ) :: el type ( epw_wannier ), intent ( in ) :: wann type ( numerics ), intent ( in ) :: num real ( r64 ), intent ( in ) :: max_ph_en !Local variables logical :: in_T_bracket real ( r64 ) :: T , norm_Z , norm_Zold , norm_Delta , norm_Deltaold , aux real ( r64 ), allocatable :: quasi_dos (:), & iso_matsubara_lambda (:), iso_matsubara_Delta (:), iso_matsubara_Z (:), & aniso_matsubara_Delta (:, :), aniso_matsubara_Z (:, :) complex ( r64 ), allocatable :: iso_quasi_Delta (:), iso_quasi_Z (:), & aniso_quasi_Delta (:, :), aniso_quasi_Z (:, :) integer ( i64 ) :: iter , nstates_irred , i , istate , m , ik character ( len = 1024 ) :: filename , numcols !Total number of IBZ blocks states nstates_irred = el % nwv_irred * wann % numwannbands allocate ( quasi_dos ( self % numqp )) if ( self % isotropic ) then call print_message ( \"Solving the isotropic Migdal-Eliashberg equations...\" ) allocate ( iso_quasi_Delta ( self % numqp ), iso_quasi_Z ( self % numqp )) else call print_message ( \"Solving the anisotropic Migdal-Eliashberg equations...\" ) allocate ( aniso_quasi_Delta ( nstates_irred , self % numqp ), & aniso_quasi_Z ( nstates_irred , self % numqp )) end if !Calculate for all temperatures in the provided bracket T = self % Tstart in_T_bracket = . true . do while ( in_T_bracket ) if ( this_image () == 1 ) then write ( * , \"(A)\" ) \"---->\" write ( * , \"(A, 1E16.8, A)\" ) \" Temperature = \" , T , \" K\" end if !Generate the Matsubara meshes call self % generate_matsubara_meshes ( T , max_ph_en ) if ( self % isotropic ) then if ( allocated ( iso_matsubara_lambda )) deallocate ( iso_matsubara_lambda ) if ( allocated ( iso_matsubara_Delta )) deallocate ( iso_matsubara_Delta ) if ( allocated ( iso_matsubara_Z )) deallocate ( iso_matsubara_Z ) allocate ( iso_matsubara_lambda ( self % nummatsubara )) allocate ( iso_matsubara_Delta ( self % nummatsubara )) allocate ( iso_matsubara_Z ( self % nummatsubara )) !Approximate initial gap to start off the iterator iso_matsubara_Delta (:) = self % BCS_delta norm_Delta = twonorm ( iso_matsubara_Delta ) iso_matsubara_Z = 1.0_r64 !For the sake of non-zero initial norm norm_Z = twonorm ( iso_matsubara_Z ) !Calculate isotropic lambda function call calculate_iso_matsubara_lambda ( wann , num , self % omegas , self % bose_matsubara_ens , iso_matsubara_lambda ) else if ( allocated ( aniso_matsubara_Delta )) deallocate ( aniso_matsubara_Delta ) if ( allocated ( aniso_matsubara_Z )) deallocate ( aniso_matsubara_Z ) allocate ( aniso_matsubara_Delta ( nstates_irred , self % nummatsubara )) allocate ( aniso_matsubara_Z ( nstates_irred , self % nummatsubara )) !Approximate initial gap to start off the iterator aniso_matsubara_Delta (:, :) = self % BCS_delta norm_Delta = twonorm ( aniso_matsubara_Delta ) aniso_matsubara_Z = 1.0_r64 !For the sake of non-zero initial norm norm_Z = twonorm ( aniso_matsubara_Z ) !Calculate anisotropic lambda function call calculate_aniso_matsubara_lambda ( wann , num , el , self % omegas , self % bose_matsubara_ens ) end if if ( this_image () == 1 ) write ( * , \"(A)\" ) \"   Iterating...\" do iter = 1 , max ( 500 , num % maxiter ) !At least 500 iterations. if ( self % isotropic ) then call iterate_iso_matsubara_Z ( iso_matsubara_lambda , self % fermi_matsubara_ens , & iso_matsubara_Delta , iso_matsubara_Z , T ) call iterate_iso_matsubara_Delta ( iso_matsubara_lambda , self % fermi_matsubara_ens , & iso_matsubara_Delta , iso_matsubara_Z , T , self % mustar ) else call iterate_aniso_matsubara_Z ( el , wann , num , self % fermi_matsubara_ens , & aniso_matsubara_Delta , aniso_matsubara_Z , T ) call iterate_aniso_matsubara_Delta ( el , wann , num , self % fermi_matsubara_ens , & aniso_matsubara_Delta , aniso_matsubara_Z , T , self % mustar ) end if norm_Zold = norm_Z norm_Deltaold = norm_Delta if ( self % isotropic ) then norm_Z = twonorm ( iso_matsubara_Z ) norm_Delta = twonorm ( iso_matsubara_Delta ) else norm_Z = twonorm ( aniso_matsubara_Z ) norm_Delta = twonorm ( aniso_matsubara_Delta ) end if !Zero out norm_Delata if it is smaller 1 micro eV if ( norm_Delta < 1.0e-6_r64 ) norm_Delta = 0.0_r64 !Output norms every 100 iterations if ( this_image () == 1 . and . mod ( iter , 100 ) == 0 ) then write ( * , \"(A, (1E16.8, x, 1E16.8))\" ) \"   ||Z||, ||Delta|| = \" , norm_Z , norm_Delta end if !Iteration breaker if (( abs ( norm_Z - norm_Zold ) / norm_Zold < num % conv_thres ) . and . & (( abs ( norm_Delta - norm_Deltaold ) / norm_Deltaold < num % conv_thres ) & . or . norm_Delta == 0.0_r64 )) then if ( this_image () == 1 ) write ( * , \"(A, (I5))\" ) \"   Convergence reached after iter\" , iter if ( this_image () == 1 ) write ( * , \"(A, (1E16.8))\" ) \"   ||Delta|| = \" , norm_Delta exit end if end do !iteration number !Perform analytic continuation to positive real energies if ( this_image () == 1 ) & write ( * , \"(A)\" ) \"  Performing analytic continuation...\" if ( self % isotropic ) then iso_quasi_Delta = Pade_continued (& oneI * self % fermi_matsubara_ens ( self % nummatsubara_upper : self % nummatsubara ), & iso_matsubara_Delta ( self % nummatsubara_upper : self % nummatsubara ), self % qp_ens ) !Reduced quasiparticle density of states !Eq. 11 of H.J. Choi et al. Physica C 385 (2003) 66–74 quasi_dos = real (( self % qp_ens + oneI * 1.0e-6_r64 ) / & sqrt (( self % qp_ens + oneI * 1.0e-6_r64 ) ** 2 - iso_quasi_Delta ** 2 )) !Write quasiparticle Delta and reduced DOS as text data to file if ( this_image () == 1 ) then call chdir ( num % cwd ) write ( filename , '(f10.3)' ) T filename = 'iso_quasiparticle_Delta.T' // trim ( adjustl ( filename )) write ( numcols , \"(I0)\" ) 3 open ( 1 , file = trim ( filename ), status = 'replace' ) do i = 1 , self % numqp write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) self % qp_ens ( i ), & iso_quasi_Delta ( i ) end do close ( 1 ) write ( filename , '(f10.3)' ) T filename = 'iso_quasiparticle_DOS.T' // trim ( adjustl ( filename )) write ( numcols , \"(I0)\" ) 2 open ( 1 , file = trim ( filename ), status = 'replace' ) do i = 1 , self % numqp write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) self % qp_ens ( i ), & quasi_dos ( i ) end do close ( 1 ) end if sync all else do istate = 1 , nstates_irred !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , wann % numwannbands , m , ik ) !Apply energy window to IBZ blocks electron if ( abs ( el % ens_irred ( ik , m ) - el % enref ) > el % fsthick ) cycle aniso_quasi_Delta ( istate , :) = Pade_continued (& oneI * self % fermi_matsubara_ens ( self % nummatsubara_upper : self % nummatsubara ), & aniso_matsubara_Delta ( istate , self % nummatsubara_upper : self % nummatsubara ), self % qp_ens ) end do !TODO Need to decide if this should be printed out since it can be a pretty large file !Reduced quasiparticle density of states !Eq. 11 of H.J. Choi et al. Physica C 385 (2003) 66–74 do i = 1 , self % numqp aux = 0.0_r64 do istate = 1 , nstates_irred !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , wann % numwannbands , m , ik ) aux = aux + el % nequiv ( ik ) * el % Ws_irred ( ik , m ) * & real (( self % qp_ens ( i ) + oneI * 1.0e-6_r64 ) / & sqrt (( self % qp_ens ( i ) + oneI * 1.0e-6_r64 ) ** 2 - aniso_quasi_Delta ( istate , i ) ** 2 )) end do quasi_dos ( i ) = aux end do !Write quasiparticle reduced DOS as text data to file if ( this_image () == 1 ) then call chdir ( num % cwd ) write ( filename , '(f10.3)' ) T filename = 'aniso_quasiparticle_DOS.T' // trim ( adjustl ( filename )) write ( numcols , \"(I0)\" ) 2 open ( 1 , file = trim ( filename ), status = 'replace' ) do i = 1 , self % numqp write ( 1 , \"(\" // trim ( adjustl ( numcols )) // \"E20.10)\" ) self % qp_ens ( i ), & quasi_dos ( i ) end do close ( 1 ) end if sync all end if !Next temperature T = T + self % dT !Check temperature bracket if ( self % dT > 0 ) then if ( T > self % Tend . or . T < self % Tstart ) in_T_bracket = . false . else if ( T < self % Tend . or . T > self % Tstart ) in_T_bracket = . false . end if end do end subroutine calculate_MigEl_theory subroutine iterate_aniso_matsubara_Z ( el , wann , num , fermi_matsubara_ens , & Delta , Z , T ) !! Iterate the anisotropic Matsubara mass renormalization function for !! a given gap (Delta) at a given temperature (T) in K. type ( electron ), intent ( in ) :: el type ( epw_wannier ), intent ( in ) :: wann type ( numerics ), intent ( in ) :: num real ( r64 ), intent ( in ) :: Delta (:, :), fermi_matsubara_ens (:), T real ( r64 ), intent ( out ) :: Z (:, :) !Internal variables integer ( i64 ) :: j , jp , nstates_irred , nummatsubara , nprocs , start , end , chunk , & num_active_images , istate , count , m , n , s , ik , ikp , ikp_ibz , istatep_ibz real ( r64 ) :: aux , pikBT real ( r64 ), allocatable :: lambda (:), lambda_istate (:, :) character ( len = 1024 ) :: filename nstates_irred = size ( Delta (:, 1 )) nummatsubara = size ( Delta ( 1 , :)) pikBT = pi * T * kB !eV allocate ( lambda ( nummatsubara )) call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) Z = 0.0_r64 !Run over IBZ blocks states do istate = start , end !Initialize eligible process counter for this state count = 0 !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , wann % numwannbands , m , ik ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( el % ens_irred ( ik , m ) - el % enref ) > el % fsthick ) cycle !Read anisotropic lambda_istate from file call chdir ( trim ( adjustl ( num % scdir ))) write ( filename , '(I9)' ) istate filename = 'lambda.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'old' , access = 'stream' ) read ( 1 ) nprocs if ( allocated ( lambda_istate )) deallocate ( lambda_istate ) allocate ( lambda_istate ( nprocs , nummatsubara )) if ( nprocs > 0 ) read ( 1 ) lambda_istate close ( 1 ) !Sum over final (FBZ blocks) electron wave vectors do ikp = 1 , el % nwv !Grab IBZ vector index, ikp_ibz, corresponding to this FBZ vector ikp_ibz = el % fbz2ibz_map ( ikp ) !Sum over final electron bands do n = 1 , wann % numwannbands !Apply energy window to final electron if ( abs ( el % ens ( ikp , n ) - el % enref ) > el % fsthick ) cycle !Mux primed state index istatep_ibz = mux_state ( wann % numwannbands , n , ikp_ibz ) !Branch summed lambda lambda = 0.0_r64 do s = 1 , wann % numbranches !Increment anisotropic lambda_istate processes counter count = count + 1 lambda (:) = lambda (:) + lambda_istate ( count , :) end do !Run over Matsubara axis do j = 1 , nummatsubara !Sum over Matsubara axis aux = 0.0_r64 do jp = 1 , nummatsubara aux = aux + el % Ws ( ikp , n ) * & lambda ( abs ( j - jp ) + 1 ) * fermi_matsubara_ens ( jp ) / & sqrt ( fermi_matsubara_ens ( jp ) ** 2 + Delta ( istatep_ibz , jp ) ** 2 ) end do Z ( istate , j ) = Z ( istate , j ) + aux / fermi_matsubara_ens ( j ) end do end do end do end do sync all call co_sum ( Z ) sync all Z = 1.0_r64 + Z * pikBT sync all end subroutine iterate_aniso_matsubara_Z subroutine iterate_aniso_matsubara_Delta ( el , wann , num , fermi_matsubara_ens , & Delta , Z , T , mustar ) !! Iterate the isotropic Matsubara gap function, Delta. !! This will take Delta&#94;(tau) -> Delta&#94;(tau + 1) for a given mass enhancement, Z&#94;(tau), !! tau being the \"time\" in the iterator sense. type ( electron ), intent ( in ) :: el type ( epw_wannier ), intent ( in ) :: wann type ( numerics ), intent ( in ) :: num real ( r64 ), intent ( in ) :: Z (:, :), fermi_matsubara_ens (:), T , mustar real ( r64 ), intent ( inout ) :: Delta (:, :) !Internal variables integer ( i64 ) :: j , jp , nstates_irred , nummatsubara , nprocs , start , end , chunk , & num_active_images , istate , count , m , n , s , ik , ikp , ikp_ibz , istatep_ibz real ( r64 ) :: aux , pikBT real ( r64 ), allocatable :: lambda (:), lambda_istate (:, :), old_Delta (:, :) character ( len = 1024 ) :: filename nstates_irred = size ( Delta (:, 1 )) nummatsubara = size ( Delta ( 1 , :)) pikBT = pi * T * kB !eV allocate ( lambda ( nummatsubara )) allocate ( old_Delta ( nstates_irred , nummatsubara )) call distribute_points ( nstates_irred , chunk , start , end , num_active_images ) old_Delta = Delta Delta = 0.0_r64 !Run over IBZ blocks states do istate = start , end !Initialize eligible process counter for this state count = 0 !Demux state index into band (m) and wave vector (ik) indices call demux_state ( istate , wann % numwannbands , m , ik ) !Apply energy window to initial (IBZ blocks) electron if ( abs ( el % ens_irred ( ik , m ) - el % enref ) > el % fsthick ) cycle !Read anisotropic lambda_istate from file call chdir ( trim ( adjustl ( num % scdir ))) write ( filename , '(I9)' ) istate filename = 'lambda.istate' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'old' , access = 'stream' ) read ( 1 ) nprocs if ( allocated ( lambda_istate )) deallocate ( lambda_istate ) allocate ( lambda_istate ( nprocs , nummatsubara )) if ( nprocs > 0 ) read ( 1 ) lambda_istate close ( 1 ) !Sum over final (FBZ blocks) electron wave vectors do ikp = 1 , el % nwv !Grab IBZ vector index, ikp_ibz, corresponding to this FBZ vector ikp_ibz = el % fbz2ibz_map ( ikp ) !Sum over final electron bands do n = 1 , wann % numwannbands !Apply energy window to final electron if ( abs ( el % ens ( ikp , n ) - el % enref ) > el % fsthick ) cycle !Mux primed state index istatep_ibz = mux_state ( wann % numwannbands , n , ikp_ibz ) !Branch summed lambda lambda = 0.0_r64 do s = 1 , wann % numbranches !Increment anisotropic lambda_istate processes counter count = count + 1 lambda (:) = lambda (:) + lambda_istate ( count , :) end do !Run over Matsubara axis do j = 1 , nummatsubara !Sum over Matsubara axis aux = 0.0_r64 do jp = 1 , nummatsubara aux = aux + el % Ws ( ikp , n ) * & ( lambda ( abs ( j - jp ) + 1 ) - mustar ) * old_Delta ( istatep_ibz , jp ) / & sqrt ( fermi_matsubara_ens ( jp ) ** 2 + old_Delta ( istatep_ibz , jp ) ** 2 ) end do Delta ( istate , j ) = Delta ( istate , j ) + aux end do end do end do end do sync all call co_sum ( Delta ) sync all Delta = pikBT * Delta / Z sync all end subroutine iterate_aniso_matsubara_Delta subroutine iterate_iso_matsubara_Z ( iso_matsubara_lambda , fermi_matsubara_ens , & Delta , Z , T ) !! Iterate the isotropic Matsubara mass renormalization function for !! a given gap (Delta) at a given temperature (T) in K. real ( r64 ), intent ( in ) :: iso_matsubara_lambda (:), Delta (:), & fermi_matsubara_ens (:), T real ( r64 ), intent ( out ) :: Z (:) !Internal variables integer ( i64 ) :: j , jp , nummatsubara , start , end , chunk , num_active_images real ( r64 ) :: aux , pikBT nummatsubara = size ( Delta ) pikBT = pi * T * kB !eV call distribute_points ( nummatsubara , chunk , start , end , num_active_images ) Z = 0.0_r64 !Run over Matsubara energies do j = start , end !Sum over Matsubara energies aux = 0.0_r64 do jp = 1 , nummatsubara aux = aux + iso_matsubara_lambda ( abs ( j - jp ) + 1 ) * & fermi_matsubara_ens ( jp ) / & sqrt ( fermi_matsubara_ens ( jp ) ** 2 + Delta ( jp ) ** 2 ) end do Z ( j ) = Z ( j ) + aux / fermi_matsubara_ens ( j ) end do !Reduce Z sync all call co_sum ( Z ) sync all Z = 1.0_r64 + pikBT * Z sync all end subroutine iterate_iso_matsubara_Z subroutine iterate_iso_matsubara_Delta ( iso_matsubara_lambda , fermi_matsubara_ens , & Delta , Z , T , mustar ) !! Iterate the isotropic Matsubara gap function, Delta. !! This will take Delta&#94;(tau) -> Delta&#94;(tau + 1) for a given mass enhancement, Z&#94;(tau), !! tau being the \"time\" in the iterator sense. real ( r64 ), intent ( in ) :: iso_matsubara_lambda (:), fermi_matsubara_ens (:), & Z (:), T , mustar real ( r64 ), intent ( inout ) :: Delta (:) !Internal variables integer ( i64 ) :: j , jp , nummatsubara , start , end , chunk , num_active_images real ( r64 ) :: aux , lambda_aux , pikBT real ( r64 ), allocatable :: old_Delta (:) nummatsubara = size ( Delta ) allocate ( old_Delta ( nummatsubara )) pikBT = pi * T * kB !eV call distribute_points ( nummatsubara , chunk , start , end , num_active_images ) old_Delta = Delta Delta = 0.0_r64 !Run over Matsubara energies do j = start , end !Sum over Matsubara energies aux = 0.0_r64 do jp = 1 , nummatsubara lambda_aux = iso_matsubara_lambda ( abs ( j - jp ) + 1 ) aux = aux + ( lambda_aux - mustar ) * old_Delta ( jp ) / & sqrt ( fermi_matsubara_ens ( jp ) ** 2 + old_Delta ( jp ) ** 2 ) end do Delta ( j ) = Delta ( j ) + aux end do !Reduce Delta sync all call co_sum ( Delta ) sync all Delta = Delta * pikBT / Z sync all end subroutine iterate_iso_matsubara_Delta subroutine generate_real_ens_meshes ( self , max_ph_en ) !! Create uniform mesh of phonon energies and quasiparticle energies class ( MigEl_sc ), intent ( inout ) :: self real ( r64 ), intent ( in ) :: max_ph_en !Local variables integer ( i64 ) :: i call print_message ( \"Creating uniform phonon energy mesh...\" ) !Number of phonon energy points in mesh self % numomega = ceiling (( max_ph_en + 5.0e-3_r64 ) / self % domega ) !Create uniform phonon energy mesh if ( allocated ( self % omegas )) deallocate ( self % omegas ) allocate ( self % omegas ( self % numomega )) self % omegas ( 1 ) = 1.0e-5_r64 !avoid zero phonon energy do i = 2 , self % numomega self % omegas ( i ) = self % omegas ( i - 1 ) + self % domega end do !Number of quasiparticle energy points in mesh self % numqp = self % qp_cutoff * ceiling ( max_ph_en / self % domega ) !Create uniform quasiparticle energy mesh allocate ( self % qp_ens ( self % numqp )) self % qp_ens ( 1 ) = 0 do i = 2 , self % numqp self % qp_ens ( i ) = self % qp_ens ( i - 1 ) + self % domega end do !Write energy meshes to file call write2file_rank1_real ( 'omegas' , self % omegas ) call write2file_rank1_real ( 'quasiparticle_ens' , self % qp_ens ) end subroutine generate_real_ens_meshes subroutine generate_matsubara_meshes ( self , temp , max_ph_en ) !! Calculate the Fermionic and Bosonic Matsubara frequency meshes !! for a given temperature in Kelvins. class ( MigEl_sc ), intent ( inout ) :: self real ( r64 ), intent ( in ) :: temp , max_ph_en !Local variables integer ( i64 ) :: l , halfloc real ( r64 ) :: dmatsubara , invbeta call print_message ( \"   Creating Matsubara meshes...\" ) !Temperature energy invbeta = kB * temp !eV !Matsubara energy mesh spacing dmatsubara = pi * invbeta !eV !The length of the Matsubara mesh is T-dependent. !Set number of Matsubara energy points. ! The ratio of the largest energy to the largest phonon energy = matsubara_cutoff self % nummatsubara = self % matsubara_cutoff * ceiling ( max_ph_en / dmatsubara ) if ( mod ( self % nummatsubara , 2 ) == 1 ) self % nummatsubara = self % nummatsubara + 1 !enforce evenness !Bose iomega_l = i2l.pi/beta, upper plane: l = 0, 1, 2, ... if ( allocated ( self % bose_matsubara_ens )) deallocate ( self % bose_matsubara_ens ) allocate ( self % bose_matsubara_ens ( self % nummatsubara )) do l = 1 , self % nummatsubara self % bose_matsubara_ens ( l ) = 2 * ( l - 1 ) * dmatsubara end do !Fermi iomega_j = i(2j + 1)pi/beta, j = ...-3, -2, -1, 0, 1, 2, ... if ( allocated ( self % fermi_matsubara_ens )) deallocate ( self % fermi_matsubara_ens ) allocate ( self % fermi_matsubara_ens ( self % nummatsubara )) halfloc = self % nummatsubara / 2 + 1 do l = 1 , self % nummatsubara self % fermi_matsubara_ens ( l ) = ( 2 * ( l - halfloc ) + 1 ) * dmatsubara end do !Set number of fermionic Matsubara points on upper half plane !j = 0, 1, 2, ... self % nummatsubara_upper = self % nummatsubara / 2 + 1 end subroutine generate_matsubara_meshes end module MigEl_sc_module","tags":"","loc":"sourcefile/migel_sc.f90.html"},{"title":"symmetry.f90 – elphbolt","text":"Contents Modules symmetry_module Source Code symmetry.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module symmetry_module !! Module containing type and procedures related to crystal and !! Brillouin zone symmetries. use params , only : r64 , i64 use misc , only : mux_vector , demux_mesh , demux_vector , & exit_with_message , subtitle , distribute_points use crystal_module , only : crystal use spglib_wrapper , only : get_operations , get_cartesian_operations , get_num_operations implicit none private public symmetry , find_equiv_map , find_irred_wedge , create_fbz2ibz_map , & fbz2ibz , symmetrize_3x3_tensor type symmetry !! Data and procedure related to symmetries. integer ( i64 ) :: nsymm !! Number of spacegroup symmetries. integer ( i64 ) :: nsymm_rot !! Number of rotations. integer ( i64 ), allocatable :: rotations_orig (:,:,:) !! Rotations without time-reversal, real space, crystal coordinates. real ( r64 ), allocatable :: crotations_orig (:,:,:) !! Rotations without time-reversal, real space, Cartesian coordinates. real ( r64 ), allocatable :: qrotations_orig (:,:,:) !! Rotations without time-reversal, reciprocal space, crystal coordinates. !And with time-reversal (time reversed sector is the 2nd half of last axis): integer ( i64 ), allocatable :: rotations (:,:,:) !! Rotations with time-reversal, real space, crystal coordinates. real ( r64 ), allocatable :: crotations (:,:,:) !! Rotations with time-reversal, real space, Cartesian coordinates. real ( r64 ), allocatable :: qrotations (:,:,:) !! Rotations with time-reversal, reciprocal space, crystal coordinates. character ( len = 10 ) :: international !! Spacegroup in Hermann–Mauguin (or international) notation. contains procedure :: calculate_symmetries end type symmetry contains subroutine calculate_symmetries ( self , crys , mesh ) !! Subroutine to generate the symmetry related data for a given crystal. !! !! This subroutine closely follows parts of config.f90 of the ShengBTE code. class ( symmetry ), intent ( out ) :: self type ( crystal ), intent ( in ) :: crys integer ( i64 ), intent ( in ) :: mesh ( 3 ) !Internal variables: integer ( i64 ) :: i , ii , jj , kk , ll , info , nq , nlen integer ( i64 ) :: P ( 3 ) integer ( i64 ), allocatable :: rtmp (:,:,:), local_equiv_map (:,:) logical , allocatable :: valid (:) real ( r64 ), allocatable :: crtmp (:,:,:), qrtmp (:,:,:) real ( r64 ), allocatable :: translations (:,:), ctranslations (:,:) real ( r64 ) :: tmp1 ( 3 , 3 ), tmp2 ( 3 , 3 ), tmp3 ( 3 , 3 ) !External procedures external :: dgesv call subtitle ( \"Analyzing symmetry...\" ) !Number of points in wave vector mesh nq = product ( mesh ) !Number of crystal symmetries. self % nsymm = get_num_operations ( crys % lattvecs , crys % numatoms , crys % atomtypes , crys % basis ) !Double the above to take time reversal symetry (TRS) into account. self % nsymm_rot = 2 * self % nsymm allocate ( self % rotations ( 3 , 3 , self % nsymm_rot ), self % crotations ( 3 , 3 , self % nsymm_rot ),& self % qrotations ( 3 , 3 , self % nsymm_rot ), self % rotations_orig ( 3 , 3 , self % nsymm ),& self % crotations_orig ( 3 , 3 , self % nsymm ), self % qrotations_orig ( 3 , 3 , self % nsymm ),& translations ( 3 , self % nsymm ), ctranslations ( 3 , self % nsymm )) !Get symmetry operations. call get_operations ( crys % lattvecs , crys % numatoms , crys % atomtypes ,& crys % basis , self % nsymm , self % rotations_orig , translations , self % international ) self % rotations (:,:, 1 : self % nsymm ) = self % rotations_orig if ( this_image () == 1 ) then !This is a hacky fix to the problem of a trailing binary character !printing that happens on some machines. nlen = len ( trim ( self % international )) - 1 write ( * , \"(A, A)\" ) \"Crystal symmetry group = \" , self % international ( 1 : nlen ) write ( * , \"(A, I5)\" ) \"Number of crystal symmetries (without time-reversal) = \" , self % nsymm end if !Get symmertry operations in Cartesian basis. call get_cartesian_operations ( crys % lattvecs , self % nsymm ,& self % rotations_orig , translations ,& self % crotations_orig , ctranslations ) self % crotations (:,:, 1 : self % nsymm ) = self % crotations_orig !Transform the rotation matrices to the reciprocal-space basis. do i = 1 , self % nsymm tmp1 = matmul ( transpose ( crys % lattvecs ), crys % lattvecs ) tmp2 = transpose ( self % rotations_orig (:, :, i )) tmp3 = tmp1 call dgesv ( 3 , 3 , tmp1 , 3 , P , tmp2 , 3 , info ) self % qrotations_orig (:,:, i ) = transpose ( matmul ( tmp2 , tmp3 )) end do self % qrotations (:,:, 1 : self % nsymm ) = self % qrotations_orig !Fill the second half of the rotation matrix list using TRS. self % rotations (:,:, self % nsymm + 1 : 2 * self % nsymm ) = - self % rotations_orig (:,:, 1 : self % nsymm ) self % qrotations (:,:, self % nsymm + 1 : 2 * self % nsymm ) = - self % qrotations_orig (:,:, 1 : self % nsymm ) self % crotations (:,:, self % nsymm + 1 : 2 * self % nsymm ) = - self % crotations_orig (:,:, 1 : self % nsymm ) !Find rotations that are either duplicated or incompatible with mesh. allocate ( local_equiv_map ( self % nsymm_rot , nq )) call find_equiv_map ( self % nsymm_rot , local_equiv_map , mesh , self % qrotations ) allocate ( valid ( self % nsymm_rot )) valid = . true . jj = 0 do ii = 1 , self % nsymm_rot if ( valid ( ii ) . and . any ( local_equiv_map ( ii ,:) == - 1 )) then valid ( ii ) = . false . jj = jj + 1 end if end do if ( this_image () == 1 . and . jj /= 0 ) then print * , jj , & \"Rotations are incompatible with the wave vector mesh and will be discarded.\" end if ll = 0 do ii = 2 , self % nsymm_rot do i = 1 , ii - 1 if (. not . valid ( i )) cycle if ( all ( self % rotations (:,:, ii ) == self % rotations (:,:, i ))) then valid ( ii ) = . false . ll = ll + 1 exit end if end do end do if ( this_image () == 1 . and . ll == 0 ) then write ( * , \"(A, I5)\" ) \"Number of duplicated rotations to be discarded = \" , ll end if !Filter out those rotations through a series of move_alloc calls. !Arrays to take into account: rotations,crotations,qrotations. if ( ll + jj /= 0 ) then allocate ( rtmp ( 3 , 3 , self % nsymm_rot - ll - jj )) allocate ( crtmp ( 3 , 3 , self % nsymm_rot - ll - jj )) allocate ( qrtmp ( 3 , 3 , self % nsymm_rot - ll - jj )) kk = 0 do ii = 1 , self % nsymm_rot if ( valid ( ii )) then kk = kk + 1 rtmp (:,:, kk ) = self % rotations (:,:, ii ) crtmp (:,:, kk ) = self % crotations (:,:, ii ) qrtmp (:,:, kk ) = self % qrotations (:,:, ii ) end if end do self % nsymm_rot = self % nsymm_rot - ll - jj call move_alloc ( rtmp , self % rotations ) call move_alloc ( crtmp , self % crotations ) call move_alloc ( qrtmp , self % qrotations ) end if end subroutine calculate_symmetries subroutine find_star ( q_in , q_out , mesh , qrotations ) !! Compute all images of a wave vector (crystal coords.) under the !! rotational symmetry operations. integer ( i64 ), intent ( in ) :: q_in ( 3 ), mesh ( 3 ) real ( r64 ), intent ( in ) :: qrotations (:,:,:) real ( r64 ), intent ( out ) :: q_out (:,:) integer ( i64 ) :: ii , nsymm_rot nsymm_rot = size ( qrotations ( 1 , 1 ,:)) do ii = 1 , nsymm_rot q_out (:, ii ) = mesh * matmul ( qrotations (:, :, ii ), dble ( q_in ) / mesh ) end do end subroutine find_star subroutine find_equiv_map ( nsymm_rot , equiv_map , mesh , qrotations , indexlist ) !! Subroutine to create the map of equivalent wave vectors. integer ( i64 ), intent ( in ) :: nsymm_rot , mesh ( 3 ) real ( r64 ), intent ( in ) :: qrotations (:,:,:) integer ( i64 ), optional , intent ( in ) :: indexlist (:) integer ( i64 ), intent ( out ) :: equiv_map (:,:) !Local variables integer ( i64 ) :: nmesh , chunk , counter , im , num_active_images integer ( i64 ), allocatable :: index_mesh (:,:) integer ( i64 ) :: i , isym , ivec ( 3 ), base real ( r64 ) :: vec ( 3 ), vec_star ( 3 , nsymm_rot ), dnrm2 integer ( i64 ), allocatable :: start [:], end [:], equiv_map_chunk (:,:)[:] if ( present ( indexlist )) then nmesh = size ( indexlist ) else nmesh = product ( mesh ) end if allocate ( index_mesh ( 3 , nmesh )) !Create mesh of demuxed 0-based indices. base = 0 if ( present ( indexlist )) then call demux_mesh ( index_mesh , nmesh , mesh , base , indexlist ) else call demux_mesh ( index_mesh , nmesh , mesh , base ) end if !Allocate start and end coarrays allocate ( start [ * ], end [ * ]) !Divide wave vectors among images call distribute_points ( nmesh , chunk , start , end , num_active_images ) !Allocate small work variable chunk for each image allocate ( equiv_map_chunk ( nsymm_rot , chunk )[ * ]) counter = 0 do i = start , end !Run over total number of wave vectors. !Increase counter counter = counter + 1 call find_star ( index_mesh (:, i ), vec_star , mesh , qrotations ) !Find star of wave vector. do isym = 1 , nsymm_rot !Run over all rotational symmetries of system. vec = vec_star (:, isym ) !Pick image. ivec = nint ( vec ) !Snap to nearest integer grid. !Check norm and save mapping: if ( dnrm2 ( 3 , abs ( vec - dble ( ivec )), 1 ) >= 1e-2_r64 ) then equiv_map_chunk ( isym , counter ) = - 1 else equiv_map_chunk ( isym , counter ) = mux_vector ( modulo ( ivec , mesh ), mesh , base ) end if end do end do !Gather equiv_map_chunks in equiv_map and broadcast to all sync all if ( this_image () == 1 ) then do im = 1 , num_active_images equiv_map (:, start [ im ]: end [ im ]) = equiv_map_chunk (:,:)[ im ] end do end if sync all call co_broadcast ( equiv_map , 1 ) sync all end subroutine find_equiv_map subroutine find_irred_wedge ( mesh , nwavevecs_irred , wavevecs_irred , & indexlist_irred , nequivalent , nsymm_rot , qrotations , ibz2fbz_map , equivalence_map , blocks , indexlist ) !! Find the irreducible wedge of the FBZ and other quantities. !! Wedge finding algorithm is inspired by ShengBTE. !! !! mesh is the array of number of points along the reciprocal lattice vectors !! nwavevecs_irred is the number of irreducible vectors !! wavevecs_irred are the irreducible vectors !! indexlist_irred is the list containing the muxed indices of the irreducible wave vectors !! nequivalent lists the number of equivalent points of each irreducible point !! ibz2fbz_map contains the map from an irreducible BZ (IBZ) vector to its FBZ images !!   The third axis contains the pair (symmetry index, image) !! equivalence_map is a map of the equivalent points under rotations !! blocks chooses whether the FBZ is energy restricted or not !! indexlist is the sorted list of indices of the wavevectors !!   in the energy restricted FBZ which must be present if blocks is true integer ( i64 ), intent ( in ) :: mesh ( 3 ) logical , intent ( in ) :: blocks integer ( i64 ), intent ( in ) :: nsymm_rot real ( r64 ), intent ( in ) :: qrotations (:,:,:) integer ( i64 ), optional , intent ( in ) :: indexlist (:) integer ( i64 ), intent ( out ) :: nwavevecs_irred integer ( i64 ), allocatable , intent ( out ) :: indexlist_irred (:), & nequivalent (:), ibz2fbz_map (:,:,:), equivalence_map (:,:) real ( r64 ), allocatable , intent ( out ) :: wavevecs_irred (:,:) !Local variables integer ( i64 ) :: nwavevecs , i , imux , s , image , imagelist ( nsymm_rot ), & nrunninglist , counter , ijk ( 3 ), aux , num_active_images , chunk , check integer ( i64 ), allocatable :: runninglist (:), & indexlist_irred_tmp (:), nequivalent_tmp (:), ibz2fbz_map_tmp (:,:,:), & start [:], end [:] logical :: in_list if ( blocks . and . . not . present ( indexlist )) & call exit_with_message ( \"If blocks is true then indexlist must be present\" ) if ( blocks ) then nwavevecs = size ( indexlist ) else nwavevecs = product ( mesh ) end if allocate ( equivalence_map ( nsymm_rot , nwavevecs )) if ( blocks ) then call find_equiv_map ( nsymm_rot , equivalence_map , mesh , qrotations , indexlist ) else call find_equiv_map ( nsymm_rot , equivalence_map , mesh , qrotations ) end if allocate ( indexlist_irred_tmp ( nwavevecs ), nequivalent_tmp ( nwavevecs ), & runninglist ( nwavevecs ), ibz2fbz_map_tmp ( nsymm_rot , nwavevecs , 2 )) !Allocate coarrays allocate ( start [ * ], end [ * ]) runninglist = 0 nrunninglist = 0 nwavevecs_irred = 0 nequivalent_tmp = 0 counter = 0 do i = 1 , nwavevecs !Take a point from the FBZ !Get the muxed index of the wave vector if ( blocks ) then imux = indexlist ( i ) else imux = i end if !Check if point is not already in the running list of points in_list = . false . if ( nrunninglist > 0 ) then !Divide wave vectors among images call distribute_points ( nrunninglist , chunk , start , end , num_active_images ) check = 0 if ( any ( runninglist ( start : end ) == imux )) check = 1 sync all call co_sum ( check ) sync all if ( check > 0 ) in_list = . true . end if sync all if (. not . in_list ) then !Increment irreducible point counter nwavevecs_irred = nwavevecs_irred + 1 !Save point to irreducible wedge list indexlist_irred_tmp ( nwavevecs_irred ) = imux !Generate images of this irreducible point do s = 1 , nsymm_rot !Take a rotation image = equivalence_map ( s , i ) !This is the image !Check if image is not already in the list of images if (. not . any ( imagelist ( 1 : nequivalent_tmp ( nwavevecs_irred )) == image )) then !Increment equivalent image counter nequivalent_tmp ( nwavevecs_irred ) = & nequivalent_tmp ( nwavevecs_irred ) + 1 aux = nequivalent_tmp ( nwavevecs_irred ) !Save image to list of images and running list of !points that have already been considered imagelist ( aux ) = image nrunninglist = nrunninglist + 1 runninglist ( nrunninglist ) = image !Save mapping of the irreducible point to its FBZ image ibz2fbz_map_tmp ( aux , & nwavevecs_irred , :) = [ s , image ] end if end do counter = counter + nequivalent_tmp ( nwavevecs_irred ) end if end do !Check for error if ( nwavevecs /= counter ) call exit_with_message ( \"Severe error: Could not find irreducible wedge.\" ) if ( this_image () == 1 ) then write ( * , \"(A, I10)\" ) \" Number of FBZ wave vectors = \" , counter write ( * , \"(A, I10)\" ) \" Number IBZ wave vectors = \" , nwavevecs_irred end if !Deallocate some internal data deallocate ( runninglist ) !Copy the tmp data into (much) smaller sized global data holders allocate ( indexlist_irred ( nwavevecs_irred )) indexlist_irred ( 1 : nwavevecs_irred ) = indexlist_irred_tmp ( 1 : nwavevecs_irred ) deallocate ( indexlist_irred_tmp ) allocate ( nequivalent ( nwavevecs_irred )) nequivalent ( 1 : nwavevecs_irred ) = nequivalent_tmp ( 1 : nwavevecs_irred ) deallocate ( nequivalent_tmp ) allocate ( ibz2fbz_map ( nsymm_rot , nwavevecs_irred , 2 )) ibz2fbz_map (:, 1 : nwavevecs_irred , :) = ibz2fbz_map_tmp (:, 1 : nwavevecs_irred , :) deallocate ( ibz2fbz_map_tmp ) !Create crystal coords IBZ wave vectors allocate ( wavevecs_irred ( nwavevecs_irred , 3 )) do i = 1 , nwavevecs_irred !run over total number of vectors imux = indexlist_irred ( i ) call demux_vector ( imux , ijk , mesh , 0_i64 ) !get 0-based (i,j,k) indices wavevecs_irred ( i ,:) = dble ( ijk ) / mesh !wave vectors in crystal coordinates end do end subroutine find_irred_wedge function fbz2ibz ( iwvmux , nwv_irred , nequiv , ibz2fbz_map ) !! Find index in IBZ blocks list for a given FBZ blocks muxed vector index integer ( i64 ), intent ( in ) :: iwvmux , nwv_irred , nequiv ( nwv_irred ), ibz2fbz_map (:,:,:) integer ( i64 ) :: i , l , il , fbz2ibz fbz2ibz = - 1 !Sum over all ibz points do i = 1 , nwv_irred !an irreducible point do l = 1 , nequiv ( i ) !number of equivalent points of i !Get (i, l) -> il, the muxed vector index of image il = ibz2fbz_map ( l , i , 2 ) if ( il == iwvmux ) then fbz2ibz = i exit end if end do end do if ( fbz2ibz == - 1 ) then print * , 'Error in fbz2ibz for input index = ' , iwvmux end if end function fbz2ibz subroutine create_fbz2ibz_map ( fbz2ibz_map , nwv , nwv_irred , indexlist , nequiv , ibz2fbz_map ) !! Subroutine to create map of FBZ blocks to IBZ blocks integer ( i64 ), intent ( in ) :: nwv , nwv_irred , indexlist ( nwv ), & nequiv ( nwv_irred ), ibz2fbz_map (:,:,:) integer ( i64 ), intent ( out ), allocatable :: fbz2ibz_map (:) integer ( i64 ) :: iwv allocate ( fbz2ibz_map ( nwv )) do iwv = 1 , nwv !Run over all wave vectors fbz2ibz_map ( iwv ) = fbz2ibz ( indexlist ( iwv ), nwv_irred , nequiv , ibz2fbz_map ) end do end subroutine create_fbz2ibz_map subroutine symmetrize_3x3_tensor ( tensor , crotations ) !! Symmetrize a 3x3 tensor. real ( r64 ), intent ( inout ) :: tensor ( 3 , 3 ) real ( r64 ), intent ( in ) :: crotations (:,:,:) integer ( i64 ) :: irot , nrots real ( r64 ) :: aux ( 3 , 3 ) nrots = size ( crotations ( 1 , 1 , :)) aux (:,:) = 0.0_r64 do irot = 1 , nrots aux (:,:) = aux (:,:) + matmul ( crotations (:, :, irot ),& matmul ( tensor , transpose ( crotations (:, :, irot )))) end do tensor (:,:) = aux (:,:) / nrots end subroutine symmetrize_3x3_tensor end module symmetry_module","tags":"","loc":"sourcefile/symmetry.f90.html"},{"title":"bz_sums.f90 – elphbolt","text":"Contents Modules bz_sums Source Code bz_sums.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module bz_sums !! Module containing the procedures to do Brillouin zone sums. use params , only : r64 , i64 , kB , qe , pi , hbar_eVps , perm0 use misc , only : exit_with_message , print_message , write2file_rank2_real , & distribute_points , Bose , Fermi , binsearch use phonon_module , only : phonon use electron_module , only : electron use crystal_module , only : crystal use delta , only : delta_fn_tetra , delta_fn_triang use symmetry_module , only : symmetry , symmetrize_3x3_tensor implicit none public calculate_dos , calculate_transport_coeff , calculate_qTF , & calculate_el_dos_fermi , calculate_el_Ws , calculate_mfp_cumulative_transport_coeff private calculate_el_dos , calculate_ph_dos_iso interface calculate_dos module procedure :: calculate_el_dos , calculate_ph_dos_iso end interface calculate_dos contains subroutine calculate_qTF ( crys , el ) !! Calculate Thomas-Fermi screening wavevector in the simple electron-gas model. ! ! qTF**2 = spindeg*e&#94;2*beta/nptq/vol_pcell/perm0/epsilon0*Sum_{BZ}f0_{k}(1-f0_{k}) type ( crystal ), intent ( inout ) :: crys type ( electron ), intent ( in ) :: el !Local variables real ( r64 ) :: beta , fFD integer ( i64 ) :: ib , ik beta = 1.0_r64 / kB / crys % T / qe !1/J crys % qTF = 0.d0 if ( crys % epsilon0 /= 0 ) then call print_message ( \"Calculating Thomas-Fermi screening...\" ) do ib = 1 , el % numbands do ik = 1 , el % nwv fFD = Fermi ( el % ens ( ik , ib ), el % chempot , crys % T ) crys % qTF = crys % qTF + fFD * ( 1.0_r64 - fFD ) end do end do crys % qTF = sqrt ( 1.0e9_r64 * crys % qTF * el % spindeg * beta * qe ** 2 / product ( el % wvmesh )& / crys % volume / perm0 / crys % epsilon0 ) !nm&#94;-1 if ( this_image () == 1 ) then write ( * , \"(A, 1E16.8, A)\" ) ' Thomas-Fermi screening wave vector = ' , crys % qTF , ' 1/nm' end if end if end subroutine calculate_qTF subroutine calculate_el_dos_Fermi ( el , usetetra ) !! Calculate spin-normalized electron density of states at the Fermi level !! !! el Electron data type !! usetetra Use the tetrahedron method for delta functions? type ( electron ), intent ( inout ) :: el logical , intent ( in ) :: usetetra !Local variables integer ( i64 ) :: ikp , ibp real ( r64 ) :: delta call print_message ( \"Calculating spin-normalized electronic density of states at Fermi level...\" ) el % spinnormed_dos_fermi = 0.0_r64 do ikp = 1 , el % nwv !over FBZ blocks do ibp = 1 , el % numbands if ( usetetra ) then !Evaluate delta[E(iq',ib') - E_Fermi] delta = delta_fn_tetra ( el % chempot , ikp , ibp , el % wvmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( el % chempot , ikp , ibp , el % wvmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if el % spinnormed_dos_fermi = el % spinnormed_dos_fermi + delta end do end do if ( this_image () == 1 ) then write ( * , \"(A, 1E16.8, A)\" ) ' Spin-normalized DOS(Ef) = ' , el % spinnormed_dos_fermi , ' 1/eV/spin' end if sync all end subroutine calculate_el_dos_Fermi subroutine calculate_el_Ws ( el , usetetra ) !! Calculate all electron delta functions scaled by spin-normalized DOS(Ef) !! W_mk = delta[E_mk - Ef]/DOS(Ef) ! !Note that here the delta function weights are already supercell normalized. type ( electron ), intent ( inout ) :: el logical , intent ( in ) :: usetetra !Local variables integer ( i64 ) :: ik_ibz , ik_fbz , ieq , ib real ( r64 ) :: delta call print_message ( \"Calculating DOS(Ef) normalized electron delta functions...\" ) allocate ( el % Ws ( el % nwv , el % numbands )) allocate ( el % Ws_irred ( el % nwv_irred , el % numbands )) el % Ws_irred = 0.0_r64 do ik_ibz = 1 , el % nwv_irred do ieq = 1 , el % nequiv ( ik_ibz ) call binsearch ( el % indexlist , el % ibz2fbz_map ( ieq , ik_ibz , 2 ), ik_fbz ) do ib = 1 , el % numbands if ( usetetra ) then !Evaluate delta[E(ik,ib) - E_Fermi] delta = delta_fn_tetra ( el % chempot , ik_fbz , ib , el % wvmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( el % chempot , ik_fbz , ib , el % wvmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if el % Ws ( ik_fbz , ib ) = delta end do el % Ws_irred ( ik_ibz , :) = el % Ws_irred ( ik_ibz , :) + & el % Ws ( ik_fbz , :) end do !Get the irreducible quantities as an average over all FBZ images el % Ws_irred ( ik_ibz , :) = el % Ws_irred ( ik_ibz , :) / el % nequiv ( ik_ibz ) end do el % Ws = el % Ws / el % spinnormed_dos_fermi el % Ws_irred = el % Ws_irred / el % spinnormed_dos_fermi sync all end subroutine calculate_el_Ws subroutine calculate_el_dos ( el , usetetra ) !! Calculate the density of states (DOS) in units of 1/energy. !! The DOS will be evaluates on the IBZ mesh energies. !! !! el Electron data type !! usetetra Use the tetrahedron method for delta functions? type ( electron ), intent ( inout ) :: el logical , intent ( in ) :: usetetra !Local variables integer ( i64 ) :: ik , ib , ikp , ibp , im , chunk , counter , num_active_images integer ( i64 ), allocatable :: start [:], end [:] real ( r64 ) :: e , delta real ( r64 ), allocatable :: dos_chunk (:,:)[:] call print_message ( \"Calculating electron density of states...\" ) !Allocate start and end coarrays allocate ( start [ * ], end [ * ]) !Divide wave vectors among images call distribute_points ( el % nwv_irred , chunk , start , end , num_active_images ) !Allocate small work variable chunk for each image allocate ( dos_chunk ( chunk , el % numbands )[ * ]) !Allocate dos allocate ( el % dos ( el % nwv_irred , el % numbands )) !Initialize dos arrays el % dos (:,:) = 0.0_r64 dos_chunk (:,:) = 0.0_r64 counter = 0 do ik = start , end !Run over IBZ wave vectors !Increase counter counter = counter + 1 do ib = 1 , el % numbands !Run over wave vectors !Grab sample energy from the IBZ e = el % ens_irred ( ik , ib ) do ikp = 1 , el % nwv !Sum over FBZ wave vectors do ibp = 1 , el % numbands !Sum over wave vectors if ( usetetra ) then !Evaluate delta[E(iq,ib) - E(iq',ib')] delta = delta_fn_tetra ( e , ikp , ibp , el % wvmesh , el % tetramap , & el % tetracount , el % tetra_evals ) else delta = delta_fn_triang ( e , ikp , ibp , el % wvmesh , el % triangmap , & el % triangcount , el % triang_evals ) end if !Sum over delta function dos_chunk ( counter , ib ) = dos_chunk ( counter , ib ) + delta end do end do end do end do !Multiply with spin degeneracy factor dos_chunk (:,:) = el % spindeg * dos_chunk (:,:) !Gather from images and broadcast to all sync all if ( this_image () == 1 ) then do im = 1 , num_active_images el % dos ( start [ im ]: end [ im ], :) = dos_chunk (:,:)[ im ] end do end if sync all call co_broadcast ( el % dos , 1 ) sync all !Write dos to file call write2file_rank2_real ( el % prefix // '.dos' , el % dos ) sync all end subroutine calculate_el_dos subroutine calculate_ph_dos_iso ( ph , usetetra , gfactors , subs_gfactors , & atomtypes , W_phiso , W_phsubs , phiso , phsubs ) !! Calculate the phonon density of states (DOS) in units of 1/energy and, !! optionally, the phonon-isotope scattering rates. !! !! The DOS and isotope scattering rates will be evaluates on the IBZ mesh energies. !! !! ph Phonon data type !! usetetra Use the tetrahedron method for delta functions? type ( phonon ), intent ( inout ) :: ph logical , intent ( in ) :: usetetra , phiso , phsubs real ( r64 ), intent ( in ) :: gfactors (:), subs_gfactors (:) integer ( i64 ), intent ( in ) :: atomtypes (:) real ( r64 ), intent ( out ), allocatable :: W_phiso (:,:), W_phsubs (:,:) !Local variables integer ( i64 ) :: iq , ib , iqp , ibp , im , chunk , counter , num_active_images , & pol , a , numatoms integer ( i64 ), allocatable :: start [:], end [:] real ( r64 ) :: e , delta , aux real ( r64 ), allocatable :: dos_chunk (:,:)[:], W_phiso_chunk (:,:)[:], & W_phsubs_chunk (:,:)[:] call print_message ( \"Calculating phonon density of states and (if needed) isotope/substitution scattering...\" ) !Number of basis atoms numatoms = size ( atomtypes ) !Allocate start and end coarrays allocate ( start [ * ], end [ * ]) !Divide wave vectors among images call distribute_points ( ph % nwv_irred , chunk , start , end , num_active_images ) !Allocate small work variable chunk for each image allocate ( dos_chunk ( chunk , ph % numbands )[ * ]) if ( phiso ) allocate ( W_phiso_chunk ( chunk , ph % numbands )[ * ]) if ( phsubs ) allocate ( W_phsubs_chunk ( chunk , ph % numbands )[ * ]) !Allocate dos and W_phiso allocate ( ph % dos ( ph % nwv_irred , ph % numbands )) allocate ( W_phiso ( ph % nwv_irred , ph % numbands )) allocate ( W_phsubs ( ph % nwv_irred , ph % numbands )) !Initialize arrays and coarrays ph % dos (:,:) = 0.0_r64 dos_chunk (:,:) = 0.0_r64 W_phiso (:,:) = 0.0_r64 W_phsubs (:,:) = 0.0_r64 if ( phiso ) W_phiso_chunk (:,:) = 0.0_r64 if ( phsubs ) W_phsubs_chunk (:,:) = 0.0_r64 counter = 0 do iq = start , end !Run over IBZ wave vectors !Increase counter counter = counter + 1 do ib = 1 , ph % numbands !Run over wave vectors !Grab sample energy from the IBZ e = ph % ens ( ph % indexlist_irred ( iq ), ib ) do iqp = 1 , ph % nwv !Sum over FBZ wave vectors do ibp = 1 , ph % numbands !Sum over wave vectors !Evaluate delta[E(iq,ib) - E(iq',ib')] if ( usetetra ) then delta = delta_fn_tetra ( e , iqp , ibp , ph % wvmesh , ph % tetramap , & ph % tetracount , ph % tetra_evals ) else delta = delta_fn_triang ( e , iqp , ibp , ph % wvmesh , ph % triangmap , & ph % triangcount , ph % triang_evals ) end if !Sum over delta function dos_chunk ( counter , ib ) = dos_chunk ( counter , ib ) + delta if ( phiso . or . phsubs ) then do a = 1 , numatoms pol = ( a - 1 ) * 3 aux = ( abs ( dot_product (& ph % evecs ( ph % indexlist_irred ( iq ), ib , pol + 1 : pol + 3 ), & ph % evecs ( iqp , ibp , pol + 1 : pol + 3 )))) ** 2 !Calculate phonon-isotope scattering in the Tamura model if ( phiso ) then W_phiso_chunk ( counter , ib ) = W_phiso_chunk ( counter , ib ) + & delta * aux * gfactors ( atomtypes ( a )) * e ** 2 end if !Calculate phonon-substitution scattering in the Tamura model if ( phsubs ) then W_phsubs_chunk ( counter , ib ) = W_phsubs_chunk ( counter , ib ) + & delta * aux * subs_gfactors ( atomtypes ( a )) * e ** 2 end if end do end if end do end do end do end do if ( phiso ) W_phiso_chunk = W_phiso_chunk * 0.5_r64 * pi / hbar_eVps !THz if ( phsubs ) W_phsubs_chunk = W_phsubs_chunk * 0.5_r64 * pi / hbar_eVps !THz !Gather from images and broadcast to all sync all if ( this_image () == 1 ) then do im = 1 , num_active_images ph % dos ( start [ im ]: end [ im ], :) = dos_chunk (:,:)[ im ] if ( phiso ) W_phiso ( start [ im ]: end [ im ], :) = W_phiso_chunk (:,:)[ im ] if ( phsubs ) W_phsubs ( start [ im ]: end [ im ], :) = W_phsubs_chunk (:,:)[ im ] end do end if sync all call co_broadcast ( ph % dos , 1 ) call co_broadcast ( W_phiso , 1 ) call co_broadcast ( W_phsubs , 1 ) sync all !Write to file call write2file_rank2_real ( ph % prefix // '.dos' , ph % dos ) call write2file_rank2_real ( ph % prefix // '.W_rta_phiso' , W_phiso ) call write2file_rank2_real ( ph % prefix // '.W_rta_phsubs' , W_phsubs ) sync all end subroutine calculate_ph_dos_iso subroutine calculate_transport_coeff ( species_prefix , field , T , deg , chempot , ens , vels , & volume , mesh , response , sym , trans_coeff_hc , trans_coeff_cc ) !! Subroutine to calculate transport coefficients. !! !! species_prefix Prefix of particle type !! field Type of field !! T Temperature in K !! deg Degeneracy !! chempot Chemical potential in eV !! ens FBZ energies in eV !! vels FBZ velocities in Km/s !! volume Primitive cell volume in nm&#94;3 !! mesh Wave vector grid !! response FBZ response function !! sym Symmery object !! trans_coeff_hc Heat current coefficient !! trans_coeff_cc Charge current coefficient character ( len = 2 ), intent ( in ) :: species_prefix character ( len = 1 ), intent ( in ) :: field integer ( i64 ), intent ( in ) :: mesh ( 3 ), deg real ( r64 ), intent ( in ) :: T , chempot , ens (:,:), vels (:,:,:), volume , response (:,:,:) type ( symmetry ), intent ( in ) :: sym real ( r64 ), intent ( out ) :: trans_coeff_hc (:,:,:), trans_coeff_cc (:,:,:) ! Above, h(c)c = heat(charge) current !Local variables integer ( i64 ) :: ik , ib , icart , nk , nbands , pow_hc , pow_cc real ( r64 ) :: dist_factor , e , v , fac , A_hc , A_cc nk = size ( ens (:, 1 )) nbands = size ( ens ( 1 ,:)) !Common multiplicative factor fac = 1.0e21 / kB / T / volume / product ( mesh ) !Do checks related to particle and field type if ( species_prefix == 'ph' ) then if ( chempot /= 0.0_r64 ) then call exit_with_message (& \"Phonon chemical potential non-zero in calculate_transport_coefficient. Exiting.\" ) end if if ( field == 'T' ) then A_hc = qe * fac pow_hc = 1 A_cc = 0.0_r64 pow_cc = 0 else if ( field == 'E' ) then A_hc = - fac pow_hc = 1 A_cc = 0.0_r64 pow_cc = 0 else call exit_with_message ( \"Unknown field type in calculate_transport_coefficient. Exiting.\" ) end if else if ( species_prefix == 'el' ) then if ( field == 'T' ) then A_cc = - deg * qe * fac pow_cc = 0 A_hc = deg * qe * fac pow_hc = 1 else if ( field == 'E' ) then A_cc = deg * fac pow_cc = 0 A_hc = - A_cc pow_hc = 1 else call exit_with_message ( \"Unknown field type in calculate_transport_coefficient. Exiting.\" ) end if else call exit_with_message ( \"Unknown particle species in calculate_transport_coefficient. Exiting.\" ) end if trans_coeff_hc = 0.0_r64 trans_coeff_cc = 0.0_r64 do ik = 1 , nk do ib = 1 , nbands e = ens ( ik , ib ) if ( species_prefix == 'ph' ) then if ( e == 0.0_r64 ) cycle !Ignore zero energies phonons dist_factor = Bose ( e , T ) dist_factor = dist_factor * ( 1.0_r64 + dist_factor ) else dist_factor = Fermi ( e , chempot , T ) dist_factor = dist_factor * ( 1.0_r64 - dist_factor ) end if do icart = 1 , 3 v = vels ( ik , ib , icart ) trans_coeff_hc ( ib , icart , :) = trans_coeff_hc ( ib , icart , :) + & ( e - chempot ) ** pow_hc * dist_factor * v * response ( ik , ib , :) if ( A_cc /= 0.0_r64 ) then trans_coeff_cc ( ib , icart , :) = trans_coeff_cc ( ib , icart , :) + & ( e - chempot ) ** pow_cc * dist_factor * v * response ( ik , ib , :) end if end do end do end do !Units: ! W/m/K for thermal conductivity ! 1/Omega/m for charge conductivity ! V/K for thermopower ! A/m/K for alpha/T trans_coeff_hc = A_hc * trans_coeff_hc if ( A_cc /= 0.0_r64 ) trans_coeff_cc = A_cc * trans_coeff_cc !Symmetrize transport tensor do ib = 1 , nbands call symmetrize_3x3_tensor ( trans_coeff_hc ( ib , :, :), sym % crotations ) if ( A_cc /= 0.0_r64 ) call symmetrize_3x3_tensor ( trans_coeff_cc ( ib , :, :), sym % crotations ) end do end subroutine calculate_transport_coeff subroutine calculate_spectral_transport_coeff ( species , field , T , deg , chempot , & ens , vels , volume , response , en_grid , usetetra , sym , trans_coeff_hc , trans_coeff_cc ) !! Subroutine to calculate the spectral transport coefficients. !! !! species Object of species type !! field Type of field !! T Temperature in K !! deg Degeneracy !! chempot Chemical potential in eV !! ens FBZ energies in eV !! vels FBZ velocities in Km/s !! volume Primitive cell volume in nm&#94;3 !! usetetra Use tetrahedron method? !! sym Symmery object !! trans_coeff_hc Heat current coefficient !! trans_coeff_cc Charge current coefficient class ( * ), intent ( in ) :: species character ( len = 1 ), intent ( in ) :: field integer ( i64 ), intent ( in ) :: deg real ( r64 ), intent ( in ) :: T , chempot , ens (:,:), vels (:,:,:), volume , & response (:,:,:), en_grid (:) logical , intent ( in ) :: usetetra type ( symmetry ), intent ( in ) :: sym real ( r64 ), intent ( out ) :: trans_coeff_hc (:,:,:,:), trans_coeff_cc (:,:,:,:) !Local variables character ( len = 2 ) :: species_prefix ! Above, h(c)c = heat(charge) current integer ( i64 ) :: ik , ib , ie , icart , nk , nbands , ne , pow_hc , pow_cc real ( r64 ) :: dist_factor , e , v , fac , A_hc , A_cc , delta nk = size ( ens (:, 1 )) !Number of (transport active) wave vectors nbands = size ( ens ( 1 ,:)) !Number of bands/branches ne = size ( en_grid (:)) !Number of sampling energy mesh points !Common multiplicative factor fac = 1.0e21 / kB / T / volume !Grab species prefix select type ( species ) class is ( phonon ) species_prefix = species % prefix class is ( electron ) species_prefix = species % prefix class default species_prefix = 'xx' !Unknown species end select !Do checks related to particle and field type if ( species_prefix == 'ph' ) then if ( chempot /= 0.0_r64 ) then call exit_with_message (& \"Phonon chemical potential non-zero in calculate_transport_coefficient. Exiting.\" ) end if if ( field == 'T' ) then A_hc = qe * fac pow_hc = 1 A_cc = 0.0_r64 pow_cc = 0 else if ( field == 'E' ) then A_hc = - fac pow_hc = 1 A_cc = 0.0_r64 pow_cc = 0 else call exit_with_message ( \"Unknown field type in calculate_transport_coefficient. Exiting.\" ) end if else if ( species_prefix == 'el' ) then if ( field == 'T' ) then A_cc = - deg * qe * fac pow_cc = 0 A_hc = deg * qe * fac pow_hc = 1 else if ( field == 'E' ) then A_cc = deg * fac pow_cc = 0 A_hc = - A_cc pow_hc = 1 else call exit_with_message (& \"Unknown field type in calculate_spectral_transport_coefficient. Exiting.\" ) end if else call exit_with_message (& \"Unknown particle species in calculate_spectral_transport_coefficient. Exiting.\" ) end if !Initialize transport coefficients trans_coeff_hc = 0.0_r64 trans_coeff_cc = 0.0_r64 do ik = 1 , nk !Sum over wave vectors do ib = 1 , nbands !Sum over bands/branches e = ens ( ik , ib ) !Grab energy !Calculate distribution function factor if ( species_prefix == 'ph' ) then if ( e == 0.0_r64 ) cycle !Ignore zero energies phonons dist_factor = Bose ( e , T ) dist_factor = dist_factor * ( 1.0_r64 + dist_factor ) else dist_factor = Fermi ( e , chempot , T ) dist_factor = dist_factor * ( 1.0_r64 - dist_factor ) end if !Run over sampling energies do ie = 1 , ne !Evaluate delta function if ( usetetra ) then select type ( species ) class is ( phonon ) delta = delta_fn_tetra ( en_grid ( ie ), ik , ib , species % wvmesh , species % tetramap , & species % tetracount , species % tetra_evals ) class is ( electron ) delta = delta_fn_tetra ( en_grid ( ie ), ik , ib , species % wvmesh , species % tetramap , & species % tetracount , species % tetra_evals ) end select else select type ( species ) class is ( phonon ) delta = delta_fn_triang ( en_grid ( ie ), ik , ib , species % wvmesh , species % triangmap , & species % triangcount , species % triang_evals ) class is ( electron ) delta = delta_fn_triang ( en_grid ( ie ), ik , ib , species % wvmesh , species % triangmap , & species % triangcount , species % triang_evals ) end select end if do icart = 1 , 3 !Run over Cartesian directions v = vels ( ik , ib , icart ) !Grab velocity trans_coeff_hc ( ib , icart , :, ie ) = trans_coeff_hc ( ib , icart , :, ie ) + & ( en_grid ( ie ) - chempot ) ** pow_hc * dist_factor * v * response ( ik , ib , :) * delta if ( A_cc /= 0.0_r64 ) then trans_coeff_cc ( ib , icart , :, ie ) = trans_coeff_cc ( ib , icart , :, ie ) + & ( en_grid ( ie ) - chempot ) ** pow_cc * dist_factor * v * response ( ik , ib , :) * delta end if end do end do !ie end do !ib end do !ik !Units: ! W/m/K/eV for thermal conductivity ! 1/Omega/m/eV for charge conductivity ! V/K/eV for thermopower ! A/m/K/eV for alpha/T trans_coeff_hc = A_hc * trans_coeff_hc if ( A_cc /= 0.0_r64 ) trans_coeff_cc = A_cc * trans_coeff_cc !Symmetrize transport tensor do ie = 1 , ne do ib = 1 , nbands call symmetrize_3x3_tensor ( trans_coeff_hc ( ib , :, :, ie ), sym % crotations ) if ( A_cc /= 0.0_r64 ) call symmetrize_3x3_tensor ( trans_coeff_cc ( ib , :, :, ie ), sym % crotations ) end do end do end subroutine calculate_spectral_transport_coeff subroutine calculate_mfp_cumulative_transport_coeff ( species_prefix , field , T , deg , chempot , & ens , vels , mesh , volume , response , mfp_grid_sampling , mfps , sym , trans_coeff_hc ) !, trans_coeff_cc) !! Subroutine to calculate the mean-free-path cumulative transport coefficients. !! !! species_prefix Prefix of particle type !! field Type of field !! T Temperature in K !! deg Degeneracy !! chempot Chemical potential in eV !! ens FBZ energies in eV !! vels FBZ velocities in Km/s !! volume Primitive cell volume in nm&#94;3 !! mesh Wave vector mesh !! response Response function (units depend of the specieas and the field type) !! mfp_grid Scalar mean-free-path sampling grid !! mfps Mode resolved mean-free-path !! sym Symmery object !! trans_coeff_hc Heat current coefficient !! trans_coeff_cc Charge current coefficient character ( len = 2 ), intent ( in ) :: species_prefix character ( len = 1 ), intent ( in ) :: field integer ( i64 ), intent ( in ) :: deg , mesh ( 3 ) real ( r64 ), intent ( in ) :: T , chempot , ens (:,:), mfps (:, :), vels (:,:,:), volume , & response (:,:,:), mfp_grid_sampling (:) type ( symmetry ), intent ( in ) :: sym real ( r64 ), intent ( out ) :: trans_coeff_hc (:,:,:,:) !, trans_coeff_cc(:,:,:,:) !Local variables ! Above, h(c)c = heat(charge) current integer ( i64 ) :: ik , ib , imfp , icart , nmfp , nk , nbands , pow_hc !, pow_cc real ( r64 ) :: dist_factor , e , v , fac , A_hc !, A_cc nk = size ( ens (:, 1 )) nbands = size ( ens ( 1 ,:)) nmfp = size ( mfp_grid_sampling ) !Common multiplicative factor fac = 1.0e21 / kB / T / volume / product ( mesh ) !Do checks related to particle and field type if ( species_prefix == 'ph' ) then if ( chempot /= 0.0_r64 ) then call exit_with_message (& \"Phonon chemical potential non-zero in calculate_mfp_cumulative_transport_coeff. Exiting.\" ) end if if ( field == 'T' ) then A_hc = qe * fac pow_hc = 1 !!$          A_cc = 0.0_r64 !!$          pow_cc = 0 else if ( field == 'E' ) then !!$          A_hc = -fac !!$          pow_hc = 1 !!$          A_cc = 0.0_r64 !!$          pow_cc = 0 call exit_with_message ( \"Not supported yet. Exiting.\" ) else call exit_with_message ( \"Unknown field type in calculate_mfp_cumulative_transport_coeff. Exiting.\" ) end if else if ( species_prefix == 'el' ) then !!$       if(field == 'T') then !!$          A_cc = -deg*qe*fac !!$          pow_cc = 0 !!$          A_hc = deg*qe*fac !!$          pow_hc = 1 !!$       else if(field == 'E') then !!$          A_cc = deg*fac !!$          pow_cc = 0 !!$          A_hc = -A_cc !!$          pow_hc = 1 !!$       else !!$          call exit_with_message(\"Unknown field type in calculate_mfp_cumulative_transport_coeff. Exiting.\") !!$       end if call exit_with_message ( \"Not supported yet. Exiting.\" ) else call exit_with_message ( \"Unknown particle species in calculate_mfp_cumulative_transport_coeff. Exiting.\" ) end if trans_coeff_hc = 0.0_r64 !!$    trans_coeff_cc = 0.0_r64 do imfp = 1 , nmfp do ik = 1 , nk do ib = 1 , nbands !Theta(mfp(ik, ib) - mfp_sampling) condition if ( mfps ( ik , ib ) <= mfp_grid_sampling ( imfp )) then e = ens ( ik , ib ) if ( species_prefix == 'ph' ) then if ( e == 0.0_r64 ) cycle !Ignore zero energies phonons dist_factor = Bose ( e , T ) dist_factor = dist_factor * ( 1.0_r64 + dist_factor ) else !!$             dist_factor = Fermi(e, chempot, T) !!$             dist_factor = dist_factor*(1.0_r64 - dist_factor) call exit_with_message ( \"Not supported yet. Exiting.\" ) end if do icart = 1 , 3 v = vels ( ik , ib , icart ) trans_coeff_hc ( ib , icart , :, imfp ) = trans_coeff_hc ( ib , icart , :, imfp ) + & ( e - chempot ) ** pow_hc * dist_factor * v * response ( ik , ib , :) !!$                if(A_cc /= 0.0_r64) then !!$                   trans_coeff_cc(ib, icart, :) = trans_coeff_cc(ib, icart, :) + & !!$                        (e - chempot)**pow_cc*dist_factor*v*response(ik, ib, :) !!$                end if end do end if end do end do end do !Units: ! W/m/K for thermal conductivity ! 1/Omega/m for charge conductivity ! V/K for thermopower ! A/m/K for alpha/T trans_coeff_hc = A_hc * trans_coeff_hc !!$    if(A_cc /= 0.0_r64) trans_coeff_cc = A_cc*trans_coeff_cc !Symmetrize transport tensor do imfp = 1 , nmfp do ib = 1 , nbands call symmetrize_3x3_tensor ( trans_coeff_hc ( ib , :, :, imfp ), sym % crotations ) !!$          if(A_cc /= 0.0_r64) call symmetrize_3x3_tensor(trans_coeff_cc(ib, :, :, imfp), sym%crotations) end do end do end subroutine calculate_mfp_cumulative_transport_coeff end module bz_sums","tags":"","loc":"sourcefile/bz_sums.f90.html"},{"title":"numerics.f90 – elphbolt","text":"Contents Modules numerics_module Source Code numerics.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module numerics_module !! Module containing type and procedures related to the numerics. use params , only : r64 , i64 , twopi use misc , only : exit_with_message , subtitle use crystal_module , only : crystal implicit none private public numerics !external system, getcwd type numerics !! Data and procedures related to the numerics. integer ( i64 ) :: qmesh ( 3 ) !! Phonon wave vector mesh. integer ( i64 ) :: mesh_ref !! Electron mesh refinement factor compared to the phonon mesh. real ( r64 ) :: fsthick !! Fermi surface thickness in eV. character ( len = 1024 ) :: cwd !! Current working directory. character ( len = 1024 ) :: datadumpdir !! Runtime data dump repository. character ( len = 1024 ) :: datadumpdir_T !! Runtime temperature dependent data dump repository. character ( len = 1024 ) :: datadumpdir_T_chempot !! Runtime temperature and chemical potential dependent data dump repository. character ( len = 1024 ) :: g2dir !! Directory for e-ph vertex. character ( len = 1024 ) :: Vdir !! Directory for ph-ph vertex. character ( len = 1024 ) :: Wdir !! Directory for ph-ph transition rates. character ( len = 1024 ) :: Xdir !! Directory for e-ph transition rates. character ( len = 1024 ) :: Ydir !! Directory for ph-e transition rates. character ( len = 1024 ) :: scdir !! Directory for the superconductivity temporary data. logical :: read_gq2 !! Choose if earlier e-ph (IBZ q) vertices are to be used. logical :: read_gk2 !! Choose if earlier e-ph (IBZ k) vertices are to be used. logical :: read_V !! Choose if earlier ph-ph (IBZ q) vertices are to be used. logical :: read_W !! Choose if earlier ph-ph (IBZ q) transition probabilities are to be used. logical :: tetrahedra !! Choose if the tetrahedron method for 3d delta function evaluation will be used. logical :: phe !! Choose if ph-e interaction will be included. logical :: phiso !! Use phonon-isotope scattering? logical :: phsubs !! Use phonon-substitution scattering? logical :: phbound !! Use phonon-boundary scattering? logical :: fourph !! Use 4-ph scattering? integer ( i64 ) :: fourph_mesh_ref !! Mesh refinement factor of phonon wavectors with respect to external 4-ph calculation logical :: phthinfilm !! Use phonon-thin-film scattering? logical :: phdef_Tmat !! Calculate phonon-defect scattering T-matrix? logical :: onlyphbte !! Choose if only phonon BTE will be solved. logical :: onlyebte !! Choose if electron BTE will be solved. logical :: elchimp !! Use electron-charged impurity scattering? logical :: elbound !! Use electron-boundary scattering? logical :: drag !! Choose if the drag effect will be included. integer ( i64 ) :: maxiter !! Maximum number of iterations in the BTE/Migdal-Eliashberg equations solver. real ( r64 ) :: conv_thres !! BTE/Migdal-Eliashberg euqations iteration convergence criterion. logical :: plot_along_path !! Plot Wannierized quantities along high symmetry wave vectors? integer ( i64 ) :: runlevel !! Control for the type of calculation. real ( r64 ) :: ph_en_min , ph_en_max !! Bounds of equidistant phonon energy mesh. integer ( i64 ) :: ph_en_num !! Number of equidistant phonon energy mesh points. real ( r64 ) :: el_en_min , el_en_max !! Bounds of equidistant electron energy mesh. integer ( i64 ) :: el_en_num !! Number of equidistant electron energy mesh points. integer ( i64 ) :: ph_mfp_npts !! Number of equidistant phonon mean-free-path mesh points. contains procedure :: initialize => read_input_and_setup , create_chempot_dirs end type numerics contains subroutine read_input_and_setup ( self , crys ) !! Read input file for information related to the numerics. !! !! self Numerics object !! crys Crytal object class ( numerics ), intent ( out ) :: self type ( crystal ), intent ( in ) :: crys !Local variables integer ( i64 ) :: mesh_ref , qmesh ( 3 ), maxiter , runlevel , el_en_num , & ph_en_num , ph_mfp_npts , fourph_mesh_ref real ( r64 ) :: fsthick , conv_thres , ph_en_min , ph_en_max , el_en_min , el_en_max character ( len = 1024 ) :: datadumpdir , tag logical :: read_gq2 , read_gk2 , read_V , read_W , tetrahedra , phe , phiso , phsubs , & phbound , phdef_Tmat , onlyphbte , onlyebte , elchimp , elbound , drag , plot_along_path , & phthinfilm , fourph namelist / numerics / qmesh , mesh_ref , fsthick , datadumpdir , read_gq2 , read_gk2 , & read_V , read_W , tetrahedra , phe , phiso , phsubs , onlyphbte , onlyebte , maxiter , & conv_thres , drag , elchimp , plot_along_path , runlevel , ph_en_min , ph_en_max , & ph_en_num , el_en_min , el_en_max , el_en_num , phbound , elbound , phdef_Tmat , & ph_mfp_npts , phthinfilm , fourph , fourph_mesh_ref call subtitle ( \"Reading numerics information...\" ) !Open input file open ( 1 , file = 'input.nml' , status = 'old' ) !Read numerics information qmesh = ( / 1 , 1 , 1 / ) mesh_ref = 1 fourph_mesh_ref = 1 fsthick = 0.0_r64 datadumpdir = './' read_gq2 = . false . read_gk2 = . false . read_V = . false . read_W = . false . tetrahedra = . false . phe = . false . phiso = . false . phsubs = . false . phbound = . false . fourph = . false . phthinfilm = . false . phdef_Tmat = . false . onlyphbte = . false . onlyebte = . false . elchimp = . false . elbound = . false . drag = . true . plot_along_path = . false . maxiter = 50 conv_thres = 1e-4_r64 runlevel = 1 ph_en_min = 0.0_r64 ph_en_max = 1.0_r64 ph_en_num = 100 el_en_min = - 1 0.0_r64 el_en_max = 1 0.0_r64 el_en_num = 100 ph_mfp_npts = 100 read ( 1 , nml = numerics ) if ( any ( qmesh <= 0 ) . or . fourph_mesh_ref < 1 . or . mesh_ref < 1 . or . fsthick < 0 ) then call exit_with_message ( 'Bad input(s) in numerics.' ) end if if ( crys % twod . and . tetrahedra ) then call exit_with_message ( 'The tetrahedra method only works for 3d. Exiting.' ) end if if ( crys % epsilon0 == 0.0 . and . elchimp ) then call exit_with_message (& 'Need to provide non-zero epsilon0 for e-ch. imp. interaction. Exiting.' ) end if self % qmesh = qmesh self % runlevel = runlevel !Runlevels: !1 BTE !2 BTE postproc !3 Superconductivity if ( self % runlevel /= 3 ) then !Non-superconductivity mode self % mesh_ref = mesh_ref self % fourph_mesh_ref = fourph_mesh_ref self % read_gq2 = read_gq2 self % read_V = read_V self % read_W = read_W self % phe = phe self % phiso = phiso self % phsubs = phsubs self % phbound = phbound self % fourph = fourph self % phthinfilm = phthinfilm self % phdef_Tmat = phdef_Tmat self % onlyphbte = onlyphbte self % onlyebte = onlyebte self % elchimp = elchimp self % elbound = elbound self % drag = drag else self % mesh_ref = 1 !Enforce this for superconductivity mode end if self % read_gk2 = read_gk2 self % fsthick = fsthick self % datadumpdir = trim ( datadumpdir ) self % tetrahedra = tetrahedra self % maxiter = maxiter self % conv_thres = conv_thres self % plot_along_path = plot_along_path if ( runlevel == 2 ) then self % ph_en_min = ph_en_min self % ph_en_max = ph_en_max self % ph_en_num = ph_en_num self % el_en_min = el_en_min self % el_en_max = el_en_max self % el_en_num = el_en_num self % ph_mfp_npts = ph_mfp_npts end if if ( crys % twod . and . self % qmesh ( 3 ) /= 1 ) then call exit_with_message ( 'For 2d systems, qmesh(3) must be equal to 1.' ) end if !Set BTE solution type if ( self % onlyphbte ) then self % onlyebte = . false . self % drag = . false . end if if ( self % onlyebte ) then self % onlyphbte = . false . self % phiso = . false . self % phsubs = . false . self % drag = . false . self % phe = . false . end if if ( self % drag ) then self % onlyebte = . false . self % onlyphbte = . false . self % phe = . true . end if !Check if T-matrix and tetrahedron method consistency if ( self % phdef_Tmat . and . . not . self % tetrahedra ) then call exit_with_message ( \"Currently T-matrix method is only supported with tetrahedron method. Exiting.\" ) end if !Create data dump directory if ( this_image () == 1 ) call system ( 'mkdir -p ' // trim ( adjustl ( self % datadumpdir ))) !Create matrix elements data directories self % g2dir = trim ( adjustl ( self % datadumpdir )) // 'g2' if ( this_image () == 1 ) call system ( 'mkdir -p ' // trim ( adjustl ( self % g2dir ))) self % Vdir = trim ( adjustl ( self % datadumpdir )) // 'V2' if ( this_image () == 1 ) call system ( 'mkdir -p ' // trim ( adjustl ( self % Vdir ))) !Create superconductivity data dump directory self % scdir = trim ( adjustl ( self % datadumpdir )) // 'sc' if ( this_image () == 1 ) call system ( 'mkdir -p ' // trim ( adjustl ( self % scdir ))) !Create T dependent subdirectory write ( tag , \"(E9.3)\" ) crys % T self % datadumpdir_T = trim ( adjustl ( self % datadumpdir )) // 'T' // trim ( adjustl ( tag )) if ( this_image () == 1 ) call system ( 'mkdir -p ' // trim ( adjustl ( self % datadumpdir_T ))) !Create T-dependent ph-ph transition probability directory self % Wdir = trim ( adjustl ( self % datadumpdir_T )) // '/W' if ( this_image () == 1 ) call system ( 'mkdir -p ' // trim ( adjustl ( self % Wdir ))) !Close input file close ( 1 ) !Set current work directory. call getcwd ( self % cwd ) self % cwd = trim ( self % cwd ) !Print out information. if ( this_image () == 1 ) then write ( * , \"(A, (3I5,x))\" ) \"q-mesh = \" , self % qmesh if ( crys % twod ) then write ( * , \"(A, (3I5,x))\" ) \"k-mesh = \" , self % mesh_ref * self % qmesh ( 1 ), self % mesh_ref * self % qmesh ( 2 ), 1 else write ( * , \"(A, (3I5,x))\" ) \"k-mesh = \" , self % mesh_ref * self % qmesh ( 1 ), self % mesh_ref * self % qmesh ( 2 ), & self % mesh_ref * self % qmesh ( 3 ) end if if ( self % fourph ) then if ( crys % twod ) then write ( * , \"(A, (3I5,x))\" ) \"external 4ph q-mesh = \" , & self % fourph_mesh_ref * self % qmesh ( 1 ), self % fourph_mesh_ref * self % qmesh ( 2 ), 1 else write ( * , \"(A, (3I5,x))\" ) \"external 4ph q-mesh = \" , & self % fourph_mesh_ref * self % qmesh ( 1 ), self % fourph_mesh_ref * self % qmesh ( 2 ), & self % fourph_mesh_ref * self % qmesh ( 3 ) end if end if write ( * , \"(A, 1E16.8, A)\" ) \"Fermi window thickness (each side of reference energy) = \" , self % fsthick , \" eV\" write ( * , \"(A, A)\" ) \"Working directory = \" , trim ( self % cwd ) write ( * , \"(A, A)\" ) \"Data dump directory = \" , trim ( self % datadumpdir ) write ( * , \"(A, A)\" ) \"T-dependent data dump directory = \" , trim ( self % datadumpdir_T ) write ( * , \"(A, A)\" ) \"e-ph directory = \" , trim ( self % g2dir ) if ( self % runlevel /= 3 ) write ( * , \"(A, A)\" ) \"ph-ph directory = \" , trim ( self % Vdir ) write ( * , \"(A, L)\" ) \"Reuse e-ph matrix elements: \" , self % read_gk2 if ( self % runlevel /= 3 ) then write ( * , \"(A, L)\" ) \"Reuse ph-e matrix elements: \" , self % read_gq2 write ( * , \"(A, L)\" ) \"Reuse ph-ph matrix elements: \" , self % read_V write ( * , \"(A, L)\" ) \"Reuse ph-ph transition probabilities: \" , self % read_W write ( * , \"(A, L)\" ) \"Include ph-e interaction: \" , self % phe write ( * , \"(A, L)\" ) \"Include ph-isotope interaction: \" , self % phiso write ( * , \"(A, L)\" ) \"Include ph-substitution interaction: \" , self % phsubs write ( * , \"(A, L)\" ) \"Include ph-boundary interaction: \" , self % phbound write ( * , \"(A, L)\" ) \"Include 4-ph interaction: \" , self % fourph write ( * , \"(A, L)\" ) \"Include ph-thin-film interaction: \" , self % phthinfilm write ( * , \"(A, L)\" ) \"Include ph-defect interaction using the T-matrix: \" , self % phdef_Tmat if ( self % phbound ) then write ( * , \"(A,(1E16.8,x),A)\" ) 'Characteristic length for ph-boundary scattering =' , & crys % bound_length , 'mm' end if if ( self % phthinfilm ) then write ( * , \"(A,(1E16.8,x),A,A,A)\" ) 'Height for ph-thin-film scattering =' , & crys % thinfilm_height , 'mm along the ' , crys % thinfilm_normal , ' direction' end if write ( * , \"(A, L)\" ) \"Include el-charged impurity interaction: \" , self % elchimp write ( * , \"(A, L)\" ) \"Include el-boundary interaction: \" , self % elbound if ( self % elbound ) then write ( * , \"(A,(1E16.8,x),A)\" ) 'Characteristic length for el-boundary scattering =' , & crys % bound_length , 'mm' end if if ( self % onlyphbte ) write ( * , \"(A, L)\" ) \"Calculate only phonon BTE: \" , self % onlyphbte if ( self % onlyebte ) write ( * , \"(A, L)\" ) \"Calculate only electron BTE: \" , self % onlyebte write ( * , \"(A, L)\" ) \"Include drag: \" , self % drag end if write ( * , \"(A, L)\" ) \"Use tetrahedron method: \" , self % tetrahedra write ( * , \"(A, L)\" ) \"Plot quantities along path: \" , self % plot_along_path write ( * , \"(A, I5)\" ) \"Maximum number of BTE/Migdal-Eliashberg equations iterations = \" , self % maxiter write ( * , \"(A, 1E16.8)\" ) \"BTE/Migdal-Eliashberg equations convergence threshold = \" , self % conv_thres end if sync all end subroutine read_input_and_setup subroutine create_chempot_dirs ( self , chempot ) !! Subroutine to create data dump directory tagged by the chemical potential !! and subdirectories within. class ( numerics ), intent ( inout ) :: self real ( r64 ), intent ( in ) :: chempot !Local variables character ( len = 1024 ) :: tag !Create chemical potential dependent data dump directory write ( tag , \"(E14.8)\" ) chempot self % datadumpdir_T_chempot = trim ( adjustl ( self % datadumpdir_T )) // '/mu' // trim ( adjustl ( tag )) !Create e-ph and ph-e transition probability data directories self % Xdir = trim ( adjustl ( self % datadumpdir_T_chempot )) // '/X' self % Ydir = trim ( adjustl ( self % datadumpdir_T_chempot )) // '/Y' if ( this_image () == 1 ) then call system ( 'mkdir -p ' // trim ( adjustl ( self % datadumpdir_T_chempot ))) call system ( 'mkdir -p ' // trim ( adjustl ( self % Xdir ))) call system ( 'mkdir -p ' // trim ( adjustl ( self % Ydir ))) end if sync all end subroutine create_chempot_dirs end module numerics_module","tags":"","loc":"sourcefile/numerics.f90.html"},{"title":"crystal.f90 – elphbolt","text":"Contents Modules crystal_module Source Code crystal.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module crystal_module !! Module containing type and procedures related to the crystal structure. use params , only : r64 , i64 , twopi use misc , only : exit_with_message , print_message , cross_product , demux_vector , & subtitle , trace implicit none private public crystal , calculate_wavevectors_full type crystal !! Data and procedures related to the crystal structure. integer ( i64 ) :: numelements !! Number of types of basis atoms. integer ( i64 ) :: numatoms !! Number of basis atoms. character ( len = 100 ) :: name !! Name of material. character ( len = 3 ), allocatable :: elements (:) !! Elements in the basis. integer ( i64 ), allocatable :: atomtypes (:) !! Integer tagging unique elements in the basis. real ( r64 ), allocatable :: masses (:) !! Masses of the basis atoms. logical :: polar !! Is the system polar? real ( r64 ) :: epsilon ( 3 , 3 ) !! Dielectric tensor. real ( r64 ), allocatable :: born (:,:,:) !! Born effective charge. real ( r64 ) :: epsilon0 !! Static dielectric constant. logical :: read_epsiloninf !! Read high-frequency dielectric constant? real ( r64 ) :: epsiloninf !! High frequency dielectric constant. real ( r64 ) :: qTF !! Thomas-Fermi screening wave vector. real ( r64 ), allocatable :: basis (:,:) !! Basis vectors (crystal coordinates). real ( r64 ), allocatable :: basis_cart (:,:) !! Basis vectors (Cartesian coordinates). real ( r64 ) :: lattvecs ( 3 , 3 ) !! Lattice vectors (nm). real ( r64 ) :: volume !! Volume of primitive cell (nm&#94;3). real ( r64 ) :: reclattvecs ( 3 , 3 ) !! Reciprocal lattice vectors. real ( r64 ) :: volume_bz !! Brillouin zone volume (nm&#94;-3). real ( r64 ) :: T !! Crystal temperature (K). logical :: autoisotopes !! Use isotopic mix for masses? real ( r64 ), allocatable :: gfactors (:) !! g-factors. real ( r64 ), allocatable :: subs_masses (:) !! Masses of the substitutional atoms [D] real ( r64 ), allocatable :: subs_conc (:) !! Concentration of the substitutional atoms in cm&#94;-3 [D] real ( r64 ), allocatable :: subs_gfactors (:) !! g-factors for the substitutional defects. [D] integer ( i64 ), allocatable :: defect_hosts (:) !! Basis atom sites that can be a host for an impurity, one for each unique element. integer ( i64 ), allocatable :: numdopants_types (:) !! Number of dopant types at each host atom site. real ( r64 ), allocatable :: dopant_masses (:, :) !! Masses of the dopants at each host atom site. real ( r64 ), allocatable :: dopant_conc (:, :) !! Concentrations [cm&#94;-3] of the dopants at each host atom site. logical :: twod !! Is the system 2d? real ( r64 ) :: dim !! Dimension of the system real ( r64 ) :: thickness !! Thickness of the system real ( r64 ) :: bound_length !! Characteristic boundary scattering length in mm real ( r64 ) :: thinfilm_height !! Height of thin-film in mm character ( 1 ) :: thinfilm_normal !! Normal direction of the thin-film: 'x', 'y', or 'z'. contains procedure :: initialize => read_input_and_setup_crystal end type crystal contains subroutine read_input_and_setup_crystal ( self ) !! Read input file and initialize crystal data. class ( crystal ), intent ( out ) :: self !Local variables integer ( i64 ) :: i , j , k , numelements , numatoms integer ( i64 ), allocatable :: atomtypes (:), num_atomtypes (:), defect_hosts (:), numdopants_types (:) real ( r64 ), allocatable :: masses (:), born (:,:,:), basis (:,:), & basis_cart (:,:), subs_perc (:), subs_masses (:), subs_conc (:), & dopant_masses (:, :), dopant_conc (:, :) real ( r64 ) :: epsilon ( 3 , 3 ), lattvecs ( 3 , 3 ), T , & epsilon0 , epsiloninf , subs_mavg , bound_length , thinfilm_height character ( len = 3 ), allocatable :: elements (:) character ( len = 100 ) :: name character ( 1 ) :: thinfilm_normal logical :: polar , autoisotopes , read_epsiloninf , twod namelist / allocations / numelements , numatoms namelist / crystal_info / name , elements , atomtypes , basis , lattvecs , & polar , born , epsilon , read_epsiloninf , epsilon0 , epsiloninf , & masses , T , autoisotopes , twod , subs_masses , subs_conc , bound_length , & defect_hosts , numdopants_types , dopant_masses , dopant_conc , thinfilm_height , & thinfilm_normal call subtitle ( \"Setting up crystal...\" ) !Open input file open ( 1 , file = 'input.nml' , status = 'old' ) !Set values from input: !Read allocations numelements = 0 numatoms = 0 read ( 1 , nml = allocations ) if ( numelements < 1 . or . numatoms < 1 . or . numatoms < numelements ) then call exit_with_message ( 'Bad input(s) in allocations.' ) end if self % numelements = numelements self % numatoms = numatoms !Allocate variables allocate ( elements ( numelements ), atomtypes ( numatoms ), born ( 3 , 3 , numatoms ), & basis ( 3 , numatoms ), masses ( numelements ), basis_cart ( 3 , numatoms ), & subs_masses ( numelements ), subs_conc ( numelements ), subs_perc ( numelements ), & num_atomtypes ( numelements ), defect_hosts ( numelements ), & numdopants_types ( numelements ), dopant_masses ( 10 , numelements ), dopant_conc ( 10 , numelements )) allocate ( self % elements ( self % numelements ), self % atomtypes ( self % numatoms ), self % born ( 3 , 3 , self % numatoms ), & self % masses ( self % numatoms ), self % gfactors ( self % numelements ), self % basis ( 3 , self % numatoms ), & self % basis_cart ( 3 , self % numatoms ), self % subs_masses ( self % numelements ), self % subs_conc ( self % numelements ), & self % subs_gfactors ( self % numelements ), self % defect_hosts ( self % numelements )) !Read crystal_info name = trim ( adjustl ( 'Crystal' )) elements = 'X' atomtypes = 0 masses = - 1.0_r64 autoisotopes = . true . lattvecs = 0.0_r64 basis = 0.0_r64 polar = . false . read_epsiloninf = . false . epsilon = 0.0_r64 epsilon0 = 0.0_r64 epsiloninf = 0.0_r64 born = 0.0_r64 T = - 1.0_r64 twod = . false . subs_masses = 0.0_r64 subs_conc = 0.0_r64 defect_hosts = - 1_i64 bound_length = 1.e12_r64 !mm, practically inifinity thinfilm_height = 1.e12_r64 !mm, practically inifinity thinfilm_normal = 'z' numdopants_types = [ 1 , 1 ] dopant_masses = 0.0_r64 dopant_conc = 0.0_r64 read ( 1 , nml = crystal_info ) if ( any ( atomtypes < 1 ) . or . T < 0.0_r64 ) then call exit_with_message ( 'Bad input(s) in crystal_info.' ) end if if (. not . autoisotopes . and . any ( masses < 0 )) then call exit_with_message ( 'Bad input(s) in crystal_info.' ) end if if ( bound_length <= 0.0_r64 ) then call exit_with_message ( 'Characteristic length for boundary scattering must be positive.' ) end if if ( thinfilm_height <= 0.0_r64 ) then call exit_with_message ( 'Height of thin-film must be positive.' ) end if if (. not . ( thinfilm_normal == 'x' . or . thinfilm_normal == 'y' . or . thinfilm_normal == 'z' )) then call exit_with_message ( \"Thin-film normal direction must be 'x', 'y', or 'z'.\" ) end if !Close input file close ( 1 ) self % name = name self % elements = elements self % atomtypes = atomtypes self % born = born self % epsilon = epsilon self % basis = basis self % polar = polar self % read_epsiloninf = read_epsiloninf self % epsilon0 = epsilon0 self % lattvecs = lattvecs self % T = T self % autoisotopes = autoisotopes self % masses = masses self % gfactors = 0.0_r64 self % twod = twod self % subs_masses = subs_masses self % subs_conc = subs_conc self % bound_length = bound_length self % thinfilm_height = thinfilm_height self % thinfilm_normal = thinfilm_normal self % defect_hosts = defect_hosts self % numdopants_types = numdopants_types if ( product ( numdopants_types ) <= 0 ) then call exit_with_message ( 'Number of dopant types must be a non-zero integer. Exiting.' ) end if if ( self % twod ) then if ( lattvecs ( 1 , 3 ) /= 0 . or . lattvecs ( 2 , 3 ) /= 0 . or . lattvecs ( 3 , 3 ) == 0 ) then call exit_with_message ( 'For 2d systems, cross plane lattice vector must be & &of the for (0 0 h).' ) end if self % thickness = lattvecs ( 3 , 3 ) self % dim = 2.0_r64 else self % dim = 3.0_r64 end if !Dopant masses and concentrations allocate ( self % dopant_masses ( maxval ( numdopants_types ), self % numelements ), & self % dopant_conc ( maxval ( numdopants_types ), self % numelements )) self % dopant_masses = 0.0_r64 self % dopant_conc = 0.0_r64 self % dopant_masses = dopant_masses ( 1 : size ( self % dopant_masses , 1 ), :) self % dopant_conc = dopant_conc ( 1 : size ( self % dopant_conc , 1 ), :) !Set high-frequency dielectric constant if ( self % read_epsiloninf ) then self % epsiloninf = epsiloninf else self % epsiloninf = trace ( self % epsilon ) / 3.0_r64 end if !If required, calculate isotopic average masses and g-factors if ( autoisotopes ) then call calculate_mavg_and_g ( self % elements , self % masses , self % gfactors ) end if !Calculate atomic basis in Cartesian coordinates self % basis_cart (:,:) = matmul ( self % lattvecs , self % basis ) !Calculate reciprocal lattice vectors and real and reciprocal cell volumes do i = 1 , 3 j = mod ( i , 3 ) + 1 k = mod ( j , 3 ) + 1 self % reclattvecs (:, i ) = & cross_product ( self % lattvecs (:, j ), self % lattvecs (:, k )) end do self % volume = abs ( dot_product ( self % lattvecs (:, 1 ), self % reclattvecs (:, 1 ))) self % volume_bz = twopi / self % volume self % reclattvecs (:,:) = self % volume_bz * self % reclattvecs (:,:) !Calculate the number of atoms of each type num_atomtypes (:) = 0_i64 do i = 1 , self % numelements do j = 1 , self % numatoms if ( self % atomtypes ( j ) == i ) num_atomtypes ( i ) = num_atomtypes ( i ) + 1 end do end do !Convert number concentration of substitutions to percentage !of replaced host atoms. if ( twod ) then subs_perc = self % subs_conc * ( 1.0e-14_r64 * self % volume / self % thickness ) / num_atomtypes * 10 0.0_r64 else subs_perc = self % subs_conc * ( 1.0e-21_r64 * self % volume ) / num_atomtypes * 10 0.0_r64 end if !Calculate the mass variance parameters for the substitutions do i = 1 , self % numelements !Impurity and host mixed mass subs_mavg = ( subs_perc ( i ) * self % subs_masses ( i ) + & ( 10 0.0_r64 - subs_perc ( i )) * self % masses ( i )) / 10 0.0_r64 !g-factor self % subs_gfactors ( i ) = subs_perc ( i ) * ( 1.0_r64 - self % subs_masses ( i ) / subs_mavg ) ** 2 + & ( 10 0.0_r64 - subs_perc ( i )) * ( 1.0_r64 - self % masses ( i ) / subs_mavg ) ** 2 end do self % subs_gfactors = self % subs_gfactors / 10 0.0_r64 !Print out crystal and reciprocal lattice information. if ( this_image () == 1 ) then write ( * , \"(A, A)\" ) 'Material: ' , self % name write ( * , \"(A)\" ) \"Basis atom sites ready to host a substitution:\" do i = 1 , self % numelements write ( * , '(A, A, A, I5)' ) \" \" , self % elements ( i ), \" at site \" , self % defect_hosts ( i ) end do if ( self % autoisotopes ) write ( * , \"(A)\" ) 'Isotopic average of masses will be used.' do i = 1 , self % numelements write ( * , \"(A, A, 1E16.8, A)\" ) trim ( self % elements ( i )), \" mass = \" , self % masses ( i ), \" u\" end do if ( any ( self % subs_conc /= 0.0_r64 )) then do i = 1 , self % numelements write ( * , \"(A, A, 1E16.8, A)\" ) & trim ( self % elements ( i )), \" substitution mass = \" , self % subs_masses ( i ), \" u\" end do do i = 1 , self % numelements write ( * , \"(A, A, 1E16.8, A)\" ) & trim ( self % elements ( i )), \" substitution amount = \" , subs_perc ( i ), \" %\" end do end if write ( * , \"(A)\" ) 'Lattice vectors [nm]:' write ( * , \"(3(1E16.8,x))\" ) self % lattvecs (:, 1 ) write ( * , \"(3(1E16.8,x))\" ) self % lattvecs (:, 2 ) write ( * , \"(3(1E16.8,x))\" ) self % lattvecs (:, 3 ) write ( * , \"(A,(1E16.8,x),A)\" ) 'Primitive cell volume =' , self % volume , 'nm&#94;3' write ( * , \"(A)\" ) 'Reciprocal lattice vectors [1/nm]:' write ( * , \"(3(1E16.8,x))\" ) self % reclattvecs (:, 1 ) write ( * , \"(3(1E16.8,x))\" ) self % reclattvecs (:, 2 ) write ( * , \"(3(1E16.8,x))\" ) self % reclattvecs (:, 3 ) write ( * , \"(A,(1E16.8,x),A)\" ) 'Brillouin zone volume =' , self % volume_bz , '1/nm&#94;3' if ( self % twod ) write ( * , \"(A)\" ) 'System is 2d.' if ( self % polar ) then write ( * , \"(A)\" ) 'System is polar.' write ( * , \"(A)\" ) 'Dielectric tensor:' do i = 1 , 3 write ( * , \"(3(1E16.8,x))\" ) self % epsilon (:, i ) end do write ( * , \"(A)\" ) 'Born effective charges:' do i = 1 , self % numatoms write ( * , \"(A)\" ) trim ( self % elements ( self % atomtypes ( i ))) do j = 1 , 3 write ( * , \"(3(1E16.8,x))\" ) self % born (:, j , i ) end do end do write ( * , \"(A,1E16.8)\" ) 'Static dielectric (used for screening e-ch. imp. interactions) = ' , self % epsilon0 write ( * , \"(A,1E16.8)\" ) 'High-frequency dielectric = ' , self % epsiloninf end if write ( * , \"(A, F7.2, A)\" ) 'Crystal temperature = ' , self % T , ' K' end if end subroutine read_input_and_setup_crystal subroutine calculate_wavevectors_full ( mesh , wavevecs , blocks , indexlist ) !! Calculate wave vectors (crystal coords.) of the full Brillouin zone (FBZ) !! !! mesh is the array of number of points along the reciprocal lattice vectors !! wavevecs is the list of all the wave vectors integer ( i64 ), intent ( in ) :: mesh ( 3 ) logical , intent ( in ) :: blocks integer ( i64 ), optional , intent ( in ) :: indexlist (:) real ( r64 ), allocatable , intent ( out ) :: wavevecs (:,:) integer ( i64 ) :: nwavevecs , ijk ( 3 ), i , imux if ( blocks . and . . not . present ( indexlist )) & call exit_with_message ( \"If blocks is true then indexlist must be present\" ) if ( blocks ) then nwavevecs = size ( indexlist ) else nwavevecs = product ( mesh ) end if allocate ( wavevecs ( nwavevecs , 3 )) do i = 1 , nwavevecs !run over total number of vectors if ( blocks ) then imux = indexlist ( i ) else imux = i end if call demux_vector ( imux , ijk , mesh , 0_i64 ) !get 0-based (i,j,k) indices wavevecs ( i ,:) = dble ( ijk ) / mesh !wave vectors in crystal coordinates end do end subroutine calculate_wavevectors_full subroutine calculate_mavg_and_g ( elements , m , g ) !! Compute the average mass of each element and its g-factor (Pearson !! deviation coefficient of the masses). !! !! This subroutine is adapted from ShengBTE. character ( len = 3 ), intent ( in ) :: elements (:) real ( r64 ), intent ( out ) :: m (:), g (:) !Local variables integer ( i64 ) :: i , niso , nelems , e character ( len = 3 ) :: isotope_element ( 287 ) real ( r64 ) :: isotope_mass ( 287 ) real ( r64 ) :: isotope_abundance ( 287 ) nelems = size ( elements ) niso = 287 ! Fill in isotope data. isotope_element ( 1 ) = \"Ag\" isotope_mass ( 1 ) = 10 6.905095_r64 isotope_abundance ( 1 ) = 5 1.84_r64 isotope_element ( 2 ) = \"Ag\" isotope_mass ( 2 ) = 10 8.904754_r64 isotope_abundance ( 2 ) = 4 8.16_r64 isotope_element ( 3 ) = \"Al\" isotope_mass ( 3 ) = 2 6.981541_r64 isotope_abundance ( 3 ) = 10 0.0_r64 isotope_element ( 4 ) = \"Ar\" isotope_mass ( 4 ) = 3 5.967546_r64 isotope_abundance ( 4 ) = 0.34_r64 isotope_element ( 5 ) = \"Ar\" isotope_mass ( 5 ) = 3 7.962732_r64 isotope_abundance ( 5 ) = 0.063_r64 isotope_element ( 6 ) = \"Ar\" isotope_mass ( 6 ) = 3 9.962383_r64 isotope_abundance ( 6 ) = 9 9.6_r64 isotope_element ( 7 ) = \"As\" isotope_mass ( 7 ) = 7 4.921596_r64 isotope_abundance ( 7 ) = 10 0.0_r64 isotope_element ( 8 ) = \"Au\" isotope_mass ( 8 ) = 19 6.96656_r64 isotope_abundance ( 8 ) = 10 0.0_r64 isotope_element ( 9 ) = \"B\" isotope_mass ( 9 ) = 1 0.012938_r64 isotope_abundance ( 9 ) = 1 9.8_r64 isotope_element ( 10 ) = \"B\" isotope_mass ( 10 ) = 1 1.009305_r64 isotope_abundance ( 10 ) = 8 0.2_r64 isotope_element ( 11 ) = \"Ba\" isotope_mass ( 11 ) = 12 9.906277_r64 isotope_abundance ( 11 ) = 0.11_r64 isotope_element ( 12 ) = \"Ba\" isotope_mass ( 12 ) = 13 1.905042_r64 isotope_abundance ( 12 ) = 0.1_r64 isotope_element ( 13 ) = \"Ba\" isotope_mass ( 13 ) = 13 3.90449_r64 isotope_abundance ( 13 ) = 2.42_r64 isotope_element ( 14 ) = \"Ba\" isotope_mass ( 14 ) = 13 4.905668_r64 isotope_abundance ( 14 ) = 6.59_r64 isotope_element ( 15 ) = \"Ba\" isotope_mass ( 15 ) = 13 5.904556_r64 isotope_abundance ( 15 ) = 7.85_r64 isotope_element ( 16 ) = \"Ba\" isotope_mass ( 16 ) = 13 6.905816_r64 isotope_abundance ( 16 ) = 1 1.23_r64 isotope_element ( 17 ) = \"Ba\" isotope_mass ( 17 ) = 13 7.905236_r64 isotope_abundance ( 17 ) = 7 1.7_r64 isotope_element ( 18 ) = \"Be\" isotope_mass ( 18 ) = 9.012183_r64 isotope_abundance ( 18 ) = 10 0.0_r64 isotope_element ( 19 ) = \"Bi\" isotope_mass ( 19 ) = 20 8.980388_r64 isotope_abundance ( 19 ) = 10 0.0_r64 isotope_element ( 20 ) = \"Br\" isotope_mass ( 20 ) = 7 8.918336_r64 isotope_abundance ( 20 ) = 5 0.69_r64 isotope_element ( 21 ) = \"Br\" isotope_mass ( 21 ) = 8 0.91629_r64 isotope_abundance ( 21 ) = 4 9.31_r64 isotope_element ( 22 ) = \"C\" isotope_mass ( 22 ) = 1 2.0_r64 isotope_abundance ( 22 ) = 9 8.9_r64 isotope_element ( 23 ) = \"C\" isotope_mass ( 23 ) = 1 3.003355_r64 isotope_abundance ( 23 ) = 1.1_r64 isotope_element ( 24 ) = \"Ca\" isotope_mass ( 24 ) = 3 9.962591_r64 isotope_abundance ( 24 ) = 9 6.95_r64 isotope_element ( 25 ) = \"Ca\" isotope_mass ( 25 ) = 4 1.958622_r64 isotope_abundance ( 25 ) = 0.65_r64 isotope_element ( 26 ) = \"Ca\" isotope_mass ( 26 ) = 4 2.95877_r64 isotope_abundance ( 26 ) = 0.14_r64 isotope_element ( 27 ) = \"Ca\" isotope_mass ( 27 ) = 4 3.955485_r64 isotope_abundance ( 27 ) = 2.086_r64 isotope_element ( 28 ) = \"Ca\" isotope_mass ( 28 ) = 4 5.953689_r64 isotope_abundance ( 28 ) = 0.004_r64 isotope_element ( 29 ) = \"Ca\" isotope_mass ( 29 ) = 4 7.952532_r64 isotope_abundance ( 29 ) = 0.19_r64 isotope_element ( 30 ) = \"Cd\" isotope_mass ( 30 ) = 10 5.906461_r64 isotope_abundance ( 30 ) = 1.25_r64 isotope_element ( 31 ) = \"Cd\" isotope_mass ( 31 ) = 10 7.904186_r64 isotope_abundance ( 31 ) = 0.89_r64 isotope_element ( 32 ) = \"Cd\" isotope_mass ( 32 ) = 10 9.903007_r64 isotope_abundance ( 32 ) = 1 2.49_r64 isotope_element ( 33 ) = \"Cd\" isotope_mass ( 33 ) = 11 0.904182_r64 isotope_abundance ( 33 ) = 1 2.8_r64 isotope_element ( 34 ) = \"Cd\" isotope_mass ( 34 ) = 11 1.902761_r64 isotope_abundance ( 34 ) = 2 4.13_r64 isotope_element ( 35 ) = \"Cd\" isotope_mass ( 35 ) = 11 2.904401_r64 isotope_abundance ( 35 ) = 1 2.22_r64 isotope_element ( 36 ) = \"Cd\" isotope_mass ( 36 ) = 11 3.903361_r64 isotope_abundance ( 36 ) = 2 8.73_r64 isotope_element ( 37 ) = \"Cd\" isotope_mass ( 37 ) = 11 5.904758_r64 isotope_abundance ( 37 ) = 7.49_r64 isotope_element ( 38 ) = \"Ce\" isotope_mass ( 38 ) = 13 5.90714_r64 isotope_abundance ( 38 ) = 0.19_r64 isotope_element ( 39 ) = \"Ce\" isotope_mass ( 39 ) = 13 7.905996_r64 isotope_abundance ( 39 ) = 0.25_r64 isotope_element ( 40 ) = \"Ce\" isotope_mass ( 40 ) = 13 9.905442_r64 isotope_abundance ( 40 ) = 8 8.48_r64 isotope_element ( 41 ) = \"Ce\" isotope_mass ( 41 ) = 14 1.909249_r64 isotope_abundance ( 41 ) = 1 1.08_r64 isotope_element ( 42 ) = \"Cl\" isotope_mass ( 42 ) = 3 4.968853_r64 isotope_abundance ( 42 ) = 7 5.77_r64 isotope_element ( 43 ) = \"Cl\" isotope_mass ( 43 ) = 3 6.965903_r64 isotope_abundance ( 43 ) = 2 4.23_r64 isotope_element ( 44 ) = \"Co\" isotope_mass ( 44 ) = 5 8.933198_r64 isotope_abundance ( 44 ) = 10 0.0_r64 isotope_element ( 45 ) = \"Cr\" isotope_mass ( 45 ) = 4 9.946046_r64 isotope_abundance ( 45 ) = 4.35_r64 isotope_element ( 46 ) = \"Cr\" isotope_mass ( 46 ) = 5 1.94051_r64 isotope_abundance ( 46 ) = 8 3.79_r64 isotope_element ( 47 ) = \"Cr\" isotope_mass ( 47 ) = 5 2.940651_r64 isotope_abundance ( 47 ) = 9.5_r64 isotope_element ( 48 ) = \"Cr\" isotope_mass ( 48 ) = 5 3.938882_r64 isotope_abundance ( 48 ) = 2.36_r64 isotope_element ( 49 ) = \"Cs\" isotope_mass ( 49 ) = 13 2.905433_r64 isotope_abundance ( 49 ) = 10 0.0_r64 isotope_element ( 50 ) = \"Cu\" isotope_mass ( 50 ) = 6 2.929599_r64 isotope_abundance ( 50 ) = 6 9.17_r64 isotope_element ( 51 ) = \"Cu\" isotope_mass ( 51 ) = 6 4.927792_r64 isotope_abundance ( 51 ) = 3 0.83_r64 isotope_element ( 52 ) = \"Dy\" isotope_mass ( 52 ) = 15 5.924287_r64 isotope_abundance ( 52 ) = 0.06_r64 isotope_element ( 53 ) = \"Dy\" isotope_mass ( 53 ) = 15 7.924412_r64 isotope_abundance ( 53 ) = 0.1_r64 isotope_element ( 54 ) = \"Dy\" isotope_mass ( 54 ) = 15 9.925203_r64 isotope_abundance ( 54 ) = 2.34_r64 isotope_element ( 55 ) = \"Dy\" isotope_mass ( 55 ) = 16 0.926939_r64 isotope_abundance ( 55 ) = 1 8.9_r64 isotope_element ( 56 ) = \"Dy\" isotope_mass ( 56 ) = 16 1.926805_r64 isotope_abundance ( 56 ) = 2 5.5_r64 isotope_element ( 57 ) = \"Dy\" isotope_mass ( 57 ) = 16 2.928737_r64 isotope_abundance ( 57 ) = 2 4.9_r64 isotope_element ( 58 ) = \"Dy\" isotope_mass ( 58 ) = 16 3.929183_r64 isotope_abundance ( 58 ) = 2 8.2_r64 isotope_element ( 59 ) = \"Er\" isotope_mass ( 59 ) = 16 1.928787_r64 isotope_abundance ( 59 ) = 0.14_r64 isotope_element ( 60 ) = \"Er\" isotope_mass ( 60 ) = 16 3.929211_r64 isotope_abundance ( 60 ) = 1.61_r64 isotope_element ( 61 ) = \"Er\" isotope_mass ( 61 ) = 16 5.930305_r64 isotope_abundance ( 61 ) = 3 3.6_r64 isotope_element ( 62 ) = \"Er\" isotope_mass ( 62 ) = 16 6.932061_r64 isotope_abundance ( 62 ) = 2 2.95_r64 isotope_element ( 63 ) = \"Er\" isotope_mass ( 63 ) = 16 7.932383_r64 isotope_abundance ( 63 ) = 2 6.8_r64 isotope_element ( 64 ) = \"Er\" isotope_mass ( 64 ) = 16 9.935476_r64 isotope_abundance ( 64 ) = 1 4.9_r64 isotope_element ( 65 ) = \"Eu\" isotope_mass ( 65 ) = 15 0.91986_r64 isotope_abundance ( 65 ) = 4 7.8_r64 isotope_element ( 66 ) = \"Eu\" isotope_mass ( 66 ) = 15 2.921243_r64 isotope_abundance ( 66 ) = 5 2.2_r64 isotope_element ( 67 ) = \"F\" isotope_mass ( 67 ) = 1 8.998403_r64 isotope_abundance ( 67 ) = 10 0.0_r64 isotope_element ( 68 ) = \"Fe\" isotope_mass ( 68 ) = 5 3.939612_r64 isotope_abundance ( 68 ) = 5.8_r64 isotope_element ( 69 ) = \"Fe\" isotope_mass ( 69 ) = 5 5.934939_r64 isotope_abundance ( 69 ) = 9 1.72_r64 isotope_element ( 70 ) = \"Fe\" isotope_mass ( 70 ) = 5 6.935396_r64 isotope_abundance ( 70 ) = 2.2_r64 isotope_element ( 71 ) = \"Fe\" isotope_mass ( 71 ) = 5 7.933278_r64 isotope_abundance ( 71 ) = 0.28_r64 isotope_element ( 72 ) = \"Ga\" isotope_mass ( 72 ) = 6 8.925581_r64 isotope_abundance ( 72 ) = 6 0.1_r64 isotope_element ( 73 ) = \"Ga\" isotope_mass ( 73 ) = 7 0.924701_r64 isotope_abundance ( 73 ) = 3 9.9_r64 isotope_element ( 74 ) = \"Gd\" isotope_mass ( 74 ) = 15 1.919803_r64 isotope_abundance ( 74 ) = 0.2_r64 isotope_element ( 75 ) = \"Gd\" isotope_mass ( 75 ) = 15 3.920876_r64 isotope_abundance ( 75 ) = 2.18_r64 isotope_element ( 76 ) = \"Gd\" isotope_mass ( 76 ) = 15 4.822629_r64 isotope_abundance ( 76 ) = 1 4.8_r64 isotope_element ( 77 ) = \"Gd\" isotope_mass ( 77 ) = 15 5.92213_r64 isotope_abundance ( 77 ) = 2 0.47_r64 isotope_element ( 78 ) = \"Gd\" isotope_mass ( 78 ) = 15 6.923967_r64 isotope_abundance ( 78 ) = 1 5.65_r64 isotope_element ( 79 ) = \"Gd\" isotope_mass ( 79 ) = 15 7.924111_r64 isotope_abundance ( 79 ) = 2 4.84_r64 isotope_element ( 80 ) = \"Gd\" isotope_mass ( 80 ) = 15 9.927061_r64 isotope_abundance ( 80 ) = 2 1.86_r64 isotope_element ( 81 ) = \"Ge\" isotope_mass ( 81 ) = 6 9.92425_r64 isotope_abundance ( 81 ) = 2 0.5_r64 isotope_element ( 82 ) = \"Ge\" isotope_mass ( 82 ) = 7 1.92208_r64 isotope_abundance ( 82 ) = 2 7.4_r64 isotope_element ( 83 ) = \"Ge\" isotope_mass ( 83 ) = 7 2.923464_r64 isotope_abundance ( 83 ) = 7.8_r64 isotope_element ( 84 ) = \"Ge\" isotope_mass ( 84 ) = 7 3.921179_r64 isotope_abundance ( 84 ) = 3 6.5_r64 isotope_element ( 85 ) = \"Ge\" isotope_mass ( 85 ) = 7 5.921403_r64 isotope_abundance ( 85 ) = 7.8_r64 isotope_element ( 86 ) = \"H\" isotope_mass ( 86 ) = 1.007825_r64 isotope_abundance ( 86 ) = 9 9.99_r64 isotope_element ( 87 ) = \"H\" isotope_mass ( 87 ) = 2.014102_r64 isotope_abundance ( 87 ) = 0.015_r64 isotope_element ( 88 ) = \"He\" isotope_mass ( 88 ) = 3.016029_r64 isotope_abundance ( 88 ) = 0.0001_r64 isotope_element ( 89 ) = \"He\" isotope_mass ( 89 ) = 4.002603_r64 isotope_abundance ( 89 ) = 10 0.0_r64 isotope_element ( 90 ) = \"Hf\" isotope_mass ( 90 ) = 17 3.940065_r64 isotope_abundance ( 90 ) = 0.16_r64 isotope_element ( 91 ) = \"Hf\" isotope_mass ( 91 ) = 17 5.94142_r64 isotope_abundance ( 91 ) = 5.2_r64 isotope_element ( 92 ) = \"Hf\" isotope_mass ( 92 ) = 17 6.943233_r64 isotope_abundance ( 92 ) = 1 8.6_r64 isotope_element ( 93 ) = \"Hf\" isotope_mass ( 93 ) = 17 7.94371_r64 isotope_abundance ( 93 ) = 2 7.1_r64 isotope_element ( 94 ) = \"Hf\" isotope_mass ( 94 ) = 17 8.945827_r64 isotope_abundance ( 94 ) = 1 3.74_r64 isotope_element ( 95 ) = \"Hf\" isotope_mass ( 95 ) = 17 9.946561_r64 isotope_abundance ( 95 ) = 3 5.2_r64 isotope_element ( 96 ) = \"Hg\" isotope_mass ( 96 ) = 19 5.965812_r64 isotope_abundance ( 96 ) = 0.15_r64 isotope_element ( 97 ) = \"Hg\" isotope_mass ( 97 ) = 19 7.96676_r64 isotope_abundance ( 97 ) = 1 0.1_r64 isotope_element ( 98 ) = \"Hg\" isotope_mass ( 98 ) = 19 8.968269_r64 isotope_abundance ( 98 ) = 1 7.0_r64 isotope_element ( 99 ) = \"Hg\" isotope_mass ( 99 ) = 19 9.968316_r64 isotope_abundance ( 99 ) = 2 3.1_r64 isotope_element ( 100 ) = \"Hg\" isotope_mass ( 100 ) = 20 0.970293_r64 isotope_abundance ( 100 ) = 1 3.2_r64 isotope_element ( 101 ) = \"Hg\" isotope_mass ( 101 ) = 20 1.970632_r64 isotope_abundance ( 101 ) = 2 9.65_r64 isotope_element ( 102 ) = \"Hg\" isotope_mass ( 102 ) = 20 3.973481_r64 isotope_abundance ( 102 ) = 6.8_r64 isotope_element ( 103 ) = \"Ho\" isotope_mass ( 103 ) = 16 4.930332_r64 isotope_abundance ( 103 ) = 10 0.0_r64 isotope_element ( 104 ) = \"I\" isotope_mass ( 104 ) = 12 6.904477_r64 isotope_abundance ( 104 ) = 10 0.0_r64 isotope_element ( 105 ) = \"In\" isotope_mass ( 105 ) = 11 2.904056_r64 isotope_abundance ( 105 ) = 4.3_r64 isotope_element ( 106 ) = \"In\" isotope_mass ( 106 ) = 11 4.903875_r64 isotope_abundance ( 106 ) = 9 5.7_r64 isotope_element ( 107 ) = \"Ir\" isotope_mass ( 107 ) = 19 0.960603_r64 isotope_abundance ( 107 ) = 3 7.3_r64 isotope_element ( 108 ) = \"Ir\" isotope_mass ( 108 ) = 19 2.962942_r64 isotope_abundance ( 108 ) = 6 2.7_r64 isotope_element ( 109 ) = \"K\" isotope_mass ( 109 ) = 3 8.963708_r64 isotope_abundance ( 109 ) = 9 3.2_r64 isotope_element ( 110 ) = \"K\" isotope_mass ( 110 ) = 3 9.963999_r64 isotope_abundance ( 110 ) = 0.012_r64 isotope_element ( 111 ) = \"K\" isotope_mass ( 111 ) = 4 0.961825_r64 isotope_abundance ( 111 ) = 6.73_r64 isotope_element ( 112 ) = \"Kr\" isotope_mass ( 112 ) = 7 7.920397_r64 isotope_abundance ( 112 ) = 0.35_r64 isotope_element ( 113 ) = \"Kr\" isotope_mass ( 113 ) = 7 9.916375_r64 isotope_abundance ( 113 ) = 2.25_r64 isotope_element ( 114 ) = \"Kr\" isotope_mass ( 114 ) = 8 1.913483_r64 isotope_abundance ( 114 ) = 1 1.6_r64 isotope_element ( 115 ) = \"Kr\" isotope_mass ( 115 ) = 8 2.914134_r64 isotope_abundance ( 115 ) = 1 1.5_r64 isotope_element ( 116 ) = \"Kr\" isotope_mass ( 116 ) = 8 3.911506_r64 isotope_abundance ( 116 ) = 5 7.0_r64 isotope_element ( 117 ) = \"Kr\" isotope_mass ( 117 ) = 8 5.910614_r64 isotope_abundance ( 117 ) = 1 7.3_r64 isotope_element ( 118 ) = \"La\" isotope_mass ( 118 ) = 13 7.907114_r64 isotope_abundance ( 118 ) = 0.09_r64 isotope_element ( 119 ) = \"La\" isotope_mass ( 119 ) = 13 8.906355_r64 isotope_abundance ( 119 ) = 9 9.91_r64 isotope_element ( 120 ) = \"Li\" isotope_mass ( 120 ) = 6.015123_r64 isotope_abundance ( 120 ) = 7.42_r64 isotope_element ( 121 ) = \"Li\" isotope_mass ( 121 ) = 7.016005_r64 isotope_abundance ( 121 ) = 9 2.58_r64 isotope_element ( 122 ) = \"Lu\" isotope_mass ( 122 ) = 17 4.940785_r64 isotope_abundance ( 122 ) = 9 7.4_r64 isotope_element ( 123 ) = \"Lu\" isotope_mass ( 123 ) = 17 5.942694_r64 isotope_abundance ( 123 ) = 2.6_r64 isotope_element ( 124 ) = \"Mg\" isotope_mass ( 124 ) = 2 3.985045_r64 isotope_abundance ( 124 ) = 7 8.9_r64 isotope_element ( 125 ) = \"Mg\" isotope_mass ( 125 ) = 2 4.985839_r64 isotope_abundance ( 125 ) = 1 0.0_r64 isotope_element ( 126 ) = \"Mg\" isotope_mass ( 126 ) = 2 5.982595_r64 isotope_abundance ( 126 ) = 1 1.1_r64 isotope_element ( 127 ) = \"Mn\" isotope_mass ( 127 ) = 5 4.938046_r64 isotope_abundance ( 127 ) = 10 0.0_r64 isotope_element ( 128 ) = \"Mo\" isotope_mass ( 128 ) = 9 1.906809_r64 isotope_abundance ( 128 ) = 1 4.84_r64 isotope_element ( 129 ) = \"Mo\" isotope_mass ( 129 ) = 9 3.905086_r64 isotope_abundance ( 129 ) = 9.25_r64 isotope_element ( 130 ) = \"Mo\" isotope_mass ( 130 ) = 9 4.905838_r64 isotope_abundance ( 130 ) = 1 5.92_r64 isotope_element ( 131 ) = \"Mo\" isotope_mass ( 131 ) = 9 5.904676_r64 isotope_abundance ( 131 ) = 1 6.68_r64 isotope_element ( 132 ) = \"Mo\" isotope_mass ( 132 ) = 9 6.906018_r64 isotope_abundance ( 132 ) = 9.55_r64 isotope_element ( 133 ) = \"Mo\" isotope_mass ( 133 ) = 9 7.905405_r64 isotope_abundance ( 133 ) = 2 4.13_r64 isotope_element ( 134 ) = \"Mo\" isotope_mass ( 134 ) = 9 9.907473_r64 isotope_abundance ( 134 ) = 9.63_r64 isotope_element ( 135 ) = \"N\" isotope_mass ( 135 ) = 1 4.003074_r64 isotope_abundance ( 135 ) = 9 9.63_r64 isotope_element ( 136 ) = \"N\" isotope_mass ( 136 ) = 1 5.000109_r64 isotope_abundance ( 136 ) = 0.37_r64 isotope_element ( 137 ) = \"Na\" isotope_mass ( 137 ) = 2 2.98977_r64 isotope_abundance ( 137 ) = 10 0.0_r64 isotope_element ( 138 ) = \"Nb\" isotope_mass ( 138 ) = 9 2.906378_r64 isotope_abundance ( 138 ) = 10 0.0_r64 isotope_element ( 139 ) = \"Nd\" isotope_mass ( 139 ) = 14 1.907731_r64 isotope_abundance ( 139 ) = 2 7.13_r64 isotope_element ( 140 ) = \"Nd\" isotope_mass ( 140 ) = 14 2.909823_r64 isotope_abundance ( 140 ) = 1 2.18_r64 isotope_element ( 141 ) = \"Nd\" isotope_mass ( 141 ) = 14 3.910096_r64 isotope_abundance ( 141 ) = 2 3.8_r64 isotope_element ( 142 ) = \"Nd\" isotope_mass ( 142 ) = 14 4.912582_r64 isotope_abundance ( 142 ) = 8.3_r64 isotope_element ( 143 ) = \"Nd\" isotope_mass ( 143 ) = 14 5.913126_r64 isotope_abundance ( 143 ) = 1 7.19_r64 isotope_element ( 144 ) = \"Nd\" isotope_mass ( 144 ) = 14 7.916901_r64 isotope_abundance ( 144 ) = 5.76_r64 isotope_element ( 145 ) = \"Nd\" isotope_mass ( 145 ) = 14 9.9209_r64 isotope_abundance ( 145 ) = 5.64_r64 isotope_element ( 146 ) = \"Ne\" isotope_mass ( 146 ) = 1 9.992439_r64 isotope_abundance ( 146 ) = 9 0.6_r64 isotope_element ( 147 ) = \"Ne\" isotope_mass ( 147 ) = 2 0.993845_r64 isotope_abundance ( 147 ) = 0.26_r64 isotope_element ( 148 ) = \"Ne\" isotope_mass ( 148 ) = 2 1.991384_r64 isotope_abundance ( 148 ) = 9.2_r64 isotope_element ( 149 ) = \"Ni\" isotope_mass ( 149 ) = 5 7.935347_r64 isotope_abundance ( 149 ) = 6 8.27_r64 isotope_element ( 150 ) = \"Ni\" isotope_mass ( 150 ) = 5 9.930789_r64 isotope_abundance ( 150 ) = 2 6.1_r64 isotope_element ( 151 ) = \"Ni\" isotope_mass ( 151 ) = 6 0.931059_r64 isotope_abundance ( 151 ) = 1.13_r64 isotope_element ( 152 ) = \"Ni\" isotope_mass ( 152 ) = 6 1.928346_r64 isotope_abundance ( 152 ) = 3.59_r64 isotope_element ( 153 ) = \"Ni\" isotope_mass ( 153 ) = 6 3.927968_r64 isotope_abundance ( 153 ) = 0.91_r64 isotope_element ( 154 ) = \"O\" isotope_mass ( 154 ) = 1 5.994915_r64 isotope_abundance ( 154 ) = 9 9.76_r64 isotope_element ( 155 ) = \"O\" isotope_mass ( 155 ) = 1 6.999131_r64 isotope_abundance ( 155 ) = 0.038_r64 isotope_element ( 156 ) = \"O\" isotope_mass ( 156 ) = 1 7.999159_r64 isotope_abundance ( 156 ) = 0.2_r64 isotope_element ( 157 ) = \"Os\" isotope_mass ( 157 ) = 18 3.952514_r64 isotope_abundance ( 157 ) = 0.02_r64 isotope_element ( 158 ) = \"Os\" isotope_mass ( 158 ) = 18 5.953852_r64 isotope_abundance ( 158 ) = 1.58_r64 isotope_element ( 159 ) = \"Os\" isotope_mass ( 159 ) = 18 6.955762_r64 isotope_abundance ( 159 ) = 1.6_r64 isotope_element ( 160 ) = \"Os\" isotope_mass ( 160 ) = 18 7.95585_r64 isotope_abundance ( 160 ) = 1 3.3_r64 isotope_element ( 161 ) = \"Os\" isotope_mass ( 161 ) = 18 8.958156_r64 isotope_abundance ( 161 ) = 1 6.1_r64 isotope_element ( 162 ) = \"Os\" isotope_mass ( 162 ) = 18 9.958455_r64 isotope_abundance ( 162 ) = 2 6.4_r64 isotope_element ( 163 ) = \"Os\" isotope_mass ( 163 ) = 19 1.961487_r64 isotope_abundance ( 163 ) = 4 1.0_r64 isotope_element ( 164 ) = \"P\" isotope_mass ( 164 ) = 3 0.973763_r64 isotope_abundance ( 164 ) = 10 0.0_r64 isotope_element ( 165 ) = \"Pb\" isotope_mass ( 165 ) = 20 3.973037_r64 isotope_abundance ( 165 ) = 1.4_r64 isotope_element ( 166 ) = \"Pb\" isotope_mass ( 166 ) = 20 5.974455_r64 isotope_abundance ( 166 ) = 2 4.1_r64 isotope_element ( 167 ) = \"Pb\" isotope_mass ( 167 ) = 20 6.975885_r64 isotope_abundance ( 167 ) = 2 2.1_r64 isotope_element ( 168 ) = \"Pb\" isotope_mass ( 168 ) = 20 7.976641_r64 isotope_abundance ( 168 ) = 5 2.4_r64 isotope_element ( 169 ) = \"Pd\" isotope_mass ( 169 ) = 10 1.905609_r64 isotope_abundance ( 169 ) = 1.02_r64 isotope_element ( 170 ) = \"Pd\" isotope_mass ( 170 ) = 10 3.904026_r64 isotope_abundance ( 170 ) = 1 1.14_r64 isotope_element ( 171 ) = \"Pd\" isotope_mass ( 171 ) = 10 4.905075_r64 isotope_abundance ( 171 ) = 2 2.33_r64 isotope_element ( 172 ) = \"Pd\" isotope_mass ( 172 ) = 10 5.903475_r64 isotope_abundance ( 172 ) = 2 7.33_r64 isotope_element ( 173 ) = \"Pd\" isotope_mass ( 173 ) = 10 7.903894_r64 isotope_abundance ( 173 ) = 2 6.46_r64 isotope_element ( 174 ) = \"Pd\" isotope_mass ( 174 ) = 10 9.905169_r64 isotope_abundance ( 174 ) = 1 1.72_r64 isotope_element ( 175 ) = \"Pr\" isotope_mass ( 175 ) = 14 0.907657_r64 isotope_abundance ( 175 ) = 10 0.0_r64 isotope_element ( 176 ) = \"Pt\" isotope_mass ( 176 ) = 18 9.959937_r64 isotope_abundance ( 176 ) = 0.01_r64 isotope_element ( 177 ) = \"Pt\" isotope_mass ( 177 ) = 19 1.961049_r64 isotope_abundance ( 177 ) = 0.79_r64 isotope_element ( 178 ) = \"Pt\" isotope_mass ( 178 ) = 19 3.962679_r64 isotope_abundance ( 178 ) = 3 2.9_r64 isotope_element ( 179 ) = \"Pt\" isotope_mass ( 179 ) = 19 4.964785_r64 isotope_abundance ( 179 ) = 3 3.8_r64 isotope_element ( 180 ) = \"Pt\" isotope_mass ( 180 ) = 19 5.964947_r64 isotope_abundance ( 180 ) = 2 5.3_r64 isotope_element ( 181 ) = \"Pt\" isotope_mass ( 181 ) = 19 7.967879_r64 isotope_abundance ( 181 ) = 7.2_r64 isotope_element ( 182 ) = \"Rb\" isotope_mass ( 182 ) = 8 4.9118_r64 isotope_abundance ( 182 ) = 7 2.17_r64 isotope_element ( 183 ) = \"Rb\" isotope_mass ( 183 ) = 8 6.909184_r64 isotope_abundance ( 183 ) = 2 7.84_r64 isotope_element ( 184 ) = \"Re\" isotope_mass ( 184 ) = 18 4.952977_r64 isotope_abundance ( 184 ) = 3 7.4_r64 isotope_element ( 185 ) = \"Re\" isotope_mass ( 185 ) = 18 6.955765_r64 isotope_abundance ( 185 ) = 6 2.6_r64 isotope_element ( 186 ) = \"Rh\" isotope_mass ( 186 ) = 10 2.905503_r64 isotope_abundance ( 186 ) = 10 0.0_r64 isotope_element ( 187 ) = \"Ru\" isotope_mass ( 187 ) = 9 5.907596_r64 isotope_abundance ( 187 ) = 5.52_r64 isotope_element ( 188 ) = \"Ru\" isotope_mass ( 188 ) = 9 7.905287_r64 isotope_abundance ( 188 ) = 1.88_r64 isotope_element ( 189 ) = \"Ru\" isotope_mass ( 189 ) = 9 8.905937_r64 isotope_abundance ( 189 ) = 1 2.7_r64 isotope_element ( 190 ) = \"Ru\" isotope_mass ( 190 ) = 9 9.904218_r64 isotope_abundance ( 190 ) = 1 2.6_r64 isotope_element ( 191 ) = \"Ru\" isotope_mass ( 191 ) = 10 0.905581_r64 isotope_abundance ( 191 ) = 1 7.0_r64 isotope_element ( 192 ) = \"Ru\" isotope_mass ( 192 ) = 10 1.904348_r64 isotope_abundance ( 192 ) = 3 1.6_r64 isotope_element ( 193 ) = \"Ru\" isotope_mass ( 193 ) = 10 3.905422_r64 isotope_abundance ( 193 ) = 1 8.7_r64 isotope_element ( 194 ) = \"S\" isotope_mass ( 194 ) = 3 1.972072_r64 isotope_abundance ( 194 ) = 9 5.02_r64 isotope_element ( 195 ) = \"S\" isotope_mass ( 195 ) = 3 2.971459_r64 isotope_abundance ( 195 ) = 0.75_r64 isotope_element ( 196 ) = \"S\" isotope_mass ( 196 ) = 3 3.967868_r64 isotope_abundance ( 196 ) = 4.21_r64 isotope_element ( 197 ) = \"S\" isotope_mass ( 197 ) = 3 5.967079_r64 isotope_abundance ( 197 ) = 0.02_r64 isotope_element ( 198 ) = \"Sb\" isotope_mass ( 198 ) = 12 0.903824_r64 isotope_abundance ( 198 ) = 5 7.3_r64 isotope_element ( 199 ) = \"Sb\" isotope_mass ( 199 ) = 12 2.904222_r64 isotope_abundance ( 199 ) = 4 2.7_r64 isotope_element ( 200 ) = \"Sc\" isotope_mass ( 200 ) = 4 4.955914_r64 isotope_abundance ( 200 ) = 10 0.0_r64 isotope_element ( 201 ) = \"Se\" isotope_mass ( 201 ) = 7 3.922477_r64 isotope_abundance ( 201 ) = 0.9_r64 isotope_element ( 202 ) = \"Se\" isotope_mass ( 202 ) = 7 5.919207_r64 isotope_abundance ( 202 ) = 9.0_r64 isotope_element ( 203 ) = \"Se\" isotope_mass ( 203 ) = 7 6.919908_r64 isotope_abundance ( 203 ) = 7.6_r64 isotope_element ( 204 ) = \"Se\" isotope_mass ( 204 ) = 7 7.917304_r64 isotope_abundance ( 204 ) = 2 3.5_r64 isotope_element ( 205 ) = \"Se\" isotope_mass ( 205 ) = 7 9.916521_r64 isotope_abundance ( 205 ) = 4 9.6_r64 isotope_element ( 206 ) = \"Se\" isotope_mass ( 206 ) = 8 1.916709_r64 isotope_abundance ( 206 ) = 9.4_r64 isotope_element ( 207 ) = \"Si\" isotope_mass ( 207 ) = 2 7.976928_r64 isotope_abundance ( 207 ) = 9 2.23_r64 isotope_element ( 208 ) = \"Si\" isotope_mass ( 208 ) = 2 8.976496_r64 isotope_abundance ( 208 ) = 4.67_r64 isotope_element ( 209 ) = \"Si\" isotope_mass ( 209 ) = 2 9.973772_r64 isotope_abundance ( 209 ) = 3.1_r64 isotope_element ( 210 ) = \"Sm\" isotope_mass ( 210 ) = 14 3.912009_r64 isotope_abundance ( 210 ) = 3.1_r64 isotope_element ( 211 ) = \"Sm\" isotope_mass ( 211 ) = 14 6.914907_r64 isotope_abundance ( 211 ) = 1 5.0_r64 isotope_element ( 212 ) = \"Sm\" isotope_mass ( 212 ) = 14 7.914832_r64 isotope_abundance ( 212 ) = 1 1.3_r64 isotope_element ( 213 ) = \"Sm\" isotope_mass ( 213 ) = 14 8.917193_r64 isotope_abundance ( 213 ) = 1 3.8_r64 isotope_element ( 214 ) = \"Sm\" isotope_mass ( 214 ) = 14 9.917285_r64 isotope_abundance ( 214 ) = 7.4_r64 isotope_element ( 215 ) = \"Sm\" isotope_mass ( 215 ) = 15 1.919741_r64 isotope_abundance ( 215 ) = 2 6.7_r64 isotope_element ( 216 ) = \"Sm\" isotope_mass ( 216 ) = 15 3.922218_r64 isotope_abundance ( 216 ) = 2 2.7_r64 isotope_element ( 217 ) = \"Sn\" isotope_mass ( 217 ) = 11 1.904826_r64 isotope_abundance ( 217 ) = 0.97_r64 isotope_element ( 218 ) = \"Sn\" isotope_mass ( 218 ) = 11 3.902784_r64 isotope_abundance ( 218 ) = 0.65_r64 isotope_element ( 219 ) = \"Sn\" isotope_mass ( 219 ) = 11 4.903348_r64 isotope_abundance ( 219 ) = 0.36_r64 isotope_element ( 220 ) = \"Sn\" isotope_mass ( 220 ) = 11 5.901744_r64 isotope_abundance ( 220 ) = 1 4.7_r64 isotope_element ( 221 ) = \"Sn\" isotope_mass ( 221 ) = 11 6.902954_r64 isotope_abundance ( 221 ) = 7.7_r64 isotope_element ( 222 ) = \"Sn\" isotope_mass ( 222 ) = 11 7.901607_r64 isotope_abundance ( 222 ) = 2 4.3_r64 isotope_element ( 223 ) = \"Sn\" isotope_mass ( 223 ) = 11 8.90331_r64 isotope_abundance ( 223 ) = 8.6_r64 isotope_element ( 224 ) = \"Sn\" isotope_mass ( 224 ) = 11 9.902199_r64 isotope_abundance ( 224 ) = 3 2.4_r64 isotope_element ( 225 ) = \"Sn\" isotope_mass ( 225 ) = 12 1.90344_r64 isotope_abundance ( 225 ) = 4.6_r64 isotope_element ( 226 ) = \"Sn\" isotope_mass ( 226 ) = 12 3.905271_r64 isotope_abundance ( 226 ) = 5.6_r64 isotope_element ( 227 ) = \"Sr\" isotope_mass ( 227 ) = 8 3.913428_r64 isotope_abundance ( 227 ) = 0.56_r64 isotope_element ( 228 ) = \"Sr\" isotope_mass ( 228 ) = 8 5.909273_r64 isotope_abundance ( 228 ) = 9.86_r64 isotope_element ( 229 ) = \"Sr\" isotope_mass ( 229 ) = 8 6.908902_r64 isotope_abundance ( 229 ) = 7.0_r64 isotope_element ( 230 ) = \"Sr\" isotope_mass ( 230 ) = 8 7.905625_r64 isotope_abundance ( 230 ) = 8 2.58_r64 isotope_element ( 231 ) = \"Ta\" isotope_mass ( 231 ) = 17 9.947489_r64 isotope_abundance ( 231 ) = 0.012_r64 isotope_element ( 232 ) = \"Ta\" isotope_mass ( 232 ) = 18 0.948014_r64 isotope_abundance ( 232 ) = 9 9.99_r64 isotope_element ( 233 ) = \"Tb\" isotope_mass ( 233 ) = 15 8.92535_r64 isotope_abundance ( 233 ) = 10 0.0_r64 isotope_element ( 234 ) = \"Te\" isotope_mass ( 234 ) = 11 9.904021_r64 isotope_abundance ( 234 ) = 0.096_r64 isotope_element ( 235 ) = \"Te\" isotope_mass ( 235 ) = 12 1.903055_r64 isotope_abundance ( 235 ) = 2.6_r64 isotope_element ( 236 ) = \"Te\" isotope_mass ( 236 ) = 12 2.904278_r64 isotope_abundance ( 236 ) = 0.91_r64 isotope_element ( 237 ) = \"Te\" isotope_mass ( 237 ) = 12 3.902825_r64 isotope_abundance ( 237 ) = 4.82_r64 isotope_element ( 238 ) = \"Te\" isotope_mass ( 238 ) = 12 4.904435_r64 isotope_abundance ( 238 ) = 7.14_r64 isotope_element ( 239 ) = \"Te\" isotope_mass ( 239 ) = 12 5.90331_r64 isotope_abundance ( 239 ) = 1 8.95_r64 isotope_element ( 240 ) = \"Te\" isotope_mass ( 240 ) = 12 7.904464_r64 isotope_abundance ( 240 ) = 3 1.69_r64 isotope_element ( 241 ) = \"Te\" isotope_mass ( 241 ) = 12 9.906229_r64 isotope_abundance ( 241 ) = 3 3.8_r64 isotope_element ( 242 ) = \"Th\" isotope_mass ( 242 ) = 23 2.038054_r64 isotope_abundance ( 242 ) = 10 0.0_r64 isotope_element ( 243 ) = \"Ti\" isotope_mass ( 243 ) = 4 5.952633_r64 isotope_abundance ( 243 ) = 8.0_r64 isotope_element ( 244 ) = \"Ti\" isotope_mass ( 244 ) = 4 6.951765_r64 isotope_abundance ( 244 ) = 7.3_r64 isotope_element ( 245 ) = \"Ti\" isotope_mass ( 245 ) = 4 7.947947_r64 isotope_abundance ( 245 ) = 7 3.8_r64 isotope_element ( 246 ) = \"Ti\" isotope_mass ( 246 ) = 4 8.947871_r64 isotope_abundance ( 246 ) = 5.5_r64 isotope_element ( 247 ) = \"Ti\" isotope_mass ( 247 ) = 4 9.944786_r64 isotope_abundance ( 247 ) = 5.4_r64 isotope_element ( 248 ) = \"Tl\" isotope_mass ( 248 ) = 20 2.972336_r64 isotope_abundance ( 248 ) = 2 9.52_r64 isotope_element ( 249 ) = \"Tl\" isotope_mass ( 249 ) = 20 4.97441_r64 isotope_abundance ( 249 ) = 7 0.48_r64 isotope_element ( 250 ) = \"Tm\" isotope_mass ( 250 ) = 16 8.934225_r64 isotope_abundance ( 250 ) = 10 0.0_r64 isotope_element ( 251 ) = \"U\" isotope_mass ( 251 ) = 23 4.040947_r64 isotope_abundance ( 251 ) = 0.006_r64 isotope_element ( 252 ) = \"U\" isotope_mass ( 252 ) = 23 5.043925_r64 isotope_abundance ( 252 ) = 0.72_r64 isotope_element ( 253 ) = \"U\" isotope_mass ( 253 ) = 23 8.050786_r64 isotope_abundance ( 253 ) = 9 9.27_r64 isotope_element ( 254 ) = \"V\" isotope_mass ( 254 ) = 4 9.947161_r64 isotope_abundance ( 254 ) = 0.25_r64 isotope_element ( 255 ) = \"V\" isotope_mass ( 255 ) = 5 0.943963_r64 isotope_abundance ( 255 ) = 9 9.75_r64 isotope_element ( 256 ) = \"W\" isotope_mass ( 256 ) = 17 9.946727_r64 isotope_abundance ( 256 ) = 0.13_r64 isotope_element ( 257 ) = \"W\" isotope_mass ( 257 ) = 18 1.948225_r64 isotope_abundance ( 257 ) = 2 6.3_r64 isotope_element ( 258 ) = \"W\" isotope_mass ( 258 ) = 18 2.950245_r64 isotope_abundance ( 258 ) = 1 4.3_r64 isotope_element ( 259 ) = \"W\" isotope_mass ( 259 ) = 18 3.950953_r64 isotope_abundance ( 259 ) = 3 0.67_r64 isotope_element ( 260 ) = \"W\" isotope_mass ( 260 ) = 18 5.954377_r64 isotope_abundance ( 260 ) = 2 8.6_r64 isotope_element ( 261 ) = \"Xe\" isotope_mass ( 261 ) = 12 3.905894_r64 isotope_abundance ( 261 ) = 0.1_r64 isotope_element ( 262 ) = \"Xe\" isotope_mass ( 262 ) = 12 5.904281_r64 isotope_abundance ( 262 ) = 0.09_r64 isotope_element ( 263 ) = \"Xe\" isotope_mass ( 263 ) = 12 7.903531_r64 isotope_abundance ( 263 ) = 1.91_r64 isotope_element ( 264 ) = \"Xe\" isotope_mass ( 264 ) = 12 8.90478_r64 isotope_abundance ( 264 ) = 2 6.4_r64 isotope_element ( 265 ) = \"Xe\" isotope_mass ( 265 ) = 12 9.90351_r64 isotope_abundance ( 265 ) = 4.1_r64 isotope_element ( 266 ) = \"Xe\" isotope_mass ( 266 ) = 13 0.905076_r64 isotope_abundance ( 266 ) = 2 1.2_r64 isotope_element ( 267 ) = \"Xe\" isotope_mass ( 267 ) = 13 1.904148_r64 isotope_abundance ( 267 ) = 2 6.9_r64 isotope_element ( 268 ) = \"Xe\" isotope_mass ( 268 ) = 13 3.905395_r64 isotope_abundance ( 268 ) = 1 0.4_r64 isotope_element ( 269 ) = \"Xe\" isotope_mass ( 269 ) = 13 5.907219_r64 isotope_abundance ( 269 ) = 8.9_r64 isotope_element ( 270 ) = \"Y\" isotope_mass ( 270 ) = 8 8.905856_r64 isotope_abundance ( 270 ) = 10 0.0_r64 isotope_element ( 271 ) = \"Yb\" isotope_mass ( 271 ) = 16 7.933908_r64 isotope_abundance ( 271 ) = 0.13_r64 isotope_element ( 272 ) = \"Yb\" isotope_mass ( 272 ) = 16 9.934774_r64 isotope_abundance ( 272 ) = 3.05_r64 isotope_element ( 273 ) = \"Yb\" isotope_mass ( 273 ) = 17 0.936338_r64 isotope_abundance ( 273 ) = 1 4.3_r64 isotope_element ( 274 ) = \"Yb\" isotope_mass ( 274 ) = 17 1.936393_r64 isotope_abundance ( 274 ) = 2 1.9_r64 isotope_element ( 275 ) = \"Yb\" isotope_mass ( 275 ) = 17 2.938222_r64 isotope_abundance ( 275 ) = 1 6.12_r64 isotope_element ( 276 ) = \"Yb\" isotope_mass ( 276 ) = 17 3.938873_r64 isotope_abundance ( 276 ) = 3 1.8_r64 isotope_element ( 277 ) = \"Yb\" isotope_mass ( 277 ) = 17 5.942576_r64 isotope_abundance ( 277 ) = 1 2.7_r64 isotope_element ( 278 ) = \"Zn\" isotope_mass ( 278 ) = 6 3.929145_r64 isotope_abundance ( 278 ) = 4 8.6_r64 isotope_element ( 279 ) = \"Zn\" isotope_mass ( 279 ) = 6 5.926035_r64 isotope_abundance ( 279 ) = 2 7.9_r64 isotope_element ( 280 ) = \"Zn\" isotope_mass ( 280 ) = 6 6.927129_r64 isotope_abundance ( 280 ) = 4.1_r64 isotope_element ( 281 ) = \"Zn\" isotope_mass ( 281 ) = 6 7.924846_r64 isotope_abundance ( 281 ) = 1 8.8_r64 isotope_element ( 282 ) = \"Zn\" isotope_mass ( 282 ) = 6 9.925325_r64 isotope_abundance ( 282 ) = 0.6_r64 isotope_element ( 283 ) = \"Zr\" isotope_mass ( 283 ) = 8 9.904708_r64 isotope_abundance ( 283 ) = 5 1.45_r64 isotope_element ( 284 ) = \"Zr\" isotope_mass ( 284 ) = 9 0.905644_r64 isotope_abundance ( 284 ) = 1 1.27_r64 isotope_element ( 285 ) = \"Zr\" isotope_mass ( 285 ) = 9 1.905039_r64 isotope_abundance ( 285 ) = 1 7.17_r64 isotope_element ( 286 ) = \"Zr\" isotope_mass ( 286 ) = 9 3.906319_r64 isotope_abundance ( 286 ) = 1 7.33_r64 isotope_element ( 287 ) = \"Zr\" isotope_mass ( 287 ) = 9 5.908272_r64 isotope_abundance ( 287 ) = 2.78_r64 do e = 1 , nelems m ( e ) = 0.0_r64 do i = 1 , niso if ( isotope_element ( i ) . eq . elements ( e )) then m ( e ) = m ( e ) + isotope_mass ( i ) * isotope_abundance ( i ) end if end do m ( e ) = m ( e ) / 10 0.0_r64 g ( e ) = 0.0_r64 do i = 1 , niso if ( isotope_element ( i ) . eq . elements ( e )) then g ( e ) = g ( e ) + isotope_abundance ( i ) * & ( 1.0_r64 - isotope_mass ( i ) / m ( e )) ** 2 end if end do g ( e ) = g ( e ) / 10 0.0_r64 end do end subroutine calculate_mavg_and_g end module crystal_module","tags":"","loc":"sourcefile/crystal.f90.html"},{"title":"wannier.f90 – elphbolt","text":"Contents Modules wannier_module Source Code wannier.f90 Source Code ! Copyright 2020 elphbolt contributors. ! This file is part of elphbolt <https://github.com/nakib/elphbolt>. ! ! elphbolt is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! elphbolt is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with elphbolt. If not, see <http://www.gnu.org/licenses/>. module wannier_module !! Module containing type and procedures related to Wannierization. use params , only : r64 , i64 , Ryd2eV , Ryd2radTHz , oneI , pi , twopi , twopiI , & Ryd2amu , bohr2nm use misc , only : exit_with_message , print_message , expi , twonorm , & distribute_points , demux_state , mux_vector , subtitle use numerics_module , only : numerics use crystal_module , only : crystal implicit none private public epw_wannier !external chdir type epw_wannier !! Data and procedures related to Wannierization. integer ( i64 ) :: numwannbands !! Number of Wannier bands. integer ( i64 ) :: numbranches !! Number of phonon branches. integer ( i64 ) :: nwsk !! Number of real space cells for electrons. integer ( i64 ) :: coarse_qmesh ( 3 ) !! Coarse phonon wave vector mesh in Wannier calculation. integer ( i64 ) :: nwsq !! Number of real space cells for phonons. integer ( i64 ) :: nwsg !! Number of real space cells for electron-phonon vertex. integer ( i64 ), allocatable :: rcells_k (:, :) !! Real space cell locations for electrons. integer ( i64 ), allocatable :: rcells_q (:, :) !! Real space cell locations for phonons. integer ( i64 ), allocatable :: rcells_g (:, :) !! Real space cell locations for electron-phonon vertex. integer ( i64 ), allocatable :: elwsdeg (:) !! Real space cell multiplicity for electrons. integer ( i64 ), allocatable :: phwsdeg (:) !! Real space cell multiplicity for phonons. integer ( i64 ), allocatable :: gwsdeg (:) !! Real space cell multiplicity for electron-phonon vertex. complex ( r64 ), allocatable :: Hwann (:, :, :) !! Hamiltonian in Wannier representation. complex ( r64 ), allocatable :: Dphwann (:, :, :) !! Dynamical matrix in Wannier representation. complex ( r64 ), allocatable :: gwann (:, :, :, :, :) !! e-ph vertex in Wannier representation. contains procedure :: read => read_EPW_Wannier , el_wann_epw , ph_wann_epw , & gkRp_epw , gReq_epw , g2_epw , deallocate_wannier , plot_along_path end type epw_wannier contains subroutine read_EPW_Wannier ( self , num ) !! Read Wannier representation of the hamiltonian, dynamical matrix, and the !! e-ph matrix elements from file epwdata.fmt. class ( epw_wannier ), intent ( out ) :: self type ( numerics ), intent ( in ) :: num !Local variables integer ( i64 ) :: iuc , ib , jb integer ( i64 ) :: coarse_qmesh ( 3 ) real ( r64 ) :: ef real ( r64 ), allocatable :: dummy (:) ! EPW File names: character ( len =* ), parameter :: filename_epwdata = \"epwdata.fmt\" character ( len =* ), parameter :: filename_epwgwann = \"epmatwp1\" character ( len =* ), parameter :: filename_elwscells = \"rcells_k\" character ( len =* ), parameter :: filename_phwscells = \"rcells_q\" character ( len =* ), parameter :: filename_gwscells = \"rcells_g\" character ( len =* ), parameter :: filename_elwsdeg = \"wsdeg_k\" character ( len =* ), parameter :: filename_phwsdeg = \"wsdeg_q\" character ( len =* ), parameter :: filename_gwsdeg = \"wsdeg_g\" namelist / wannier / coarse_qmesh call subtitle ( \"Reading EPW Wannier information...\" ) !Open input file open ( 1 , file = 'input.nml' , status = 'old' ) coarse_qmesh = ( / 0 , 0 , 0 / ) read ( 1 , nml = wannier ) if ( any ( coarse_qmesh <= 0 )) then call exit_with_message ( 'Bad input(s) in wannier.' ) end if self % coarse_qmesh = coarse_qmesh !Close input file close ( 1 ) open ( 1 , file = filename_epwdata , status = 'old' ) read ( 1 , * ) ef !Fermi energy. Read but ignored here. read ( 1 , * ) self % numwannbands , self % nwsk , self % numbranches , self % nwsq , self % nwsg allocate ( dummy (( self % numbranches / 3 + 1 ) * 9 )) !numatoms*9 Born, 9 epsilon elements. read ( 1 , * ) dummy !Born, epsilon. Read but ignored here. !Read real space hamiltonian call print_message ( \"Reading Wannier rep. Hamiltonian...\" ) allocate ( self % Hwann ( self % nwsk , self % numwannbands , self % numwannbands )) do ib = 1 , self % numwannbands do jb = 1 , self % numwannbands do iuc = 1 , self % nwsk !Number of real space electron cells read ( 1 , * ) self % Hwann ( iuc , ib , jb ) end do end do end do !Read real space dynamical matrix call print_message ( \"Reading Wannier rep. dynamical matrix...\" ) allocate ( self % Dphwann ( self % nwsq , self % numbranches , self % numbranches )) do ib = 1 , self % numbranches do jb = 1 , self % numbranches do iuc = 1 , self % nwsq !Number of real space phonon cells read ( 1 , * ) self % Dphwann ( iuc , ib , jb ) end do end do end do close ( 1 ) if (. not . num % read_gk2 . or . . not . num % read_gq2 . or . & num % plot_along_path ) then !Read real space matrix elements call print_message ( \"Reading Wannier rep. e-ph vertex...\" ) open ( 1 , file = filename_epwgwann , status = 'old' , access = 'stream' ) allocate ( self % gwann ( self % numwannbands , self % numwannbands , self % nwsk ,& self % numbranches , self % nwsg )) self % gwann = 0.0_r64 read ( 1 ) self % gwann end if close ( 1 ) !Read cell maps of q, k, g meshes. call print_message ( \"Reading Wannier cells and multiplicities...\" ) allocate ( self % rcells_k ( self % nwsk , 3 )) allocate ( self % elwsdeg ( self % nwsk )) open ( 1 , file = filename_elwscells , status = \"old\" ) open ( 2 , file = filename_elwsdeg , status = \"old\" ) do iuc = 1 , self % nwsk read ( 1 , * ) self % rcells_k ( iuc , :) read ( 2 , * ) self % elwsdeg ( iuc ) end do close ( 1 ) close ( 2 ) allocate ( self % rcells_q ( self % nwsq , 3 )) allocate ( self % phwsdeg ( self % nwsq )) open ( 1 , file = filename_phwscells , status = \"old\" ) open ( 2 , file = filename_phwsdeg , status = \"old\" ) do iuc = 1 , self % nwsq read ( 1 , * ) self % rcells_q ( iuc , :) read ( 2 , * ) self % phwsdeg ( iuc ) end do close ( 1 ) close ( 2 ) allocate ( self % rcells_g ( self % nwsg , 3 )) allocate ( self % gwsdeg ( self % nwsg )) open ( 1 , file = filename_gwscells , status = \"old\" ) open ( 2 , file = filename_gwsdeg , status = \"old\" ) do iuc = 1 , self % nwsg read ( 1 , * ) self % rcells_g ( iuc , :) read ( 2 , * ) self % gwsdeg ( iuc ) end do close ( 1 ) close ( 2 ) end subroutine read_EPW_Wannier subroutine el_wann_epw ( self , crys , nk , kvecs , energies , velocities , evecs , scissor ) !! Wannier interpolate electrons on list of arb. k-vecs class ( epw_wannier ), intent ( in ) :: self type ( crystal ), intent ( in ) :: crys integer ( i64 ), intent ( in ) :: nk real ( r64 ), intent ( in ) :: kvecs ( nk , 3 ) !Crystal coordinates real ( r64 ), intent ( out ) :: energies ( nk , self % numwannbands ) real ( r64 ), optional , intent ( out ) :: velocities ( nk , self % numwannbands , 3 ) complex ( r64 ), optional , intent ( out ) :: evecs ( nk , self % numwannbands , self % numwannbands ) real ( r64 ), optional , intent ( in ) :: scissor ( self % numwannbands ) !Local variables integer ( i64 ) :: iuc , ib , jb , ipol , ik , nwork , tmp real ( r64 ) :: rcart ( 3 ) real ( r64 ), allocatable :: rwork (:) complex ( r64 ), allocatable :: work (:) complex ( r64 ) :: caux , H ( self % numwannbands , self % numwannbands ), & dH ( 3 , self % numwannbands , self % numwannbands ) !External procedures external :: zheev !Catch error for optional velocity calculation if ( present ( velocities ) . and . . not . present ( evecs )) & call exit_with_message ( \"In Wannier, velocity is present but not eigenvecs.\" ) nwork = 1 allocate ( work ( nwork )) allocate ( rwork ( max ( 1 , 7 * self % numwannbands ))) do ik = 1 , nk !Form Hamiltonian (H) and k-derivative of H (dH) !from Hwann, rcells_k, and elwsdeg H = 0 dH = 0 do iuc = 1 , self % nwsk caux = expi ( twopi * dot_product ( kvecs ( ik ,:), self % rcells_k ( iuc ,:)))& / self % elwsdeg ( iuc ) H = H + caux * self % Hwann ( iuc ,:,:) if ( present ( velocities )) then rcart = matmul ( crys % lattvecs , self % rcells_k ( iuc ,:)) do ipol = 1 , 3 dH ( ipol ,:,:) = dH ( ipol ,:,:) + & oneI * rcart ( ipol ) * caux * self % Hwann ( iuc ,:,:) end do end if end do !Force Hermiticity do ib = 1 , self % numwannbands do jb = ib + 1 , self % numwannbands H ( ib , jb ) = ( H ( ib , jb ) + conjg ( H ( jb , ib ))) * 0.5_r64 H ( jb , ib ) = H ( ib , jb ) end do end do !Diagonalize H call zheev ( \"V\" , \"U\" , self % numwannbands , H (:,:), self % numwannbands , energies ( ik ,:), & work , - 1_i64 , rwork , tmp ) if ( real ( work ( 1 )) > nwork ) then nwork = nint ( 2 * real ( work ( 1 ))) deallocate ( work ) allocate ( work ( nwork )) end if call zheev ( \"V\" , \"U\" , self % numwannbands , H (:,:), self % numwannbands , energies ( ik ,:), & work , nwork , rwork , tmp ) !These quantities are U&#94;dagger. See Eq. 31 or prb 76, 165108. if ( present ( evecs )) then evecs ( ik ,:,:) = transpose ( H (:,:)) end if if ( present ( velocities )) then !Calculate velocities using Feynman-Hellmann thm do ib = 1 , self % numwannbands do ipol = 1 , 3 velocities ( ik , ib , ipol ) = real ( dot_product ( evecs ( ik , ib ,:), & matmul ( dH ( ipol ,:,:), evecs ( ik , ib ,:)))) end do end do end if !energies(ik,:) = energies(ik,:)*Rydberg2radTHz !2piTHz energies ( ik ,:) = energies ( ik ,:) * Ryd2eV !eV !If present, apply the scissor operator to conduction bands if ( present ( scissor )) then energies ( ik ,:) = energies ( ik ,:) + scissor (:) end if if ( present ( velocities )) then velocities ( ik ,:,:) = velocities ( ik ,:,:) * Ryd2radTHz !nmTHz = Km/s end if end do !ik end subroutine el_wann_epw subroutine ph_wann_epw ( self , crys , nq , qvecs , energies , evecs ) !! Wannier interpolate phonons on list of arb. q-vec class ( epw_wannier ), intent ( in ) :: self type ( crystal ), intent ( in ) :: crys !Local variables integer ( i64 ), intent ( in ) :: nq real ( r64 ), intent ( in ) :: qvecs ( nq , 3 ) !Crystal coordinates real ( r64 ), intent ( out ) :: energies ( nq , self % numbranches ) complex ( r64 ), intent ( out ), optional :: evecs ( nq , self % numbranches , self % numbranches ) integer ( i64 ) :: iuc , ib , jb , iq , na , nb , nwork , aux complex ( r64 ) :: caux real ( r64 ), allocatable :: rwork (:) complex ( r64 ), allocatable :: work (:) real ( r64 ) :: omega2 ( self % numbranches ), massnorm complex ( r64 ) :: dynmat ( self % numbranches , self % numbranches ) !External procedures external :: zheev nwork = 1 allocate ( work ( nwork )) allocate ( rwork ( max ( 1 , 9 * crys % numatoms - 2 ))) do iq = 1 , nq !Form dynamical matrix dynmat = ( 0.0_r64 , 0.0_r64 ) do iuc = 1 , self % nwsq caux = expi ( twopi * dot_product ( qvecs ( iq , :), self % rcells_q ( iuc , :)))& / self % phwsdeg ( iuc ) dynmat = dynmat + caux * self % Dphwann ( iuc , :, :) end do !Non-analytic correction if ( crys % polar ) then call dyn_nonanalytic ( self , crys , matmul ( crys % reclattvecs , qvecs ( iq ,:)) * bohr2nm , dynmat ) end if !Force Hermiticity do ib = 1 , self % numbranches do jb = ib + 1 , self % numbranches dynmat ( ib , jb ) = ( dynmat ( ib , jb ) + conjg ( dynmat ( jb , ib ))) * 0.5_r64 dynmat ( jb , ib ) = dynmat ( ib , jb ) end do end do !Mass normalize do na = 1 , crys % numatoms do nb = 1 , crys % numatoms massnorm = 1.d0 / sqrt ( crys % masses ( crys % atomtypes ( na )) * & crys % masses ( crys % atomtypes ( nb ))) * Ryd2amu dynmat ( 3 * ( na - 1 ) + 1 : 3 * na , 3 * ( nb - 1 ) + 1 : 3 * nb ) = & dynmat ( 3 * ( na - 1 ) + 1 : 3 * na , 3 * ( nb - 1 ) + 1 : 3 * nb ) * massnorm end do end do !Diagonalize dynmat call zheev ( \"V\" , \"U\" , self % numbranches , dynmat (:, :), self % numbranches , omega2 , work , - 1_i64 , rwork , aux ) if ( real ( work ( 1 )) > nwork ) then nwork = nint ( 2 * real ( work ( 1 ))) deallocate ( work ) allocate ( work ( nwork )) end if call zheev ( \"V\" , \"U\" , self % numbranches , dynmat (:, :), self % numbranches , omega2 , work , nwork , rwork , aux ) energies ( iq , :) = sign ( sqrt ( abs ( omega2 )), omega2 ) !These quantities are u. See Eq. 32 or prb 76, 165108. if ( present ( evecs )) then evecs ( iq , :, :) = transpose ( dynmat (:, :)) end if !energies(iq, :) = energies(iq, :)*Rydberg2radTHz !2piTHz !energies(iq, :) = energies(iq, :)*Rydberg2eV*1.0e3_r64 !meV energies ( iq , :) = energies ( iq , :) * Ryd2eV !eV !Take care of gamma point. if ( all ( qvecs ( iq ,:) == 0 )) then energies ( iq , 1 : 3 ) = 0 end if !Handle negative energy phonons do ib = 1 , self % numbranches if ( energies ( iq , ib ) < - 0.005_r64 ) then call exit_with_message ( 'Large negative phonon energy found! Stopping!' ) else if ( energies ( iq , ib ) < 0 . and . energies ( iq , ib ) > - 0.005_r64 ) then energies ( iq , ib ) = 0 end if end do end do !iq end subroutine ph_wann_epw subroutine dyn_nonanalytic ( self , crys , q , dyn ) !! Calculate the long-range correction to the !! dynamical matrix and its derivative for a given phonon mode. !! !! q: the phonon wave vector in Cartesian coords., Bohr&#94;-1 !! dyn: the dynamical matrix ! ! This is adapted from ShengBTE's subroutine phonon_espresso. ! ShengBTE is distributed under GPL v3 or later. class ( epw_wannier ), intent ( in ) :: self type ( crystal ), intent ( in ) :: crys !Local variables real ( r64 ), intent ( in ) :: q ( 3 ) !Cartesian complex ( r64 ), intent ( inout ) :: dyn ( self % numbranches , self % numbranches ) complex ( r64 ) :: dyn_l ( self % numbranches , self % numbranches ), fnat ( 3 ) real ( r64 ) :: qeq , arg , zig ( 3 ), zjg ( 3 ), g ( 3 ), gmax , alph , & tpiba , dgeg ( 3 ), rr ( crys % numatoms , crys % numatoms , 3 ) integer ( i64 ) :: iat , jat , idim , jdim , ipol , jpol , m1 , m2 , m3 , nq1 , nq2 , nq3 complex ( r64 ) :: fac , facqd , facq tpiba = twopi / twonorm ( crys % lattvecs (:, 1 )) * bohr2nm !Recall that the phonon supercell in elphbolt is the !same as the EPW coarse phonon mesh. nq1 = self % coarse_qmesh ( 1 ) nq2 = self % coarse_qmesh ( 2 ) nq3 = self % coarse_qmesh ( 3 ) gmax = 1 4.0_r64 !dimensionless alph = tpiba ** 2 !bohr&#94;-2 !In Ry units, qe = sqrt(2.0) fac = 8.0_r64 * pi / ( crys % volume / bohr2nm ** 3 ) dyn_l = ( 0.0_r64 , 0.0_r64 ) do m1 = - nq1 , nq1 do m2 = - nq2 , nq2 do m3 = - nq3 , nq3 g (:) = ( m1 * crys % reclattvecs (:, 1 ) + m2 * crys % reclattvecs (:, 2 ) + m3 * crys % reclattvecs (:, 3 )) * bohr2nm qeq = dot_product ( g , matmul ( crys % epsilon , g )) if ( qeq > 0.0_r64 . and . qeq / alph / 4.0_r64 < gmax ) then facqd = exp ( - qeq / alph / 4.0_r64 ) / qeq do iat = 1 , crys % numatoms zig (:) = matmul ( g , crys % born (:,:, iat )) fnat (:) = ( 0.0_r64 , 0.0_r64 ) do jat = 1 , crys % numatoms rr ( iat , jat ,:) = ( crys % basis_cart (:, iat ) - crys % basis_cart (:, jat )) / bohr2nm arg = dot_product ( g , rr ( iat , jat ,:)) zjg (:) = matmul ( g , crys % born (:,:, jat )) fnat (:) = fnat (:) + zjg (:) * expi ( arg ) end do do ipol = 1 , 3 idim = ( iat - 1 ) * 3 + ipol do jpol = 1 , 3 jdim = ( iat - 1 ) * 3 + jpol dyn_l ( idim , jdim ) = dyn_l ( idim , jdim ) - & facqd * zig ( ipol ) * fnat ( jpol ) end do end do end do end if g = g + q qeq = dot_product ( g , matmul ( crys % epsilon , g )) if ( qeq > 0.0_r64 . and . qeq / alph / 4.0_r64 < gmax ) then facqd = exp ( - qeq / alph / 4.0_r64 ) / qeq dgeg = matmul ( crys % epsilon + transpose ( crys % epsilon ), g ) do iat = 1 , crys % numatoms zig (:) = matmul ( g , crys % born (:,:, iat )) do jat = 1 , crys % numatoms rr ( iat , jat ,:) = ( crys % basis_cart (:, iat ) - crys % basis_cart (:, jat )) / bohr2nm zjg (:) = matmul ( g , crys % born (:,:, jat )) arg = dot_product ( g , rr ( iat , jat ,:)) facq = facqd * expi ( arg ) do ipol = 1 , 3 idim = ( iat - 1 ) * 3 + ipol do jpol = 1 , 3 jdim = ( jat - 1 ) * 3 + jpol dyn_l ( idim , jdim ) = dyn_l ( idim , jdim ) + facq * & zig ( ipol ) * zjg ( jpol ) end do end do end do end do end if end do end do end do dyn = dyn + dyn_l * fac end subroutine dyn_nonanalytic function g2_epw ( self , crys , kvec , qvec , el_evec_k , el_evec_kp , ph_evec_q , ph_en , & gmixed , wannspace ) !! Function to calculate |g|&#94;2. !! This works with EPW real space data !! kvec: electron wave vector in crystal coords !! qvec: phonon wave vector in crystal coords !! el_evec_k(kp): initial(final) electron eigenvector in bands m(n) !! ph_evec_q: phonon eigenvector branchs !! ph_en: phonon energy in mode (s,qvec) !! gmixed: e-ph matrix element in mixed Wannier-Bloch representation !! wannspace: the species that is in Wannier representation class ( epw_wannier ), intent ( in ) :: self type ( crystal ), intent ( in ) :: crys real ( r64 ), intent ( in ) :: kvec ( 3 ), qvec ( 3 ), ph_en complex ( r64 ), intent ( in ) :: el_evec_k ( self % numwannbands ),& el_evec_kp ( self % numwannbands ), ph_evec_q ( self % numbranches ), & gmixed (:,:,:,:) character ( len = 2 ) :: wannspace real ( r64 ), parameter :: g2unitfactor = Ryd2eV ** 3 * Ryd2amu !Local variables integer ( i64 ) :: ip , iws , nws , np , mp , sp , mtype complex ( r64 ) :: caux , u ( self % numbranches ), gbloch , unm , & overlap ( self % numwannbands , self % numwannbands ), glprefac complex ( r64 ), allocatable :: UkpgUkdag (:, :), UkpgUkdaguq (:) real ( r64 ) :: g2_epw if ( wannspace /= 'el' . and . wannspace /= 'ph' ) then call exit_with_message (& \"Invalid value of wannspace in call to g2_epw. Exiting.\" ) end if !Mass normalize the phonon matrix do ip = 1 , self % numbranches ! d.o.f of basis atoms !demux atom type from d.o.f mtype = ( ip - 1 ) / 3 + 1 !normalize u ( ip ) = ph_evec_q ( ip ) / sqrt ( crys % masses ( crys % atomtypes ( mtype ))) end do if ( ph_en == 0 ) then !zero out matrix elements for zero energy phonons g2_epw = 0 else if ( wannspace == 'ph' ) then nws = self % nwsg else nws = self % nwsk end if allocate ( UkpgUkdag ( self % numbranches , nws ), UkpgUkdaguq ( nws )) !See Eq. 22 of prb 76, 165108. UkpgUkdag = 0 !g(k,Rp) or g(Re,q) (un)rotated by the electron U&#94;\\dagger(k) and U(k') matrices UkpgUkdaguq = 0 !above quantity (un)rotated by the phonon u(q) matrix gbloch = 0 !Create the matrix U_nn'(k')U_m'm&#94;\\dagger(k) do np = 1 , self % numwannbands !over final electron band do mp = 1 , self % numwannbands !over initial electron band !(Recall that the electron eigenvectors came out daggered from el_wann_epw.) overlap ( mp , np ) = conjg ( el_evec_kp ( np )) * el_evec_k ( mp ) end do end do do iws = 1 , nws !over matrix elements WS cell !Apply electron rotations do sp = 1 , self % numbranches caux = 0 do np = 1 , self % numwannbands !over final electron band do mp = 1 , self % numwannbands !over initial electron band caux = caux + overlap ( mp , np ) * gmixed ( np , mp , sp , iws ) end do end do UkpgUkdag ( sp , iws ) = UkpgUkdag ( sp , iws ) + caux end do end do do iws = 1 , nws !over matrix elements WS cell !Apply phonon rotation !(Recall that the phonon eigenvector *did not* come out pre-daggered from ph_wann_epw.) UkpgUkdaguq ( iws ) = UkpgUkdaguq ( iws ) + dot_product ( conjg ( u ), UkpgUkdag (:, iws )) end do do iws = 1 , nws !over matrix elements WS cell !Fourier transform to reciprocal-space if ( wannspace == 'ph' ) then caux = expi ( twopi * dot_product ( qvec , self % rcells_g ( iws , :)))& / self % gwsdeg ( iws ) else caux = expi ( twopi * dot_product ( kvec , self % rcells_k ( iws ,:)))& / self % elwsdeg ( iws ) end if gbloch = gbloch + caux * UkpgUkdaguq ( iws ) end do if ( crys % polar ) then !Long-range correction !This is [U(k')U&#94;\\dagger(k)]_nm, the overlap factor in the dipole correction. !(Recall that the electron eigenvectors came out daggered from el_wann_epw.) unm = dot_product ( el_evec_kp , el_evec_k ) call long_range_prefac ( self , crys , & matmul ( crys % reclattvecs , qvec ) * bohr2nm , u , glprefac ) gbloch = gbloch + glprefac * unm end if g2_epw = 0.5_r64 * real ( gbloch * conjg ( gbloch )) / & ph_en * g2unitfactor !eV&#94;2 end if end function g2_epw subroutine long_range_prefac ( self , crys , q , uqs , glprefac ) !! Calculate the long-range correction prefactor of !! the e-ph matrix element for a given phonon mode. !! q: phonon wvec in Cartesian coords., Bohr&#94;-1 !! uqs: phonon eigenfn for mode (s,q) !! glprefac: is the output in Ry units (EPW/QE) ! ! This is similar to the subroutine dyn_nonanalytic above, ! adapted from ShengBTE's subroutine phonon_espresso. ! ShengBTE is distributed under GPL v3 or later. class ( epw_wannier ), intent ( in ) :: self type ( crystal ), intent ( in ) :: crys real ( r64 ), intent ( in ) :: q ( 3 ) !Cartesian complex ( r64 ), intent ( in ) :: uqs ( self % numbranches ) complex ( r64 ), intent ( out ) :: glprefac real ( r64 ) :: qeq , arg , zaq , g ( 3 ), gmax , alph , tpiba integer ( i64 ) :: na , ipol , m1 , m2 , m3 , nq1 , nq2 , nq3 complex ( r64 ) :: fac , facqd , facq tpiba = twopi / twonorm ( crys % lattvecs (:, 1 )) * bohr2nm !Recall that the phonon supercell in elphbolt is the !same as the EPW coarse phonon mesh. nq1 = self % coarse_qmesh ( 1 ) nq2 = self % coarse_qmesh ( 2 ) nq3 = self % coarse_qmesh ( 3 ) gmax = 1 4.d0 !dimensionless alph = tpiba ** 2 !bohr&#94;-2 !In Ry units, qe = sqrt(2.0) and epsilon_0 = 1/(4\\pi) fac = 8.d0 * pi / ( crys % volume / bohr2nm ** 3 ) * oneI glprefac = ( 0.d0 , 0.d0 ) do m1 = - nq1 , nq1 do m2 = - nq2 , nq2 do m3 = - nq3 , nq3 g (:) = ( m1 * crys % reclattvecs (:, 1 ) + m2 * crys % reclattvecs (:, 2 ) + m3 * crys % reclattvecs (:, 3 )) * bohr2nm + q qeq = dot_product ( g , matmul ( crys % epsilon , g )) if ( qeq > 0.d0 . and . qeq / alph / 4.d0 < gmax ) then facqd = exp ( - qeq / alph / 4.0d0 ) / qeq do na = 1 , crys % numatoms arg = - dot_product ( g , crys % basis_cart (:, na )) / bohr2nm facq = facqd * expi ( arg ) do ipol = 1 , 3 zaq = dot_product ( g , crys % born (:, ipol , na )) glprefac = glprefac + facq * zaq * uqs ( 3 * ( na - 1 ) + ipol ) end do end do end if end do end do end do glprefac = glprefac * fac end subroutine long_range_prefac subroutine gkRp_epw ( self , num , ik , kvec ) !! Calculate the Bloch-Wannier mixed rep. e-ph matrix elements g(k,Rp), !! where k is an IBZ electron wave vector and Rp is a phonon unit cell. !! Note: this step *DOES NOT* perform the rotation over the Wannier bands space. !! !! The result will be saved to disk tagged with k-index. class ( epw_wannier ), intent ( in ) :: self type ( numerics ), intent ( in ) :: num integer ( i64 ), intent ( in ) :: ik real ( r64 ), intent ( in ) :: kvec ( 3 ) !Local variables integer ( i64 ) :: iuc complex ( r64 ) :: caux complex ( r64 ), allocatable :: gmixed (:,:,:,:) character ( len = 1024 ) :: filename allocate ( gmixed ( self % numwannbands , self % numwannbands , self % numbranches , self % nwsq )) !Fourier transform to k-space gmixed = 0 do iuc = 1 , self % nwsk caux = expi ( twopi * dot_product ( kvec , self % rcells_k ( iuc ,:))) / self % elwsdeg ( iuc ) gmixed (:,:,:,:) = gmixed (:,:,:,:) + caux * self % gwann (:,:, iuc ,:,:) end do !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) ik filename = 'gkRp.ik' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) gmixed close ( 1 ) !Change back to working directory call chdir ( num % cwd ) end subroutine gkRp_epw subroutine gReq_epw ( self , num , iq , qvec ) !! Calculate the Bloch-Wannier mixed rep. e-ph matrix elements g(Re,q), !! where q is an IBZ phonon wave vector and Re is a phonon unit cell. !! Note: this step *DOES NOT* perform the rotation over the Wannier bands space. !! !! The result will be saved to disk tagged with k-index. class ( epw_wannier ), intent ( in ) :: self type ( numerics ), intent ( in ) :: num integer ( i64 ), intent ( in ) :: iq real ( r64 ), intent ( in ) :: qvec ( 3 ) !Local variables integer ( i64 ) :: iuc , s complex ( r64 ) :: caux complex ( r64 ), allocatable :: gmixed (:,:,:,:) character ( len = 1024 ) :: filename allocate ( gmixed ( self % numwannbands , self % numwannbands , self % numbranches , self % nwsk )) !Fourier transform to q-space gmixed = 0 do iuc = 1 , self % nwsg caux = expi ( twopi * dot_product ( qvec , self % rcells_g ( iuc ,:))) / self % gwsdeg ( iuc ) do s = 1 , self % numbranches gmixed (:,:, s ,:) = gmixed (:,:, s ,:) + caux * self % gwann (:,:,:, s , iuc ) end do end do !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) !Write data in binary format !Note: this will overwrite existing data! write ( filename , '(I9)' ) iq filename = 'gReq.iq' // trim ( adjustl ( filename )) open ( 1 , file = trim ( filename ), status = 'replace' , access = 'stream' ) write ( 1 ) gmixed close ( 1 ) !Change back to working directory call chdir ( num % cwd ) end subroutine gReq_epw subroutine deallocate_wannier ( self , num ) !! Deallocates some Wannier quantities class ( epw_wannier ), intent ( inout ) :: self type ( numerics ), intent ( in ) :: num deallocate ( self % rcells_k , self % rcells_q , self % rcells_g , & self % elwsdeg , self % phwsdeg , self % gwsdeg , & self % Hwann , self % Dphwann ) if (. not . num % read_gk2 . and . . not . num % read_gq2 . or . & num % plot_along_path ) then deallocate ( self % gwann ) end if end subroutine deallocate_wannier subroutine plot_along_path ( self , crys , num , scissor ) !! Subroutine to plot bands, dispersions, e-ph matrix elements !! using the Wannier interpolation method with EPW inputs. class ( epw_wannier ), intent ( in ) :: self type ( crystal ), intent ( in ) :: crys type ( numerics ), intent ( in ) :: num real ( r64 ), intent ( in ) :: scissor ( self % numwannbands ) !Local variables integer ( i64 ) :: i , nqpath , m , n , s , deg_count , mp , np , sp , icart real ( r64 ) :: k ( 1 , 3 ), kp ( 1 , 3 ), thres , aux , el_en , ph_en real ( r64 ), allocatable :: qpathvecs (:,:), ph_ens_path (:,:), & el_ens_path (:,:), el_ens_kp (:,:), & el_vels_kp (:,:,:), g2_qpath (:,:,:,:), el_ens_k (:,:), el_vels_k (:,:,:) complex ( r64 ), allocatable :: ph_evecs_path (:,:,:), el_evecs_kp (:,:,:), & el_evecs_k (:,:,:), gmixed_k (:,:,:,:) character ( len = 1024 ) :: filename character ( len = 8 ) :: saux call print_message ( \"Plotting bands, dispersions, and e-ph vertex along path...\" ) if ( this_image () == 1 ) then !Threshold used to measure degeneracy thres = 1.0e-6_r64 !0.001 meV !Read list of wavevectors in crystal coordinates open ( 1 , file = trim ( 'highsympath.txt' ), status = 'old' ) read ( 1 , * ) nqpath allocate ( qpathvecs ( nqpath , 3 )) do i = 1 , nqpath read ( 1 , * ) qpathvecs ( i ,:) end do !Calculate phonon dispersions allocate ( ph_ens_path ( nqpath , self % numbranches ), & ph_evecs_path ( nqpath , self % numbranches , self % numbranches )) call ph_wann_epw ( self , crys , nqpath , qpathvecs , ph_ens_path , ph_evecs_path ) !Output phonon dispersions write ( saux , \"(I0)\" ) self % numbranches open ( 1 , file = \"ph.ens_qpath\" , status = \"replace\" ) do i = 1 , nqpath write ( 1 , \"(\" // trim ( adjustl ( saux )) // \"E20.10)\" ) ph_ens_path ( i ,:) end do close ( 1 ) !Calculate electron bands allocate ( el_ens_path ( nqpath , self % numwannbands )) call el_wann_epw ( self , crys , nqpath , qpathvecs , el_ens_path , scissor = scissor ) !Output electron dispersions write ( saux , \"(I0)\" ) self % numwannbands open ( 1 , file = \"el.ens_kpath\" , status = \"replace\" ) do i = 1 , nqpath write ( 1 , \"(\" // trim ( adjustl ( saux )) // \"E20.10)\" ) el_ens_path ( i ,:) end do close ( 1 ) allocate ( el_ens_k ( 1 , self % numwannbands ), el_vels_k ( 1 , self % numwannbands , 3 ),& el_evecs_k ( 1 , self % numwannbands , self % numwannbands )) allocate ( el_ens_kp ( 1 , self % numwannbands ), el_vels_kp ( 1 , self % numwannbands , 3 ),& el_evecs_kp ( 1 , self % numwannbands , self % numwannbands )) allocate ( g2_qpath ( nqpath , self % numbranches , self % numwannbands , self % numwannbands )) !Read wave vector of initial electron open ( 1 , file = trim ( 'initialk.txt' ), status = 'old' ) read ( 1 , * ) k ( 1 , :) !Calculate g(k, Rp) call self % gkRp_epw ( num , 0_i64 , k ( 1 ,:)) !Load gmixed from file !Change to data output directory call chdir ( trim ( adjustl ( num % g2dir ))) allocate ( gmixed_k ( self % numwannbands , self % numwannbands , self % numbranches , self % nwsq )) filename = 'gkRp.ik0' open ( 1 , file = filename , status = \"old\" , access = 'stream' ) read ( 1 ) gmixed_k close ( 1 ) !Change back to working directory call chdir ( num % cwd ) call el_wann_epw ( self , crys , 1_i64 , k , el_ens_k , el_vels_k , el_evecs_k , & scissor = scissor ) do i = 1 , nqpath !Over phonon wave vectors path kp ( 1 , :) = k ( 1 , :) + qpathvecs ( i , :) do icart = 1 , 3 if ( kp ( 1 , icart ) >= 1.0_r64 ) kp ( 1 , icart ) = kp ( 1 , icart ) - 1.0_r64 end do !Calculate electrons at this final wave vector call el_wann_epw ( self , crys , 1_i64 , kp , el_ens_kp , el_vels_kp , el_evecs_kp , & scissor = scissor ) do n = 1 , self % numwannbands do m = 1 , self % numwannbands do s = 1 , self % numbranches !Calculate |g(k,k')|&#94;2 g2_qpath ( i , s , m , n ) = self % g2_epw ( crys , k , qpathvecs ( i , :), & el_evecs_k ( 1 , m , :), el_evecs_kp ( 1 , n , :), ph_evecs_path ( i , s , :), & ph_ens_path ( i , s ), gmixed_k , 'ph' ) end do end do end do !The gauge arbitrariness of |g| due to the band and branch degeneraries !are removed below. The code below is closely following the change !to elphon.f90 of Quantum Espresso by C. Verdi and S. Ponce. ! !This modified elphon.f90 was made available during EPW's 2018 !ICTP/Psi-k/CECAM School on Electron-Phonon Physics from First Principles. !Visit for more info: https://docs.epw-code.org/doc/School2018.html !Average over degenerate phonon branches do m = 1 , self % numwannbands do n = 1 , self % numwannbands do s = 1 , self % numbranches deg_count = 0 aux = 0.0_r64 ph_en = ph_ens_path ( i , s ) do sp = 1 , self % numbranches if ( abs ( ph_en - ph_ens_path ( i , sp )) < thres ) then deg_count = deg_count + 1 aux = aux + g2_qpath ( i , sp , m , n ) end if end do g2_qpath ( i , s , m , n ) = aux / dble ( deg_count ) end do end do end do !Average over initial electron bands do s = 1 , self % numbranches do n = 1 , self % numwannbands do m = 1 , self % numwannbands deg_count = 0 aux = 0.0_r64 el_en = el_ens_k ( 1 , m ) do mp = 1 , self % numwannbands if ( abs ( el_en - el_ens_k ( 1 , mp )) < thres ) then deg_count = deg_count + 1 aux = aux + g2_qpath ( i , s , mp , n ) end if end do g2_qpath ( i , s , m , n ) = aux / dble ( deg_count ) end do end do end do !Average over final electron bands do s = 1 , self % numbranches do m = 1 , self % numwannbands do n = 1 , self % numwannbands deg_count = 0 aux = 0.0_r64 el_en = el_ens_kp ( 1 , n ) do np = 1 , self % numwannbands if ( abs ( el_en - el_ens_kp ( 1 , np )) < thres ) then deg_count = deg_count + 1 aux = aux + g2_qpath ( i , s , m , np ) end if end do g2_qpath ( i , s , m , n ) = aux / dble ( deg_count ) end do end do end do end do !Print out |gk(m,n,s,qpath)| open ( 1 , file = 'gk_qpath' , status = \"replace\" ) write ( 1 , * ) '   m    n    s    |gk|[eV]' do i = 1 , nqpath do m = 1 , self % numwannbands do n = 1 , self % numwannbands do s = 1 , self % numbranches write ( 1 , \"(I5, I5, I5, E20.10)\" ) m , n , s , sqrt ( g2_qpath ( i , s , m , n )) end do end do end do end do close ( 1 ) end if sync all end subroutine plot_along_path end module wannier_module","tags":"","loc":"sourcefile/wannier.f90.html"}]}